<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://github.com/kriskowal/q-io/"

    >q-io (v1.13.2)</a>
</h1>
<h4>IO using Q promises</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io">module q-io</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.buffer_stream">
            function <span class="apidocSignatureSpan">q-io.</span>buffer_stream
            <span class="apidocSignatureSpan">(chunks, charset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.chain">
            function <span class="apidocSignatureSpan">q-io.</span>chain
            <span class="apidocSignatureSpan">(end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_root">
            function <span class="apidocSignatureSpan">q-io.</span>fs_root
            <span class="apidocSignatureSpan">(outer, root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.reader">
            function <span class="apidocSignatureSpan">q-io.</span>reader
            <span class="apidocSignatureSpan">(_stream, charset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.writer">
            function <span class="apidocSignatureSpan">q-io.</span>writer
            <span class="apidocSignatureSpan">(_stream, charset)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>buffer_stream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>chain.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>content</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>cookie</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>decorators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>deprecate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>fs2http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>fs_boot</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>fs_common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>html</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>http_apps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>http_cookie</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>json</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>negotiate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>proxy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>redirect</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>route</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.buffer_stream">module q-io.buffer_stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.buffer_stream.buffer_stream">
            function <span class="apidocSignatureSpan">q-io.</span>buffer_stream
            <span class="apidocSignatureSpan">(chunks, charset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.buffer_stream.prototype">module q-io.buffer_stream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.buffer_stream.prototype.close">
            function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.buffer_stream.prototype.destroy">
            function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.buffer_stream.prototype.forEach">
            function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>forEach
            <span class="apidocSignatureSpan">(write, thisp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.buffer_stream.prototype.read">
            function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.buffer_stream.prototype.write">
            function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>write
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.chain">module q-io.chain</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.chain.chain">
            function <span class="apidocSignatureSpan">q-io.</span>chain
            <span class="apidocSignatureSpan">(end)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.chain.prototype">module q-io.chain.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.chain.prototype.use">
            function <span class="apidocSignatureSpan">q-io.chain.prototype.</span>use
            <span class="apidocSignatureSpan">(App)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.content">module q-io.content</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.content.content">
            function <span class="apidocSignatureSpan">q-io.</span>content
            <span class="apidocSignatureSpan">(content, contentType, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.content.Content">
            function <span class="apidocSignatureSpan">q-io.content.</span>Content
            <span class="apidocSignatureSpan">(body, contentType, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.content.ContentRequest">
            function <span class="apidocSignatureSpan">q-io.content.</span>ContentRequest
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.content.Inspect">
            function <span class="apidocSignatureSpan">q-io.content.</span>Inspect
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.content.ParseQuery">
            function <span class="apidocSignatureSpan">q-io.content.</span>ParseQuery
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.content.ok">
            function <span class="apidocSignatureSpan">q-io.content.</span>ok
            <span class="apidocSignatureSpan">(content, contentType, status)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.cookie">module q-io.cookie</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.cookie.CookieJar">
            function <span class="apidocSignatureSpan">q-io.cookie.</span>CookieJar
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.decorators">module q-io.decorators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Date">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Date
            <span class="apidocSignatureSpan">(app, present)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Debug">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Debug
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Decorators">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Decorators
            <span class="apidocSignatureSpan">(decorators, app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Error">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Error
            <span class="apidocSignatureSpan">(app, debug)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Headers">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Headers
            <span class="apidocSignatureSpan">(app, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Log">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Log
            <span class="apidocSignatureSpan">(app, log, stamp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Normalize">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Normalize
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Permanent">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Permanent
            <span class="apidocSignatureSpan">(app, future)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Time">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Time
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.deprecate">module q-io.deprecate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.deprecate.deprecateMethod">
            function <span class="apidocSignatureSpan">q-io.deprecate.</span>deprecateMethod
            <span class="apidocSignatureSpan">(scope, deprecatedFunction, name, alternative)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.deprecate.deprecationWarning">
            function <span class="apidocSignatureSpan">q-io.deprecate.</span>deprecationWarning
            <span class="apidocSignatureSpan">(name, alternative, stackTraceLimit)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.fs">module q-io.fs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.Mock">
            function <span class="apidocSignatureSpan">q-io.fs.</span>Mock
            <span class="apidocSignatureSpan">(files, workingDirectory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.Root">
            function <span class="apidocSignatureSpan">q-io.fs.</span>Root
            <span class="apidocSignatureSpan">(outer, root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.SEPARATORS_RE">
            function <span class="apidocSignatureSpan">q-io.fs.</span>SEPARATORS_RE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.Stats">
            function <span class="apidocSignatureSpan">q-io.fs.</span>Stats
            <span class="apidocSignatureSpan">(nodeStat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.absolute">
            function <span class="apidocSignatureSpan">q-io.fs.</span>absolute
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.append">
            function <span class="apidocSignatureSpan">q-io.fs.</span>append
            <span class="apidocSignatureSpan">(path, content, flags, charset, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.base">
            function <span class="apidocSignatureSpan">q-io.fs.</span>base
            <span class="apidocSignatureSpan">(path, extension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.canonical">
            function <span class="apidocSignatureSpan">q-io.fs.</span>canonical
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.chmod">
            function <span class="apidocSignatureSpan">q-io.fs.</span>chmod
            <span class="apidocSignatureSpan">(path, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.chown">
            function <span class="apidocSignatureSpan">q-io.fs.</span>chown
            <span class="apidocSignatureSpan">(path, uid, gid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.contains">
            function <span class="apidocSignatureSpan">q-io.fs.</span>contains
            <span class="apidocSignatureSpan">(parent, child)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.copy">
            function <span class="apidocSignatureSpan">q-io.fs.</span>copy
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.copyTree">
            function <span class="apidocSignatureSpan">q-io.fs.</span>copyTree
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.directory">
            function <span class="apidocSignatureSpan">q-io.fs.</span>directory
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.exists">
            function <span class="apidocSignatureSpan">q-io.fs.</span>exists
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.extension">
            function <span class="apidocSignatureSpan">q-io.fs.</span>extension
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.isAbsolute">
            function <span class="apidocSignatureSpan">q-io.fs.</span>isAbsolute
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.isDirectory">
            function <span class="apidocSignatureSpan">q-io.fs.</span>isDirectory
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.isFile">
            function <span class="apidocSignatureSpan">q-io.fs.</span>isFile
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.isRelative">
            function <span class="apidocSignatureSpan">q-io.fs.</span>isRelative
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.isRoot">
            function <span class="apidocSignatureSpan">q-io.fs.</span>isRoot
            <span class="apidocSignatureSpan">(first)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.isSymbolicLink">
            function <span class="apidocSignatureSpan">q-io.fs.</span>isSymbolicLink
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.join">
            function <span class="apidocSignatureSpan">q-io.fs.</span>join
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.lastAccessed">
            function <span class="apidocSignatureSpan">q-io.fs.</span>lastAccessed
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.lastModified">
            function <span class="apidocSignatureSpan">q-io.fs.</span>lastModified
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.link">
            function <span class="apidocSignatureSpan">q-io.fs.</span>link
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.list">
            function <span class="apidocSignatureSpan">q-io.fs.</span>list
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.listDirectoryTree">
            function <span class="apidocSignatureSpan">q-io.fs.</span>listDirectoryTree
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.listTree">
            function <span class="apidocSignatureSpan">q-io.fs.</span>listTree
            <span class="apidocSignatureSpan">(basePath, guard)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.makeDirectory">
            function <span class="apidocSignatureSpan">q-io.fs.</span>makeDirectory
            <span class="apidocSignatureSpan">(path, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.makeTree">
            function <span class="apidocSignatureSpan">q-io.fs.</span>makeTree
            <span class="apidocSignatureSpan">(path, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.merge">
            function <span class="apidocSignatureSpan">q-io.fs.</span>merge
            <span class="apidocSignatureSpan">(fss)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.mock">
            function <span class="apidocSignatureSpan">q-io.fs.</span>mock
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.move">
            function <span class="apidocSignatureSpan">q-io.fs.</span>move
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.normal">
            function <span class="apidocSignatureSpan">q-io.fs.</span>normal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.open">
            function <span class="apidocSignatureSpan">q-io.fs.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.read">
            function <span class="apidocSignatureSpan">q-io.fs.</span>read
            <span class="apidocSignatureSpan">(path, flags, charset, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.readLink">
            function <span class="apidocSignatureSpan">q-io.fs.</span>readLink
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.relative">
            function <span class="apidocSignatureSpan">q-io.fs.</span>relative
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.relativeFromDirectory">
            function <span class="apidocSignatureSpan">q-io.fs.</span>relativeFromDirectory
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.relativeFromFile">
            function <span class="apidocSignatureSpan">q-io.fs.</span>relativeFromFile
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.remove">
            function <span class="apidocSignatureSpan">q-io.fs.</span>remove
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.removeDirectory">
            function <span class="apidocSignatureSpan">q-io.fs.</span>removeDirectory
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.removeTree">
            function <span class="apidocSignatureSpan">q-io.fs.</span>removeTree
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.rename">
            function <span class="apidocSignatureSpan">q-io.fs.</span>rename
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.reroot">
            function <span class="apidocSignatureSpan">q-io.fs.</span>reroot
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.resolve">
            function <span class="apidocSignatureSpan">q-io.fs.</span>resolve
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.root">
            function <span class="apidocSignatureSpan">q-io.fs.</span>root
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.split">
            function <span class="apidocSignatureSpan">q-io.fs.</span>split
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.stat">
            function <span class="apidocSignatureSpan">q-io.fs.</span>stat
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.statFd">
            function <span class="apidocSignatureSpan">q-io.fs.</span>statFd
            <span class="apidocSignatureSpan">(fd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.statLink">
            function <span class="apidocSignatureSpan">q-io.fs.</span>statLink
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.symbolicCopy">
            function <span class="apidocSignatureSpan">q-io.fs.</span>symbolicCopy
            <span class="apidocSignatureSpan">(source, target, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.symbolicLink">
            function <span class="apidocSignatureSpan">q-io.fs.</span>symbolicLink
            <span class="apidocSignatureSpan">(target, relative, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.toObject">
            function <span class="apidocSignatureSpan">q-io.fs.</span>toObject
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.write">
            function <span class="apidocSignatureSpan">q-io.fs.</span>write
            <span class="apidocSignatureSpan">(path, content, flags, charset, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">q-io.fs.</span>ROOT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">q-io.fs.</span>SEPARATOR</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.fs2http">module q-io.fs2http</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs2http.Client">
            function <span class="apidocSignatureSpan">q-io.fs2http.</span>Client
            <span class="apidocSignatureSpan">(fs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs2http.read">
            function <span class="apidocSignatureSpan">q-io.fs2http.</span>read
            <span class="apidocSignatureSpan">(request, qualifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs2http.request">
            function <span class="apidocSignatureSpan">q-io.fs2http.</span>request
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.fs_boot">module q-io.fs_boot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.SEPARATORS_RE">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>SEPARATORS_RE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.base">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>base
            <span class="apidocSignatureSpan">(path, extension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.directory">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>directory
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.extension">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>extension
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.isAbsolute">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>isAbsolute
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.isRelative">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>isRelative
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.isRoot">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>isRoot
            <span class="apidocSignatureSpan">(first)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.join">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>join
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.normal">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>normal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.resolve">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>resolve
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.root">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>root
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.split">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>split
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">q-io.fs_boot.</span>ROOT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">q-io.fs_boot.</span>SEPARATOR</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.fs_common">module q-io.fs_common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_common.update">
            function <span class="apidocSignatureSpan">q-io.fs_common.</span>update
            <span class="apidocSignatureSpan">(exports, workingDirectory)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.fs_root">module q-io.fs_root</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_root.fs_root">
            function <span class="apidocSignatureSpan">q-io.</span>fs_root
            <span class="apidocSignatureSpan">(outer, root)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.html">module q-io.html</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.html.HandleHtmlFragmentResponses">
            function <span class="apidocSignatureSpan">q-io.html.</span>HandleHtmlFragmentResponses
            <span class="apidocSignatureSpan">(app, handleHtmlFragmentResponse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.html.escapeHtml">
            function <span class="apidocSignatureSpan">q-io.html.</span>escapeHtml
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.html.handleHtmlFragmentResponse">
            function <span class="apidocSignatureSpan">q-io.html.</span>handleHtmlFragmentResponse
            <span class="apidocSignatureSpan">(response)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.http">module q-io.http</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http.ClientResponse">
            function <span class="apidocSignatureSpan">q-io.http.</span>ClientResponse
            <span class="apidocSignatureSpan">(_response, charset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http.Server">
            function <span class="apidocSignatureSpan">q-io.http.</span>Server
            <span class="apidocSignatureSpan">(respond)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http.ServerRequest">
            function <span class="apidocSignatureSpan">q-io.http.</span>ServerRequest
            <span class="apidocSignatureSpan">(_request, ssl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http.ServerResponse">
            function <span class="apidocSignatureSpan">q-io.http.</span>ServerResponse
            <span class="apidocSignatureSpan">(_response, ssl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http.normalizeRequest">
            function <span class="apidocSignatureSpan">q-io.http.</span>normalizeRequest
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http.normalizeResponse">
            function <span class="apidocSignatureSpan">q-io.http.</span>normalizeResponse
            <span class="apidocSignatureSpan">(response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http.read">
            function <span class="apidocSignatureSpan">q-io.http.</span>read
            <span class="apidocSignatureSpan">(request, qualifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http.request">
            function <span class="apidocSignatureSpan">q-io.http.</span>request
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.http_apps">module q-io.http_apps</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Branch">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Branch
            <span class="apidocSignatureSpan">(paths, notFound)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Cap">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Cap
            <span class="apidocSignatureSpan">(app, notFound)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Chain">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Chain
            <span class="apidocSignatureSpan">(end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Charset">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Charset
            <span class="apidocSignatureSpan">(types, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Content">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Content
            <span class="apidocSignatureSpan">(body, contentType, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.ContentRequest">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>ContentRequest
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.ContentType">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>ContentType
            <span class="apidocSignatureSpan">(types, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.CookieJar">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>CookieJar
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Date">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Date
            <span class="apidocSignatureSpan">(app, present)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Debug">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Debug
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Decorators">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Decorators
            <span class="apidocSignatureSpan">(decorators, app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.DirectoryIndex">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>DirectoryIndex
            <span class="apidocSignatureSpan">(app, indexFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Encoding">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Encoding
            <span class="apidocSignatureSpan">(types, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Error">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Error
            <span class="apidocSignatureSpan">(app, debug)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.File">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>File
            <span class="apidocSignatureSpan">(path, contentType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.FileTree">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>FileTree
            <span class="apidocSignatureSpan">(root, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.HandleHtmlFragmentResponses">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>HandleHtmlFragmentResponses
            <span class="apidocSignatureSpan">(app, handleHtmlFragmentResponse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.HandleJsonResponses">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>HandleJsonResponses
            <span class="apidocSignatureSpan">(app, reviver, tab)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Headers">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Headers
            <span class="apidocSignatureSpan">(app, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Host">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Host
            <span class="apidocSignatureSpan">(appForHost, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Inspect">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Inspect
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Json">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Json
            <span class="apidocSignatureSpan">(app, reviver, tabs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.JsonRequest">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>JsonRequest
            <span class="apidocSignatureSpan">(app, badRequest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Language">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Language
            <span class="apidocSignatureSpan">(types, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.ListDirectories">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>ListDirectories
            <span class="apidocSignatureSpan">(app, listDirectory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Log">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Log
            <span class="apidocSignatureSpan">(app, log, stamp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Method">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Method
            <span class="apidocSignatureSpan">(methods, methodNotAllowed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Normalize">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Normalize
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.ParseQuery">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>ParseQuery
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Permanent">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Permanent
            <span class="apidocSignatureSpan">(app, future)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.PermanentRedirect">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>PermanentRedirect
            <span class="apidocSignatureSpan">(location, status, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.PermanentRedirectTree">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>PermanentRedirectTree
            <span class="apidocSignatureSpan">(location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Proxy">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Proxy
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.ProxyTree">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>ProxyTree
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Redirect">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Redirect
            <span class="apidocSignatureSpan">(location, status, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.RedirectTrap">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>RedirectTrap
            <span class="apidocSignatureSpan">(app, maxRedirects)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.RedirectTree">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>RedirectTree
            <span class="apidocSignatureSpan">(location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Select">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Select
            <span class="apidocSignatureSpan">(select)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Tap">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Tap
            <span class="apidocSignatureSpan">(app, tap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.TemporaryRedirect">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>TemporaryRedirect
            <span class="apidocSignatureSpan">(location, status, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.TemporaryRedirectTree">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>TemporaryRedirectTree
            <span class="apidocSignatureSpan">(location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Time">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Time
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Trap">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Trap
            <span class="apidocSignatureSpan">(app, trap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.appForStatus">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>appForStatus
            <span class="apidocSignatureSpan">(status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.badRequest">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>badRequest
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.content">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>content
            <span class="apidocSignatureSpan">(content, contentType, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.directory">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>directory
            <span class="apidocSignatureSpan">(request, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.escapeHtml">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>escapeHtml
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.etag">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>etag
            <span class="apidocSignatureSpan">(stat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.file">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>file
            <span class="apidocSignatureSpan">(request, path, contentType, fs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.handleHtmlFragmentResponse">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>handleHtmlFragmentResponse
            <span class="apidocSignatureSpan">(response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.handleJsonResponse">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>handleJsonResponse
            <span class="apidocSignatureSpan">(response, revivier, tab)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.htmlResponseForStatus">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>htmlResponseForStatus
            <span class="apidocSignatureSpan">(request, status, message, addendum)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.isRedirect">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>isRedirect
            <span class="apidocSignatureSpan">(response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.json">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>json
            <span class="apidocSignatureSpan">(content, reviver, tabs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.listDirectory">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectory
            <span class="apidocSignatureSpan">(request, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.listDirectoryData">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryData
            <span class="apidocSignatureSpan">(request, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.listDirectoryHtmlFragment">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryHtmlFragment
            <span class="apidocSignatureSpan">(request, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.listDirectoryJson">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryJson
            <span class="apidocSignatureSpan">(request, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.listDirectoryMarkdown">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryMarkdown
            <span class="apidocSignatureSpan">(request, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.listDirectoryText">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryText
            <span class="apidocSignatureSpan">(request, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.methodNotAllowed">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>methodNotAllowed
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.negotiate">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>negotiate
            <span class="apidocSignatureSpan">(request, types, header)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.noLanguage">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>noLanguage
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.notAcceptable">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>notAcceptable
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.notFound">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>notFound
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.ok">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>ok
            <span class="apidocSignatureSpan">(content, contentType, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.permanentRedirect">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>permanentRedirect
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.permanentRedirectTree">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>permanentRedirectTree
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.redirect">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>redirect
            <span class="apidocSignatureSpan">(request, location, status, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.redirectHtml">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>redirectHtml
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.redirectText">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>redirectText
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.redirectTree">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>redirectTree
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.responseForStatus">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>responseForStatus
            <span class="apidocSignatureSpan">(request, status, addendum)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.statusWithNoEntityBody">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>statusWithNoEntityBody
            <span class="apidocSignatureSpan">(status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.temporaryRedirect">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>temporaryRedirect
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.temporaryRedirectTree">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>temporaryRedirectTree
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.textResponseForStatus">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>textResponseForStatus
            <span class="apidocSignatureSpan">(request, status, message, addendum)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.http_apps.</span>statusCodes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.http_apps.</span>statusMessages</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.http_cookie">module q-io.http_cookie</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_cookie.parse">
            function <span class="apidocSignatureSpan">q-io.http_cookie.</span>parse
            <span class="apidocSignatureSpan">(cookie, date)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_cookie.stringify">
            function <span class="apidocSignatureSpan">q-io.http_cookie.</span>stringify
            <span class="apidocSignatureSpan">(key, value, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.json">module q-io.json</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.json.json">
            function <span class="apidocSignatureSpan">q-io.</span>json
            <span class="apidocSignatureSpan">(content, reviver, tabs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.json.HandleJsonResponses">
            function <span class="apidocSignatureSpan">q-io.json.</span>HandleJsonResponses
            <span class="apidocSignatureSpan">(app, reviver, tab)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.json.Json">
            function <span class="apidocSignatureSpan">q-io.json.</span>Json
            <span class="apidocSignatureSpan">(app, reviver, tabs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.json.JsonRequest">
            function <span class="apidocSignatureSpan">q-io.json.</span>JsonRequest
            <span class="apidocSignatureSpan">(app, badRequest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.json.handleJsonResponse">
            function <span class="apidocSignatureSpan">q-io.json.</span>handleJsonResponse
            <span class="apidocSignatureSpan">(response, revivier, tab)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.negotiate">module q-io.negotiate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.negotiate.negotiate">
            function <span class="apidocSignatureSpan">q-io.</span>negotiate
            <span class="apidocSignatureSpan">(request, types, header)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.negotiate.Charset">
            function <span class="apidocSignatureSpan">q-io.negotiate.</span>Charset
            <span class="apidocSignatureSpan">(types, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.negotiate.ContentType">
            function <span class="apidocSignatureSpan">q-io.negotiate.</span>ContentType
            <span class="apidocSignatureSpan">(types, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.negotiate.Encoding">
            function <span class="apidocSignatureSpan">q-io.negotiate.</span>Encoding
            <span class="apidocSignatureSpan">(types, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.negotiate.Host">
            function <span class="apidocSignatureSpan">q-io.negotiate.</span>Host
            <span class="apidocSignatureSpan">(appForHost, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.negotiate.Language">
            function <span class="apidocSignatureSpan">q-io.negotiate.</span>Language
            <span class="apidocSignatureSpan">(types, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.negotiate.Method">
            function <span class="apidocSignatureSpan">q-io.negotiate.</span>Method
            <span class="apidocSignatureSpan">(methods, methodNotAllowed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.negotiate.Select">
            function <span class="apidocSignatureSpan">q-io.negotiate.</span>Select
            <span class="apidocSignatureSpan">(select)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.proxy">module q-io.proxy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.proxy.Proxy">
            function <span class="apidocSignatureSpan">q-io.proxy.</span>Proxy
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.proxy.ProxyTree">
            function <span class="apidocSignatureSpan">q-io.proxy.</span>ProxyTree
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.reader">module q-io.reader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.reader.reader">
            function <span class="apidocSignatureSpan">q-io.</span>reader
            <span class="apidocSignatureSpan">(_stream, charset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.reader.join">
            function <span class="apidocSignatureSpan">q-io.reader.</span>join
            <span class="apidocSignatureSpan">(buffers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.reader.read">
            function <span class="apidocSignatureSpan">q-io.reader.</span>read
            <span class="apidocSignatureSpan">(stream, charset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.redirect">module q-io.redirect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.redirect">
            function <span class="apidocSignatureSpan">q-io.</span>redirect
            <span class="apidocSignatureSpan">(request, location, status, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.PermanentRedirect">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>PermanentRedirect
            <span class="apidocSignatureSpan">(location, status, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.PermanentRedirectTree">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>PermanentRedirectTree
            <span class="apidocSignatureSpan">(location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.Redirect">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>Redirect
            <span class="apidocSignatureSpan">(location, status, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.RedirectTrap">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>RedirectTrap
            <span class="apidocSignatureSpan">(app, maxRedirects)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.RedirectTree">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>RedirectTree
            <span class="apidocSignatureSpan">(location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.TemporaryRedirect">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>TemporaryRedirect
            <span class="apidocSignatureSpan">(location, status, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.TemporaryRedirectTree">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>TemporaryRedirectTree
            <span class="apidocSignatureSpan">(location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.isRedirect">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>isRedirect
            <span class="apidocSignatureSpan">(response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.permanentRedirect">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>permanentRedirect
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.permanentRedirectTree">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>permanentRedirectTree
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.redirectHtml">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>redirectHtml
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.redirectText">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>redirectText
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.redirectTree">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>redirectTree
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.temporaryRedirect">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>temporaryRedirect
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.temporaryRedirectTree">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>temporaryRedirectTree
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.route">module q-io.route</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.route.Branch">
            function <span class="apidocSignatureSpan">q-io.route.</span>Branch
            <span class="apidocSignatureSpan">(paths, notFound)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.route.Cap">
            function <span class="apidocSignatureSpan">q-io.route.</span>Cap
            <span class="apidocSignatureSpan">(app, notFound)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.route.FirstFound">
            function <span class="apidocSignatureSpan">q-io.route.</span>FirstFound
            <span class="apidocSignatureSpan">(cascade)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.route.Tap">
            function <span class="apidocSignatureSpan">q-io.route.</span>Tap
            <span class="apidocSignatureSpan">(app, tap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.route.Trap">
            function <span class="apidocSignatureSpan">q-io.route.</span>Trap
            <span class="apidocSignatureSpan">(app, trap)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.status">module q-io.status</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.appForStatus">
            function <span class="apidocSignatureSpan">q-io.status.</span>appForStatus
            <span class="apidocSignatureSpan">(status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.badRequest">
            function <span class="apidocSignatureSpan">q-io.status.</span>badRequest
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.htmlResponseForStatus">
            function <span class="apidocSignatureSpan">q-io.status.</span>htmlResponseForStatus
            <span class="apidocSignatureSpan">(request, status, message, addendum)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.methodNotAllowed">
            function <span class="apidocSignatureSpan">q-io.status.</span>methodNotAllowed
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.noLanguage">
            function <span class="apidocSignatureSpan">q-io.status.</span>noLanguage
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.notAcceptable">
            function <span class="apidocSignatureSpan">q-io.status.</span>notAcceptable
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.notFound">
            function <span class="apidocSignatureSpan">q-io.status.</span>notFound
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.responseForStatus">
            function <span class="apidocSignatureSpan">q-io.status.</span>responseForStatus
            <span class="apidocSignatureSpan">(request, status, addendum)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.statusWithNoEntityBody">
            function <span class="apidocSignatureSpan">q-io.status.</span>statusWithNoEntityBody
            <span class="apidocSignatureSpan">(status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.textResponseForStatus">
            function <span class="apidocSignatureSpan">q-io.status.</span>textResponseForStatus
            <span class="apidocSignatureSpan">(request, status, message, addendum)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.status.</span>statusCodes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.status.</span>statusMessages</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.writer">module q-io.writer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.writer.writer">
            function <span class="apidocSignatureSpan">q-io.</span>writer
            <span class="apidocSignatureSpan">(_stream, charset)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io" id="apidoc.module.q-io">module q-io</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.buffer_stream" id="apidoc.element.q-io.buffer_stream">
        function <span class="apidocSignatureSpan">q-io.</span>buffer_stream
        <span class="apidocSignatureSpan">(chunks, charset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BufferStream(chunks, charset) {
    if (!(this instanceof BufferStream)) {
        return new BufferStream(chunks, charset);
    }
    if (!chunks) {
        chunks = [];
    } else if (!Array.isArray(chunks)) {
        chunks = [chunks];
    }
    this._charset = charset;
    this._chunks = chunks;
    this._close = Q.defer();
    this.closed = this._close.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.chain" id="apidoc.element.q-io.chain">
        function <span class="apidocSignatureSpan">q-io.</span>chain
        <span class="apidocSignatureSpan">(end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(end) {
    var self = Object.create(Chain.prototype);
    self.end = end || function (next) {
        return next;
    };
    return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_root" id="apidoc.element.q-io.fs_root">
        function <span class="apidocSignatureSpan">q-io.</span>fs_root
        <span class="apidocSignatureSpan">(outer, root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RootFs(outer, root) {
    var inner = Object.create(BOOT);

    function attenuate(path) {

        // the machinations of projecting a path inside a
        // subroot
        var actual;
        // if it&#x27;s absolute, we want the path relative to
        // the root of the inner file system
        if (outer.isAbsolute(path)) {
            actual = outer.relativeFromDirectory(outer.ROOT, path);
        } else {
            actual = path;
        }
        // we join the path onto the root of the inner file
        // system so that parent references from the root
        // return to the root, emulating standard unix
        // behavior
        actual = outer.join(outer.ROOT, actual);
        // then we reconstruct the path relative to the
        // inner root
        actual = outer.relativeFromDirectory(outer.ROOT, actual);
        // and rejoin it on the outer root
        actual = outer.join(root, actual);
        // and find the corresponding real path
        return outer.canonical(actual)
        .then(function (actual) {
            return actual;
        }, function () {
            return actual;
        }).then(function (actual) {
            // and verify that the outer canonical path is
            // actually inside the inner canonical path, to
            // prevent break-outs
            if (outer.contains(root, actual)) {
                return {
                    &#x22;inner&#x22;: outer.join(outer.ROOT, outer.relativeFromDirectory(root, actual)),
                    &#x22;outer&#x22;: actual
                };
            } else {
                return Q.reject(&#x22;Can&#x27;t find: &#x22; + JSON.stringify(path));
            }
        });
    }

    function workingDirectory() {
        return outer.ROOT;
    }

    COMMON.update(inner, workingDirectory);

    inner.list = function (path) {
        return attenuate(path).then(function (path) {
            return outer.list(path.outer);
        }).then(null, function (reason) {
            return Q.reject(&#x22;Can&#x27;t list &#x22; + JSON.stringify(path));
        });
    };

    inner.open = function (path, flags, charset) {
        return attenuate(path).then(function (path) {
            return outer.open(path.outer, flags, charset);
        }).then(null, function (reason) {
            return Q.reject(&#x22;Can&#x27;t open &#x22; + JSON.stringify(path));
        });
    };

    inner.stat = function (path) {
        return attenuate(path).then(function (path) {
            return outer.stat(path.outer);
        }).then(null, function (reason) {
            return Q.reject(&#x22;Can&#x27;t stat &#x22; + JSON.stringify(path));
        });
    };

    inner.statLink = function (path) {
        return attenuate(path).then(function (path) {
            return outer.statLink(path.outer);
        }).then(null, function (reason) {
            return Q.reject(&#x22;Can&#x27;t statLink &#x22; + JSON.stringify(path));
        });
    };

    inner.canonical = function (path) {
        return attenuate(path).then(function (path) {
            return path.inner;
        }).then(null, function (reason) {
            return Q.reject(&#x22;Can&#x27;t find canonical of &#x22; + JSON.stringify(path));
        });
    };

    inner.makeDirectory = function (path) {
        return attenuate(path).then(function (path) {
            return outer.makeDirectory(path.outer);
        }).catch(function (error) {
            throw new Error(&#x22;Can&#x27;t make directory &#x22; + JSON.stringify(path));
        });
    };

    inner.removeDirectory = function (path) {
        return attenuate(path).then(function (path) {
            return outer.removeDirectory(path.outer);
        }).catch(function (error) {
            throw new Error(&#x22;Can&#x27;t remove directory &#x22; + JSON.stringify(path));
        });
    };

    inner.remove = function (path) {
        return attenuate(path).then(function (path) {
            return outer.remove(path.outer);
        }).catch(function (error) {
            throw new Error(&#x22;Can&#x27;t remove &#x22; + JSON.stringify(path));
        });
    };

    inner.makeTree = function (path) {
        return attenuate(path).then(function (path) {
            return outer.makeT ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.reader" id="apidoc.element.q-io.reader">
        function <span class="apidocSignatureSpan">q-io.</span>reader
        <span class="apidocSignatureSpan">(_stream, charset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(_stream, charset) {
    var self = Object.create(Reader.prototype);

    if (charset &#x26;&#x26; _stream.setEncoding) // TODO complain about inconsistency
        _stream.setEncoding(charset);

    var begin = Q.defer();
    var end = Q.defer();

    _stream.on(&#x22;error&#x22;, function (reason) {
        begin.reject(reason);
    });

    var chunks = [];
    var receiver;

    _stream.on(&#x22;end&#x22;, function () {
        begin.resolve(self);
        end.resolve()
    });

    _stream.on(&#x22;data&#x22;, function (chunk) {
        begin.resolve(self);
        if (receiver) {
            receiver(chunk);
        } else {
            chunks.push(chunk);
        }
    });

    function slurp() {
        var result;
        if (charset) {
            result = chunks.join(&#x22;&#x22;);
        } else {
            result = self.constructor.join(chunks);
        }
        chunks.splice(0, chunks.length);
        return result;
    }

<span class="apidocCodeCommentSpan">    /***
     * Reads all of the remaining data from the stream.
     * @returns {Promise * String} a promise for a String
     * containing the entirety the remaining stream.
     */
</span>    self.read = function () {
        receiver = undefined;
        var deferred = Q.defer();
        Q.done(end.promise, function () {
            deferred.resolve(slurp());
        });
        return deferred.promise;
    };

    /***
     * Reads and writes all of the remaining data from the
     * stream in chunks.
     * @param {Function(Promise * String)} write a function
     * to be called on each chunk of input from this stream.
     * @returns {Promise * Undefined} a promise that will
     * be resolved when the input is depleted.
     */
    self.forEach = function (write) {
        if (chunks &#x26;&#x26; chunks.length)
            write(slurp());
        receiver = write;
        return Q.when(end.promise, function () {
            receiver = undefined;
        });
    };

    self.close = function () {
        _stream.destroy();
    };

    self.node = _stream;

    return begin.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.writer" id="apidoc.element.q-io.writer">
        function <span class="apidocSignatureSpan">q-io.</span>writer
        <span class="apidocSignatureSpan">(_stream, charset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writer(_stream, charset) {
    var self = Object.create(Writer.prototype);

    if (charset &#x26;&#x26; _stream.setEncoding) // TODO complain about inconsistency
        _stream.setEncoding(charset);

    var drained = Q.defer();

    _stream.on(&#x22;error&#x22;, function (reason) {
        drained.reject(reason);
        drained = Q.defer();
    });

    _stream.on(&#x22;drain&#x22;, function () {
        drained.resolve();
        drained = Q.defer();
    });

<span class="apidocCodeCommentSpan">    /***
     * Writes content to the stream.
     * @param {String} content
     * @returns {Promise * Undefined} a promise that will
     * be resolved when the buffer is empty, meaning
     * that all of the content has been sent.
     */
</span>    self.write = function (content) {
        if (!_stream.writeable &#x26;&#x26; !_stream.writable)
            return Q.reject(new Error(&#x22;Can&#x27;t write to non-writable (possibly closed) stream&#x22;));
        if (typeof content !== &#x22;string&#x22;) {
            content = new Buffer(content);
        }
        if (!_stream.write(content)) {
            return drained.promise;
        } else {
            return Q.resolve();
        }
    };

    /***
     * Waits for all data to flush on the stream.
     *
     * @returns {Promise * Undefined} a promise that will
     * be resolved when the buffer is empty
     */
    self.flush = function () {
        return drained.promise;
    };

    /***
     * Closes the stream, waiting for the internal buffer
     * to flush.
     *
     * @returns {Promise * Undefined} a promise that will
     * be resolved when the stream has finished writing,
     * flushing, and closed.
     */
    self.close = function () {
        var finished;

        if (supportsFinish) { // new Streams, listen for `finish` event
            finished = Q.defer();
            _stream.on(&#x22;finish&#x22;, function () {
                finished.resolve();
            });
            _stream.on(&#x22;error&#x22;, function (reason) {
                finished.reject(reason);
            });
        }

        _stream.end();
        drained.resolve(); // we will get no further drain events
        if (finished) { // closing not explicitly observable
            return finished.promise;
        } else {
            return Q(); // just resolve for old Streams
        }
    };

    /***
     * Terminates writing on a stream, closing before
     * the internal buffer drains.
     *
     * @returns {Promise * Undefined} a promise that will
     * be resolved when the stream has finished closing.
     */
    self.destroy = function () {
        _stream.destroy();
        drained.resolve(); // we will get no further drain events
        return Q.resolve(); // destruction not explicitly observable
    };

    self.node = _stream;

    return Q(self); // todo returns the begin.promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.buffer_stream" id="apidoc.module.q-io.buffer_stream">module q-io.buffer_stream</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.buffer_stream.buffer_stream" id="apidoc.element.q-io.buffer_stream.buffer_stream">
        function <span class="apidocSignatureSpan">q-io.</span>buffer_stream
        <span class="apidocSignatureSpan">(chunks, charset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BufferStream(chunks, charset) {
    if (!(this instanceof BufferStream)) {
        return new BufferStream(chunks, charset);
    }
    if (!chunks) {
        chunks = [];
    } else if (!Array.isArray(chunks)) {
        chunks = [chunks];
    }
    this._charset = charset;
    this._chunks = chunks;
    this._close = Q.defer();
    this.closed = this._close.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.buffer_stream.prototype" id="apidoc.module.q-io.buffer_stream.prototype">module q-io.buffer_stream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.buffer_stream.prototype.close" id="apidoc.element.q-io.buffer_stream.prototype.close">
        function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    this._close.resolve();
    return Q.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    } else if (content instanceof Buffer) {
        flags += &#x22;b&#x22;;
    }
    options.flags = flags;
    return Q.when(self.open(path, options), function (stream) {
        return Q.when(stream.write(content), function () {
            return stream.<span class="apidocCodeKeywordSpan">close</span>();
        });
    });
};

/**
 * Append content to the end of a file.
 * @param {String} path    Path to the file.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.buffer_stream.prototype.destroy" id="apidoc.element.q-io.buffer_stream.prototype.destroy">
        function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
    this._close.resolve();
    return Q.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        receiver = write;
        return Q.when(end.promise, function () {
            receiver = undefined;
        });
    };

    self.close = function () {
        _stream.<span class="apidocCodeKeywordSpan">destroy</span>();
    };

    self.node = _stream;

    return begin.promise;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.buffer_stream.prototype.forEach" id="apidoc.element.q-io.buffer_stream.prototype.forEach">
        function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>forEach
        <span class="apidocSignatureSpan">(write, thisp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (write, thisp) {
    var self = this;
    var chunks = self._chunks;
    return Q.fcall(function () {
        chunks.splice(0, chunks.length).forEach(write, thisp);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.closed = this._close.promise;
}

BufferStream.prototype.forEach = function (write, thisp) {
var self = this;
var chunks = self._chunks;
return Q.fcall(function () {
    chunks.splice(0, chunks.length).<span class="apidocCodeKeywordSpan">forEach</span>(write, thisp);
});
};

BufferStream.prototype.read = function () {
var result;
result = Reader.join(this._chunks);
if (this._charset) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.buffer_stream.prototype.read" id="apidoc.element.q-io.buffer_stream.prototype.read">
        function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function () {
    var result;
    result = Reader.join(this._chunks);
    if (this._charset) {
        result = result.toString(this._charset);
    }
    return Q.resolve(result);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
into memory.  It returns a promise for the whole file contents.  By
default, `read` provides a string decoded from UTF-8.  With the bytewise
mode flag, provides a `Buffer`.

The options argument is identical to that of `open`.

```javascript
return FS.<span class="apidocCodeKeywordSpan">read</span>(__filename, &#x22;b&#x22;)
.then(function (content) {
    // ...
})
```

```javascript
return FS.read(__filename, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.buffer_stream.prototype.write" id="apidoc.element.q-io.buffer_stream.prototype.write">
        function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>write
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (chunk) {
    if (this._charset) {
        chunk = new Buffer(String(chunk), this._charset);
    } else {
        if (!(chunk instanceof Buffer)) {
            throw new Error(&#x22;Can&#x27;t write strings to buffer stream without a charset: &#x22; + chunk);
        }
    }
    this._chunks.push(chunk);
    return Q.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`write` is a shortcut for opening a file and writing its entire content
from a single string or buffer.

The options are identical to that of `open`, but the &#x22;w&#x22; flag is
implied, and the &#x22;b&#x22; flag is implied if the content is a buffer.

```javascript
return FS.<span class="apidocCodeKeywordSpan">write</span>(&#x22;hello.txt&#x22;, &#x22;Hello, World!\n&#x22;)
.then(function () {
    return FS.read(&#x22;hello.txt&#x22;)
})
.then(function (hello) {
    expect(hello).toBe(&#x22;Hello, World!\n&#x22;)
})
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.chain" id="apidoc.module.q-io.chain">module q-io.chain</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.chain.chain" id="apidoc.element.q-io.chain.chain">
        function <span class="apidocSignatureSpan">q-io.</span>chain
        <span class="apidocSignatureSpan">(end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(end) {
    var self = Object.create(Chain.prototype);
    self.end = end || function (next) {
        return next;
    };
    return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.chain.prototype" id="apidoc.module.q-io.chain.prototype">module q-io.chain.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.chain.prototype.use" id="apidoc.element.q-io.chain.prototype.use">
        function <span class="apidocSignatureSpan">q-io.chain.prototype.</span>use
        <span class="apidocSignatureSpan">(App)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">use = function (App) {
    if (!App) throw new Error(&#x22;App is not defined after &#x22; + this.app);
    var args = Array.prototype.slice.call(arguments, 1);
    var self = this;
    this.end = (function (End) {
        return function Self(next) {
            if (self.end !== Self &#x26;&#x26; !next) throw new Error(&#x22;App chain is broken after &#x22; + App);
            return End(App.apply(null, [next].concat(args)));
        };
    })(this.end);
    this.app = App;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.content" id="apidoc.module.q-io.content">module q-io.content</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.content.content" id="apidoc.element.q-io.content.content">
        function <span class="apidocSignatureSpan">q-io.</span>content
        <span class="apidocSignatureSpan">(content, contentType, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">content = function (content, contentType, status) {
    status = status || 200;
    content = content || &#x22;&#x22;;
    if (typeof content === &#x22;string&#x22;) {
        content = [content];
    }
    contentType = contentType || &#x22;text/plain&#x22;;
    return {
        &#x22;status&#x22;: status,
        &#x22;headers&#x22;: {
            &#x22;content-type&#x22;: contentType
        },
        &#x22;body&#x22;: content
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* response body
* @param {String} contentType
* @param {Number} status
* @returns {App} a Q-JSGI app
*/
exports.Content = function (body, contentType, status) {
   return function () {
       return exports.<span class="apidocCodeKeywordSpan">content</span>(body, contentType, status);
   };
};

/**
* Returns a Q-JSGI response with the given content.
* @param {Body} content (optional) defaults to `[&#x22;&#x22;]`
* @param {String} contentType (optional) defaults to `&#x22;text/plain&#x22;`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.content.Content" id="apidoc.element.q-io.content.Content">
        function <span class="apidocSignatureSpan">q-io.content.</span>Content
        <span class="apidocSignatureSpan">(body, contentType, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Content = function (body, contentType, status) {
    return function () {
        return exports.content(body, contentType, status);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.content.ContentRequest" id="apidoc.element.q-io.content.ContentRequest">
        function <span class="apidocSignatureSpan">q-io.content.</span>ContentRequest
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ContentRequest = function (app) {
    return function (request, response) {
        return Q.when(request.body.read(), function (body) {
            return app(body, request, response);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function(Request, Object):Response} app
 * @param {App} badRequest
 * @returns {App}
 */
exports.JsonRequest = function (app, badRequest) {
if (!badRequest)
    badRequest = Status.badRequest;
return Content.<span class="apidocCodeKeywordSpan">ContentRequest</span>(function (content, request, response) {
    try {
        var object = JSON.parse(content);
    } catch (error) {
        return badRequest(request, error);
    }
    return app(object, request, response);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.content.Inspect" id="apidoc.element.q-io.content.Inspect">
        function <span class="apidocSignatureSpan">q-io.content.</span>Inspect
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Inspect = function (app) {
    return Negotiate.Method({&#x22;GET&#x22;: function (request, response) {
        return Q.when(app(request, response), function (object) {
            return {
                status: 200,
                headers: {
                    &#x22;content-type&#x22;: &#x22;text/plain&#x22;
                },
                body: [inspect(object)]
            }
        });
    }});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.content.ParseQuery" id="apidoc.element.q-io.content.ParseQuery">
        function <span class="apidocSignatureSpan">q-io.content.</span>ParseQuery
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ParseQuery = function (app) {
    return function (request, response) {
        request.query = QS.parse(URL.parse(request.url).query || &#x22;&#x22;);
        return app(request, response);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.content.ok" id="apidoc.element.q-io.content.ok">
        function <span class="apidocSignatureSpan">q-io.content.</span>ok
        <span class="apidocSignatureSpan">(content, contentType, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ok = function (content, contentType, status) {
    status = status || 200;
    content = content || &#x22;&#x22;;
    if (typeof content === &#x22;string&#x22;) {
        content = [content];
    }
    contentType = contentType || &#x22;text/plain&#x22;;
    return {
        &#x22;status&#x22;: status,
        &#x22;headers&#x22;: {
            &#x22;content-type&#x22;: contentType
        },
        &#x22;body&#x22;: content
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
exports.json = function (content, reviver, tabs) {
   try {
       var json = JSON.stringify(content, reviver, tabs);
   } catch (exception) {
       return Q.reject(exception);
   }
   return Content.<span class="apidocCodeKeywordSpan">ok</span>([json], &#x22;application/json&#x22;);
};

/**
* @param {Function(Request, Object):Response} app
* @param {App} badRequest
* @returns {App}
*/
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.cookie" id="apidoc.module.q-io.cookie">module q-io.cookie</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.cookie.CookieJar" id="apidoc.element.q-io.cookie.CookieJar">
        function <span class="apidocSignatureSpan">q-io.cookie.</span>CookieJar
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CookieJar = function (app) {
    var hostCookies = {}; // to {} of pathCookies to [] of cookies
    return function (request) {

        if (!request.headers.host) {
            throw new Error(&#x22;Requests must have a host header&#x22;);
        }
        var hosts = allHostsContaining(request.headers.host);

        var now = new Date();

        // delete expired cookies
        for (var host in hostCookies) {
            var pathCookies = hostCookies[host];
            for (var path in pathCookies) {
                var cookies = pathCookies[path];
                for (var name in cookies) {
                    var cookie = cookies[name];
                    if (cookie.expires &#x26;&#x26; cookie.expires &#x3e; now) {
                        delete cookie[name];
                    }
                }
            }
        }

        // collect applicable cookies
        var requestCookies = concat(
            Object.keys(hostCookies)
            .map(function (host) {
                if (!hostContains(host, request.headers.host)) {
                    return [];
                }
                var pathCookies = hostCookies[host];
                return concat(
                    Object.keys(pathCookies)
                    .map(function (path) {
                        if (!pathContains(path, request.path))
                            return [];
                        var cookies = pathCookies[path];
                        return (
                            Object.keys(cookies)
                            .map(function (name) {
                                return cookies[name];
                            })
                            .filter(function (cookie) {
                                return cookie.secure ?
                                    request.ssl :
                                    true;
                            })
                        );
                    })
                )
            })
        );

        if (requestCookies.length) {
            request.headers[&#x22;cookie&#x22;] = (
                requestCookies
                .map(function (cookie) {
                    return Cookie.stringify(
                        cookie.key,
                        cookie.value
                    );
                })
                .join(&#x22;; &#x22;)
            );
        }

        return Q.when(app.apply(this, arguments), function (response) {
            response.headers = response.headers || {};
            if (response.headers[&#x22;set-cookie&#x22;]) {
                var host = request.headers.host;
                var hostParts = splitHost(host);
                var hostname = hostParts[0];
                var requestHost = ipRe.test(hostname) ? host : &#x22;.&#x22; + host;
                // normalize to array
                if (!Array.isArray(response.headers[&#x22;set-cookie&#x22;])) {
                    response.headers[&#x22;set-cookie&#x22;] = [response.headers[&#x22;set-cookie&#x22;]];
                }
                response.headers[&#x22;set-cookie&#x22;].forEach(function (cookie) {
                    var date = response.headers[&#x22;date&#x22;] ?
                        new Date(response.headers[&#x22;date&#x22;]) :
                        new Date();
                    cookie = Cookie.parse(cookie, date);
                    // ignore illegal host
                    if (cookie.host &#x26;&#x26; !hostContains(requestHost, cookie.host))
                        delete cookie.host;
                    var host = requestHost || cookie.host;
                    var path = cookie.path || &#x22;/&#x22;;
                    var pathCookies = hostCookies[host] = hostCookies[host] || {};
                    var cookies = pathCookies[path] = pathCookies[path] || {};
                    cookies[cookie.key] = cookie;
                })
                delete response.headers[&#x22;set-cookie&#x22;];
            }

            return response;
        });

    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.decorators" id="apidoc.module.q-io.decorators">module q-io.decorators</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.decorators.Date" id="apidoc.element.q-io.decorators.Date">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Date
        <span class="apidocSignatureSpan">(app, present)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Date = function (app, present) {
    present = present || function () {
        return new Date();
    };
    return RouteApps.Trap(app, function (response, request) {
        response.headers[&#x22;date&#x22;] = &#x22;&#x22; + present();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.decorators.Debug" id="apidoc.element.q-io.decorators.Debug">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Debug
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Debug = function (app) {
    return exports.Error(app, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.decorators.Decorators" id="apidoc.element.q-io.decorators.Decorators">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Decorators
        <span class="apidocSignatureSpan">(decorators, app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Decorators = function (decorators, app) {
    decorators.reversed().forEach(function (Middleware) {
        app = Middleware(app);
    });
    return app;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.decorators.Error" id="apidoc.element.q-io.decorators.Error">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Error
        <span class="apidocSignatureSpan">(app, debug)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error = function (app, debug) {
    return function (request, response) {
        return Q.when(app(request, response), null, function (error) {
            if (!debug)
                error = undefined;
            return StatusApps.responseForStatus(request, 500, error &#x26;&#x26; error.stack || error);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
               error = undefined;
           return StatusApps.responseForStatus(request, 500, error &#x26;&#x26; error.stack || error);
       });
   };
};

exports.Debug = function (app) {
   return exports.<span class="apidocCodeKeywordSpan">Error</span>(app, true);
};

/**
* Decorates a Q-JSGI application such that all requests and responses
* are logged.
*
* @param {App} app
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.decorators.Headers" id="apidoc.element.q-io.decorators.Headers">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Headers
        <span class="apidocSignatureSpan">(app, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Headers = function (app, headers) {
    return function (request, response) {
        return Q.when(app(request, response), function (response) {
            if (response &#x26;&#x26; response.headers) {
                Object.keys(headers).forEach(function (key) {
                    if (!(key in response.headers)) {
                        response.headers[key] = headers[key];
                    }
                });
            }
            return response;
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.decorators.Log" id="apidoc.element.q-io.decorators.Log">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Log
        <span class="apidocSignatureSpan">(app, log, stamp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Log = function (app, log, stamp) {
    log = log || console.log;
    stamp = stamp || function (message) {
        return new Date().toISOString() + &#x22; &#x22; + message;
    };
    return function (request, response) {
        var remoteHost =
            request.remoteHost + &#x22;:&#x22; +
            request.remotePort;
        var requestLine =
            request.method + &#x22; &#x22; +
            request.path + &#x22; &#x22; +
            &#x22;HTTP/&#x22; + request.version.join(&#x22;.&#x22;);
        log(stamp(
            remoteHost + &#x22; &#x22; +
            &#x22;--&#x3e;     &#x22; +
            requestLine
        ));
        return Q.when(app(request, response), function (response) {
            if (response) {
                log(stamp(
                    remoteHost + &#x22; &#x22; +
                    &#x22;&#x3c;== &#x22; +
                    response.status + &#x22; &#x22; +
                    requestLine + &#x22; &#x22; +
                    (response.headers[&#x22;content-length&#x22;] || &#x22;-&#x22;)
                ));
            } else {
                log(stamp(
                    remoteHost + &#x22; &#x22; +
                    &#x22;... &#x22; +
                    &#x22;... &#x22; +
                    requestLine + &#x22; (response undefined / presumed streaming)&#x22;
                ));
            }
            return response;
        }, function (reason) {
            log(stamp(
                remoteHost + &#x22; &#x22; +
                &#x22;!!!     &#x22; +
                requestLine + &#x22; &#x22; +
                (reason &#x26;&#x26; reason.message || reason)
            ));
            return Q.reject(reason);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.decorators.Normalize" id="apidoc.element.q-io.decorators.Normalize">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Normalize
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Normalize = function (app) {
    return function (request, response) {
        var request = HTTP.normalizeRequest(request);
        return Q.when(app(request, response), function (response) {
            return HTTP.normalizeResponse(response);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.decorators.Permanent" id="apidoc.element.q-io.decorators.Permanent">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Permanent
        <span class="apidocSignatureSpan">(app, future)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Permanent = function (app, future) {
    future = future || function () {
        return new Date(new Date().getTime() + farFuture);
    };
    app = RouteApps.Tap(app, function (request, response) {
        request.permanent = future;
    });
    app = RouteApps.Trap(app, function (response, request) {
        response.headers[&#x22;expires&#x22;] = &#x22;&#x22; + future();
    });
    return app;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.decorators.Time" id="apidoc.element.q-io.decorators.Time">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Time
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Time = function (app) {
    return function (request, response) {
        var start = new Date();
        return Q.when(app(request, response), function (response) {
            var stop = new Date();
            if (response &#x26;&#x26; response.headers) {
                response.headers[&#x22;x-response-time&#x22;] = &#x22;&#x22; + (stop - start);
            }
            return response;
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.deprecate" id="apidoc.module.q-io.deprecate">module q-io.deprecate</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.deprecate.deprecateMethod" id="apidoc.element.q-io.deprecate.deprecateMethod">
        function <span class="apidocSignatureSpan">q-io.deprecate.</span>deprecateMethod
        <span class="apidocSignatureSpan">(scope, deprecatedFunction, name, alternative)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecate(scope, deprecatedFunction, name, alternative) {
    var deprecationWrapper = function () {
        // stackTraceLimit = 3 // deprecationWarning + deprecate + caller of the deprecated method
        deprecationWarning(name, alternative, 3);
        return deprecatedFunction.apply(scope ? scope : this, arguments);
    };
    deprecationWrapper.deprecatedFunction = deprecatedFunction;
    return deprecationWrapper;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.deprecate.deprecationWarning" id="apidoc.element.q-io.deprecate.deprecationWarning">
        function <span class="apidocSignatureSpan">q-io.deprecate.</span>deprecationWarning
        <span class="apidocSignatureSpan">(name, alternative, stackTraceLimit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecationWarning(name, alternative, stackTraceLimit) {
    if (stackTraceLimit) {
        var depth = Error.stackTraceLimit;
        Error.stackTraceLimit = stackTraceLimit;
    }
    if (typeof console !== &#x22;undefined&#x22; &#x26;&#x26; typeof console.warn === &#x22;function&#x22;) {
        var stack = (stackTraceLimit ? new Error(&#x22;&#x22;).stack : &#x22;&#x22;) ;
        if(alternative) {
            console.warn(name + &#x22; is deprecated, use &#x22; + alternative + &#x22; instead.&#x22;, stack);
        } else {
            //name is a complete message
            console.warn(name, stack);
        }
    }
    if (stackTraceLimit) {
        Error.stackTraceLimit = depth;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.fs" id="apidoc.module.q-io.fs">module q-io.fs</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.fs.Mock" id="apidoc.element.q-io.fs.Mock">
        function <span class="apidocSignatureSpan">q-io.fs.</span>Mock
        <span class="apidocSignatureSpan">(files, workingDirectory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MockFs(files, workingDirectory) {
    if (!(this instanceof MockFs)) {
        return new MockFs(files, workingDirectory);
    }
    this._root = new DirectoryNode(this, &#x22;/&#x22;);

    function init() {
        // construct a file tree
    }

    Common.update(this, function () {
        return workingDirectory;
    });

    workingDirectory = workingDirectory || this.ROOT;
    if (files) {
        this._init(files);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.Root" id="apidoc.element.q-io.fs.Root">
        function <span class="apidocSignatureSpan">q-io.fs.</span>Root
        <span class="apidocSignatureSpan">(outer, root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RootFs(outer, root) {
    var inner = Object.create(BOOT);

    function attenuate(path) {

        // the machinations of projecting a path inside a
        // subroot
        var actual;
        // if it&#x27;s absolute, we want the path relative to
        // the root of the inner file system
        if (outer.isAbsolute(path)) {
            actual = outer.relativeFromDirectory(outer.ROOT, path);
        } else {
            actual = path;
        }
        // we join the path onto the root of the inner file
        // system so that parent references from the root
        // return to the root, emulating standard unix
        // behavior
        actual = outer.join(outer.ROOT, actual);
        // then we reconstruct the path relative to the
        // inner root
        actual = outer.relativeFromDirectory(outer.ROOT, actual);
        // and rejoin it on the outer root
        actual = outer.join(root, actual);
        // and find the corresponding real path
        return outer.canonical(actual)
        .then(function (actual) {
            return actual;
        }, function () {
            return actual;
        }).then(function (actual) {
            // and verify that the outer canonical path is
            // actually inside the inner canonical path, to
            // prevent break-outs
            if (outer.contains(root, actual)) {
                return {
                    &#x22;inner&#x22;: outer.join(outer.ROOT, outer.relativeFromDirectory(root, actual)),
                    &#x22;outer&#x22;: actual
                };
            } else {
                return Q.reject(&#x22;Can&#x27;t find: &#x22; + JSON.stringify(path));
            }
        });
    }

    function workingDirectory() {
        return outer.ROOT;
    }

    COMMON.update(inner, workingDirectory);

    inner.list = function (path) {
        return attenuate(path).then(function (path) {
            return outer.list(path.outer);
        }).then(null, function (reason) {
            return Q.reject(&#x22;Can&#x27;t list &#x22; + JSON.stringify(path));
        });
    };

    inner.open = function (path, flags, charset) {
        return attenuate(path).then(function (path) {
            return outer.open(path.outer, flags, charset);
        }).then(null, function (reason) {
            return Q.reject(&#x22;Can&#x27;t open &#x22; + JSON.stringify(path));
        });
    };

    inner.stat = function (path) {
        return attenuate(path).then(function (path) {
            return outer.stat(path.outer);
        }).then(null, function (reason) {
            return Q.reject(&#x22;Can&#x27;t stat &#x22; + JSON.stringify(path));
        });
    };

    inner.statLink = function (path) {
        return attenuate(path).then(function (path) {
            return outer.statLink(path.outer);
        }).then(null, function (reason) {
            return Q.reject(&#x22;Can&#x27;t statLink &#x22; + JSON.stringify(path));
        });
    };

    inner.canonical = function (path) {
        return attenuate(path).then(function (path) {
            return path.inner;
        }).then(null, function (reason) {
            return Q.reject(&#x22;Can&#x27;t find canonical of &#x22; + JSON.stringify(path));
        });
    };

    inner.makeDirectory = function (path) {
        return attenuate(path).then(function (path) {
            return outer.makeDirectory(path.outer);
        }).catch(function (error) {
            throw new Error(&#x22;Can&#x27;t make directory &#x22; + JSON.stringify(path));
        });
    };

    inner.removeDirectory = function (path) {
        return attenuate(path).then(function (path) {
            return outer.removeDirectory(path.outer);
        }).catch(function (error) {
            throw new Error(&#x22;Can&#x27;t remove directory &#x22; + JSON.stringify(path));
        });
    };

    inner.remove = function (path) {
        return attenuate(path).then(function (path) {
            return outer.remove(path.outer);
        }).catch(function (error) {
            throw new Error(&#x22;Can&#x27;t remove &#x22; + JSON.stringify(path));
        });
    };

    inner.makeTree = function (path) {
        return attenuate(path).then(function (path) {
            return outer.makeT ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.SEPARATORS_RE" id="apidoc.element.q-io.fs.SEPARATORS_RE">
        function <span class="apidocSignatureSpan">q-io.fs.</span>SEPARATORS_RE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SEPARATORS_RE = function () {
    if (
        separatorCached !== exports.SEPARATOR ||
        altSeparatorCached !== exports.ALT_SEPARATOR
    ) {
        separatorCached = exports.SEPARATOR;
        altSeparatorCached = exports.ALT_SEPARATOR;
        separatorReCached = new RegExp(&#x22;[&#x22; +
            (separatorCached || &#x22;&#x22;).replace(/[-[\]{}()*+?.\\^$|,#\s]/g, &#x22;\\$&#x26;&#x22;) +
            (altSeparatorCached || &#x22;&#x22;).replace(/[-[\]{}()*+?.\\^$|,#\s]/g, &#x22;\\$&#x26;&#x22;) +
        &#x22;]&#x22;, &#x22;g&#x22;);
    }
    return separatorReCached;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * file system, indicated by an empty string on Unix, and a
 * drive letter followed by a colon on Windows.
 * @returns {Array * String}
 */
exports.split = function (path) {
var parts;
try {
    parts = String(path).split(exports.<span class="apidocCodeKeywordSpan">SEPARATORS_RE</span>());
} catch (exception) {
    throw new Error(&#x22;Cannot split &#x22; + (typeof path) + &#x22;, &#x22; + JSON.stringify(path));
}
// this special case helps isAbsolute
// distinguish an empty path from an absolute path
// &#x22;&#x22; -&#x3e; [] NOT [&#x22;&#x22;]
if (parts.length === 1 &#x26;&#x26; parts[0] === &#x22;&#x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.Stats" id="apidoc.element.q-io.fs.Stats">
        function <span class="apidocSignatureSpan">q-io.fs.</span>Stats
        <span class="apidocSignatureSpan">(nodeStat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stats(nodeStat) {
    this.node = nodeStat;
    this.size = nodeStat.size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var done = Q.defer();
    try {
        FS.stat(path, function (error, stat) {
            if (error) {
                error.message = &#x22;Can&#x27;t stat &#x22; + JSON.stringify(path) + &#x22;: &#x22; + error;
                done.reject(error);
            } else {
                done.resolve(new self.<span class="apidocCodeKeywordSpan">Stats</span>(stat));
            }
        });
    } catch (error) {
        done.reject(error);
    }
    return done.promise;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.absolute" id="apidoc.element.q-io.fs.absolute">
        function <span class="apidocSignatureSpan">q-io.fs.</span>absolute
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">absolute = function (path) {
    if (this.isAbsolute(path))
        return this.normal(path);
    return this.join(workingDirectory(), path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* @returns {String} the Unix root path or corresponding
* Windows drive for a given path.
*/
exports.root = function (path) {
   if (!exports.isAbsolute(path))
       path = require(&#x22;./fs&#x22;).<span class="apidocCodeKeywordSpan">absolute</span>(path);
   var parts = exports.split(path);
   return exports.join(parts[0], &#x22;&#x22;);
};

/**
* @returns {String} the parent directory of the given path.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.append" id="apidoc.element.q-io.fs.append">
        function <span class="apidocSignatureSpan">q-io.fs.</span>append
        <span class="apidocSignatureSpan">(path, content, flags, charset, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (path, content, flags, charset, options) {
    var self = this;
    if (typeof flags === &#x22;object&#x22;) {
        options = flags;
    } else if (typeof charset === &#x22;object&#x22;) {
        options = charset;
        options.flags = flags;
    } else {
        options = options || {};
        options.flags = flags;
        options.charset = charset;
    }
    flags = options.flags || &#x22;a&#x22;;
    if (content instanceof Buffer) {
        flags += &#x22;b&#x22;;
    }
    options.flags = flags;
    return Q.when(self.open(path, options), function (stream) {
        return Q.when(stream.write(content), function () {
            return stream.close();
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.base" id="apidoc.element.q-io.fs.base">
        function <span class="apidocSignatureSpan">q-io.fs.</span>base
        <span class="apidocSignatureSpan">(path, extension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base = function (path, extension) {
    var base = path.split(exports.SEPARATORS_RE()).pop();
    if (extension)
        base = base.replace(
            new RegExp(regExpEscape(extension) + &#x22;$&#x22;),
            &#x22;&#x22;
        );
    return base;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * @returns {String} the extension (e.g., `txt`) of the file
 * at the given path.
 */
exports.extension = function (path) {
    path = exports.<span class="apidocCodeKeywordSpan">base</span>(path);
    path = path.replace(/^\.*/, &#x22;&#x22;);
    var index = path.lastIndexOf(&#x22;.&#x22;);
    return index &#x3c;= 0 ? &#x22;&#x22; : path.substring(index);
};

})(typeof exports !== &#x22;undefined&#x22; ? exports : FS_BOOT = {});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.canonical" id="apidoc.element.q-io.fs.canonical">
        function <span class="apidocSignatureSpan">q-io.fs.</span>canonical
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canonical = function (path) {
    var result = Q.defer();
    FS.realpath(path, function (error, canonicalPath) {
        if (error) {
            error.message = &#x22;Can&#x27;t get canonical path of &#x22; + JSON.stringify(path) + &#x22; by way of C realpath: &#x22; + error.message;
            result.reject(error);
        } else {
            result.resolve(canonicalPath);
        }
    });
    return result.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
actual = outer.join(outer.ROOT, actual);
// then we reconstruct the path relative to the
// inner root
actual = outer.relativeFromDirectory(outer.ROOT, actual);
// and rejoin it on the outer root
actual = outer.join(root, actual);
// and find the corresponding real path
return outer.<span class="apidocCodeKeywordSpan">canonical</span>(actual)
.then(function (actual) {
    return actual;
}, function () {
    return actual;
}).then(function (actual) {
    // and verify that the outer canonical path is
    // actually inside the inner canonical path, to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.chmod" id="apidoc.element.q-io.fs.chmod">
        function <span class="apidocSignatureSpan">q-io.fs.</span>chmod
        <span class="apidocSignatureSpan">(path, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chmod = function (path, mode) {
    path = String(path);
    mode = String(mode);
    var done = Q.defer();
    try {
        FS.chmod(path, mode, function (error) {
            if (error) {
                error.message = &#x22;Can&#x27;t chmod (change permissions mode) of &#x22; + JSON.stringify(path) + &#x22; to (octal number) &#x22; + mode
.toString(8) + &#x22;: &#x22; + error.message;
                done.reject(error);
            } else {
                done.resolve();
            }
        });
    } catch (error) {
        done.reject(error);
    }
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

exports.chmod = function (path, mode) {
path = String(path);
mode = String(mode);
var done = Q.defer();
try {
    FS.<span class="apidocCodeKeywordSpan">chmod</span>(path, mode, function (error) {
        if (error) {
            error.message = &#x22;Can&#x27;t chmod (change permissions mode) of &#x22; + JSON.stringify(path) + &#x22; to (octal
 number) &#x22; + mode.toString(8) + &#x22;: &#x22; + error.message;
            done.reject(error);
        } else {
            done.resolve();
        }
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.chown" id="apidoc.element.q-io.fs.chown">
        function <span class="apidocSignatureSpan">q-io.fs.</span>chown
        <span class="apidocSignatureSpan">(path, uid, gid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chown = function (path, uid, gid) {
    path = String(path);
    var done = Q.defer();
    try {
        FS.chown(path, uid, gid, function (error) {
            if (error) {
                error.message = &#x22;Can&#x27;t chown (change owner) of &#x22; + JSON.stringify(path) + &#x22; to user &#x22; + JSON.stringify(uid) + &#x22;
and group &#x22; + JSON.stringify(gid) + &#x22;: &#x22; + error.message;
                done.reject(error);
            } else {
                done.resolve();
            }
        });
    } catch (error) {
        done.reject(error);
    }
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return done.promise;
};

exports.chown = function (path, uid, gid) {
path = String(path);
var done = Q.defer();
try {
    FS.<span class="apidocCodeKeywordSpan">chown</span>(path, uid, gid, function (error) {
        if (error) {
            error.message = &#x22;Can&#x27;t chown (change owner) of &#x22; + JSON.stringify(path) + &#x22; to user &#x22; + JSON
.stringify(uid) + &#x22; and group &#x22; + JSON.stringify(gid) + &#x22;: &#x22; + error.message;
            done.reject(error);
        } else {
            done.resolve();
        }
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.contains" id="apidoc.element.q-io.fs.contains">
        function <span class="apidocSignatureSpan">q-io.fs.</span>contains
        <span class="apidocSignatureSpan">(parent, child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (parent, child) {
    var i, ii;
    parent = this.absolute(parent);
    child = this.absolute(child);
    parent = parent.split(this.SEPARATORS_RE());
    child = child.split(this.SEPARATORS_RE());
    if (parent.length === 2 &#x26;&#x26; parent[1] === &#x22;&#x22;)
        parent.pop();
    if (parent.length &#x3e; child.length)
        return false;
    for (i = 0, ii = parent.length; i &#x3c; ii; i++) {
        if (parent[i] !== child[i])
            break;
    }
    return i == ii;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return actual;
}, function () {
    return actual;
}).then(function (actual) {
    // and verify that the outer canonical path is
    // actually inside the inner canonical path, to
    // prevent break-outs
    if (outer.<span class="apidocCodeKeywordSpan">contains</span>(root, actual)) {
        return {
            &#x22;inner&#x22;: outer.join(outer.ROOT, outer.relativeFromDirectory(root, actual)),
            &#x22;outer&#x22;: actual
        };
    } else {
        return Q.reject(&#x22;Can&#x27;t find: &#x22; + JSON.stringify(path));
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.copy" id="apidoc.element.q-io.fs.copy">
        function <span class="apidocSignatureSpan">q-io.fs.</span>copy
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy = function (source, target) {
    var self = this;
    return Q.when(self.stat(source), function (stat) {
        var mode = stat.node.mode;
        return Q.all([
            self.open(source, {flags: &#x22;rb&#x22;}),
            self.open(target, {flags: &#x22;wb&#x22;, mode: mode})
        ]);
    })
    .spread(function (reader, writer) {
        return Q.when(reader.forEach(function (block) {
            return writer.write(block);
        }), function () {
            return Q.all([
                reader.close(),
                writer.close()
            ]);
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
};

exports.copyTree = function (source, target) {
    var self = this;
    return Q.when(self.stat(source), function (stat) {
        if (stat.isFile()) {
            return self.<span class="apidocCodeKeywordSpan">copy</span>(source, target);
        } else if (stat.isDirectory()) {
            return self.exists(target).then(function (targetExists) {
                function copySubTree() {
                    return Q.when(self.list(source), function (list) {
                        return Q.all(list.map(function (child) {
                            return self.copyTree(
                                self.join(source, child),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.copyTree" id="apidoc.element.q-io.fs.copyTree">
        function <span class="apidocSignatureSpan">q-io.fs.</span>copyTree
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copyTree = function (source, target) {
    var self = this;
    return Q.when(self.stat(source), function (stat) {
        if (stat.isFile()) {
            return self.copy(source, target);
        } else if (stat.isDirectory()) {
            return self.exists(target).then(function (targetExists) {
                function copySubTree() {
                    return Q.when(self.list(source), function (list) {
                        return Q.all(list.map(function (child) {
                            return self.copyTree(
                                self.join(source, child),
                                self.join(target, child)
                            );
                        }));
                    });
                }
                if (targetExists) {
                    return copySubTree();
                } else {
                    return Q.when(self.makeDirectory(target, stat.node.mode), copySubTree);
                }
            });
        } else if (stat.isSymbolicLink()) {
            // TODO copy the link and type with readPath (but what about
            // Windows junction type?)
            return self.symbolicCopy(source, target);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

exports.move = function (source, target) {
    var self = this;
    return this.rename(source, target)
    .catch(function (error) {
        if (error.crossDevice) {
            return self.<span class="apidocCodeKeywordSpan">copyTree</span>(source, target)
            .then(function () {
                return self.removeTree(source);
            });
        } else {
            throw error;
        }
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.directory" id="apidoc.element.q-io.fs.directory">
        function <span class="apidocSignatureSpan">q-io.fs.</span>directory
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directory = function (path) {
    path = exports.normal(path);
    var absolute = exports.isAbsolute(path);
    var parts = exports.split(path);
    // XXX needs to be sensitive to the root for
    // Windows compatibility
    if (parts.length) {
        if (parts[parts.length - 1] == &#x22;..&#x22;) {
            parts.push(&#x22;..&#x22;);
        } else {
            parts.pop();
        }
    } else {
        parts.unshift(&#x22;..&#x22;);
    }
    return parts.join(exports.SEPARATOR) || (
        exports.isRelative(path) ?
        &#x22;&#x22; : exports.ROOT
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.exists" id="apidoc.element.q-io.fs.exists">
        function <span class="apidocSignatureSpan">q-io.fs.</span>exists
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exists = function (path) {
    return Q.when(this.stat(path), function () {
        return true;
    }, function () {
        return false;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    exports.copyTree = function (source, target) {
var self = this;
return Q.when(self.stat(source), function (stat) {
    if (stat.isFile()) {
        return self.copy(source, target);
    } else if (stat.isDirectory()) {
        return self.<span class="apidocCodeKeywordSpan">exists</span>(target).then(function (targetExists) {
            function copySubTree() {
                return Q.when(self.list(source), function (list) {
                    return Q.all(list.map(function (child) {
                        return self.copyTree(
                            self.join(source, child),
                            self.join(target, child)
                        );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.extension" id="apidoc.element.q-io.fs.extension">
        function <span class="apidocSignatureSpan">q-io.fs.</span>extension
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extension = function (path) {
    path = exports.base(path);
    path = path.replace(/^\.*/, &#x22;&#x22;);
    var index = path.lastIndexOf(&#x22;.&#x22;);
    return index &#x3c;= 0 ? &#x22;&#x22; : path.substring(index);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.isAbsolute" id="apidoc.element.q-io.fs.isAbsolute">
        function <span class="apidocSignatureSpan">q-io.fs.</span>isAbsolute
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAbsolute = function (path) {
    // for absolute paths on any operating system,
    // the first path component always determines
    // whether it is relative or absolute.  On Unix,
    // it is empty, so [&#x22;&#x22;, &#x22;foo&#x22;].join(&#x22;/&#x22;) == &#x22;/foo&#x22;,
    // &#x22;/foo&#x22;.split(&#x22;/&#x22;) == [&#x22;&#x22;, &#x22;foo&#x22;].
    var parts = exports.split(path);
    // split(&#x22;&#x22;) == [].  &#x22;&#x22; is not absolute.
    // split(&#x22;/&#x22;) == [&#x22;&#x22;, &#x22;&#x22;] is absolute.
    // split(?) == [&#x22;&#x22;] does not occur.
    if (parts.length == 0)
        return false;
    return exports.isRoot(parts[0]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var children = [];
var leaf = &#x22;&#x22;;
for (var i = 0; i &#x3c; arguments.length; i++) {
    var path = String(arguments[i]);
    if (path == &#x22;&#x22;)
        continue;
    var parts = path.split(exports.SEPARATORS_RE());
    if (exports.<span class="apidocCodeKeywordSpan">isAbsolute</span>(path)) {
        root = parts.shift() + exports.SEPARATOR;
        parents = [];
        children = [];
    }
    leaf = parts.pop();
    if (leaf == &#x22;.&#x22; || leaf == &#x22;..&#x22;) {
        parts.push(leaf);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.isDirectory" id="apidoc.element.q-io.fs.isDirectory">
        function <span class="apidocSignatureSpan">q-io.fs.</span>isDirectory
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDirectory = function (path) {
    return Q.when(this.stat(path), function (stat) {
        return stat.isDirectory();
    }, function (reason) {
        return false;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

exports.copyTree = function (source, target) {
    var self = this;
    return Q.when(self.stat(source), function (stat) {
        if (stat.isFile()) {
            return self.copy(source, target);
        } else if (stat.<span class="apidocCodeKeywordSpan">isDirectory</span>()) {
            return self.exists(target).then(function (targetExists) {
                function copySubTree() {
                    return Q.when(self.list(source), function (list) {
                        return Q.all(list.map(function (child) {
                            return self.copyTree(
                                self.join(source, child),
                                self.join(target, child)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.isFile" id="apidoc.element.q-io.fs.isFile">
        function <span class="apidocSignatureSpan">q-io.fs.</span>isFile
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFile = function (path) {
    return Q.when(this.stat(path), function (stat) {
        return stat.isFile();
    }, function (reason) {
        return false;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        });
    });
};

exports.copyTree = function (source, target) {
    var self = this;
    return Q.when(self.stat(source), function (stat) {
        if (stat.<span class="apidocCodeKeywordSpan">isFile</span>()) {
            return self.copy(source, target);
        } else if (stat.isDirectory()) {
            return self.exists(target).then(function (targetExists) {
                function copySubTree() {
                    return Q.when(self.list(source), function (list) {
                        return Q.all(list.map(function (child) {
                            return self.copyTree(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.isRelative" id="apidoc.element.q-io.fs.isRelative">
        function <span class="apidocSignatureSpan">q-io.fs.</span>isRelative
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRelative = function (path) {
    return !exports.isAbsolute(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       } else {
           parts.pop();
       }
   } else {
       parts.unshift(&#x22;..&#x22;);
   }
   return parts.join(exports.SEPARATOR) || (
       exports.<span class="apidocCodeKeywordSpan">isRelative</span>(path) ?
       &#x22;&#x22; : exports.ROOT
   );
};

/**
* @returns {String} the last component of a path, without
* the given extension if the extension is provided and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.isRoot" id="apidoc.element.q-io.fs.isRoot">
        function <span class="apidocSignatureSpan">q-io.fs.</span>isRoot
        <span class="apidocSignatureSpan">(first)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRoot = function (first) {
    if (exports.SEPARATOR === &#x22;\\&#x22;) {
        return /[a-zA-Z]:$/.test(first);
    } else {
        return first == &#x22;&#x22;;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // &#x22;/foo&#x22;.split(&#x22;/&#x22;) == [&#x22;&#x22;, &#x22;foo&#x22;].
    var parts = exports.split(path);
    // split(&#x22;&#x22;) == [].  &#x22;&#x22; is not absolute.
    // split(&#x22;/&#x22;) == [&#x22;&#x22;, &#x22;&#x22;] is absolute.
    // split(?) == [&#x22;&#x22;] does not occur.
    if (parts.length == 0)
        return false;
    return exports.<span class="apidocCodeKeywordSpan">isRoot</span>(parts[0]);
};

/**
 * @returns {Boolean} whether the given path does not begin
 * at the root of the file system or a drive letter.
 */
exports.isRelative = function (path) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.isSymbolicLink" id="apidoc.element.q-io.fs.isSymbolicLink">
        function <span class="apidocSignatureSpan">q-io.fs.</span>isSymbolicLink
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSymbolicLink = function (path) {
    return Q.when(this.statLink(path), function (stat) {
        return stat.isSymbolicLink();
    }, function (reason) {
        return false;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                }
                if (targetExists) {
                    return copySubTree();
                } else {
                    return Q.when(self.makeDirectory(target, stat.node.mode), copySubTree);
                }
            });
        } else if (stat.<span class="apidocCodeKeywordSpan">isSymbolicLink</span>()) {
            // TODO copy the link and type with readPath (but what about
            // Windows junction type?)
            return self.symbolicCopy(source, target);
        }
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.join" id="apidoc.element.q-io.fs.join">
        function <span class="apidocSignatureSpan">q-io.fs.</span>join
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">join = function () {
    if (arguments.length === 1 &#x26;&#x26; Array.isArray(arguments[0]))
        return exports.normal.apply(exports, arguments[0]);
    return exports.normal.apply(exports, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return Q.fcall(function () {
        chunks.splice(0, chunks.length).forEach(write, thisp);
    });
};

BufferStream.prototype.read = function () {
    var result;
    result = Reader.<span class="apidocCodeKeywordSpan">join</span>(this._chunks);
    if (this._charset) {
        result = result.toString(this._charset);
    }
    return Q.resolve(result);
};

BufferStream.prototype.write = function (chunk) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.lastAccessed" id="apidoc.element.q-io.fs.lastAccessed">
        function <span class="apidocSignatureSpan">q-io.fs.</span>lastAccessed
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastAccessed = function (path) {
    var self = this;
    return self.stat(path).invoke(&#x27;lastAccessed&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.lastModified" id="apidoc.element.q-io.fs.lastModified">
        function <span class="apidocSignatureSpan">q-io.fs.</span>lastModified
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastModified = function (path) {
    var self = this;
    return self.stat(path).invoke(&#x27;lastModified&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.link" id="apidoc.element.q-io.fs.link">
        function <span class="apidocSignatureSpan">q-io.fs.</span>link
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">link = function (source, target) {
    source = String(source);
    target = String(target);
    var done = Q.defer();
    try {
        FS.link(source, target, function (error) {
            if (error) {
                error.message = &#x22;Can&#x27;t link &#x22; + JSON.stringify(source) + &#x22; to &#x22; + JSON.stringify(target) + &#x22;: &#x22; + error.message;
                done.reject(error);
            } else {
                done.resolve();
            }
        });
    } catch (error) {
        done.reject(error);
    }
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

exports.link = function (source, target) {
source = String(source);
target = String(target);
var done = Q.defer();
try {
    FS.<span class="apidocCodeKeywordSpan">link</span>(source, target, function (error) {
        if (error) {
            error.message = &#x22;Can&#x27;t link &#x22; + JSON.stringify(source) + &#x22; to &#x22; + JSON.stringify(target) + &#
x22;: &#x22; + error.message;
            done.reject(error);
        } else {
            done.resolve();
        }
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.list" id="apidoc.element.q-io.fs.list">
        function <span class="apidocSignatureSpan">q-io.fs.</span>list
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">list = function () {
    var args = arguments;
    var ready = backOffDelay ? Q.delay(backOffDelay) : Q.resolve();
    return ready.then(function () {
        return Q.when(wrapped.apply(thisp, args), function (stream) {
            backOffDelay = Math.max(0, backOffDelay - 1);
            return stream;
        }, function (error) {
            if (error.code === &#x22;EMFILE&#x22;) {
                backOffDelay = (backOffDelay + 1) * backOffFactor;
                return retry.apply(null, args);
            } else {
                throw error;
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var self = this;
return Q.when(self.stat(source), function (stat) {
    if (stat.isFile()) {
        return self.copy(source, target);
    } else if (stat.isDirectory()) {
        return self.exists(target).then(function (targetExists) {
            function copySubTree() {
                return Q.when(self.<span class="apidocCodeKeywordSpan">list</span>(source), function (list) {
                    return Q.all(list.map(function (child) {
                        return self.copyTree(
                            self.join(source, child),
                            self.join(target, child)
                        );
                    }));
                });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.listDirectoryTree" id="apidoc.element.q-io.fs.listDirectoryTree">
        function <span class="apidocSignatureSpan">q-io.fs.</span>listDirectoryTree
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listDirectoryTree = function (path) {
    return this.listTree(path, function (path, stat) {
        return stat.isDirectory();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.listTree" id="apidoc.element.q-io.fs.listTree">
        function <span class="apidocSignatureSpan">q-io.fs.</span>listTree
        <span class="apidocSignatureSpan">(basePath, guard)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listTree = function (basePath, guard) {
    var self = this;
    basePath = String(basePath || &#x27;&#x27;);
    if (!basePath)
        basePath = &#x22;.&#x22;;
    guard = guard || function () {
        return true;
    };
    var stat = self.stat(basePath);
    return Q.when(stat, function (stat) {
        var paths = [];
        var mode; // true:include, false:exclude, null:no-recur
        try {
            var include = guard(basePath, stat);
        } catch (exception) {
            return Q.reject(exception);
        }
        return Q.when(include, function (include) {
            if (include) {
                paths.push([basePath]);
            }
            if (include !== null &#x26;&#x26; stat.isDirectory()) {
                return Q.when(self.list(basePath), function (children) {
                    paths.push.apply(paths, children.map(function (child) {
                        var path = self.join(basePath, child);
                        return self.listTree(path, guard);
                    }));
                    return paths;
                });
            } else {
                return paths;
            }
        });
    }, function noSuchFile(reason) {
        return [];
    }).then(Q.all).then(concat);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (include) {
        paths.push([basePath]);
    }
    if (include !== null &#x26;&#x26; stat.isDirectory()) {
        return Q.when(self.list(basePath), function (children) {
            paths.push.apply(paths, children.map(function (child) {
                var path = self.join(basePath, child);
                return self.<span class="apidocCodeKeywordSpan">listTree</span>(path, guard);
            }));
            return paths;
        });
    } else {
        return paths;
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.makeDirectory" id="apidoc.element.q-io.fs.makeDirectory">
        function <span class="apidocSignatureSpan">q-io.fs.</span>makeDirectory
        <span class="apidocSignatureSpan">(path, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeDirectory = function (path, mode) {
    path = String(path);
    var done = Q.defer();
    if (typeof mode === &#x22;string&#x22;) {
        mode = parseInt(mode, 8);
    } else if (mode === void 0) {
        mode = parseInt(&#x27;755&#x27;, 8);
    }
    FS.mkdir(path, mode, function (error) {
        if (error) {
            if (error.code === &#x22;EISDIR&#x22;) {
                error.exists = true;
                error.isDirectory = true;
                error.message = &#x22;directory already exists: &#x22; + error.message;
            }
            if (error.code === &#x22;EEXIST&#x22;) {
                error.exists = true;
                error.message = &#x22;file exists at that path: &#x22; + error.message;
            }
            error.message = &#x22;Can&#x27;t makeDirectory &#x22; + JSON.stringify(path) + &#x22; with mode &#x22; + mode + &#x22;: &#x22; + error.message;
            done.reject(error);
        } else {
            done.resolve();
        }
    });
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                    );
                }));
            });
        }
        if (targetExists) {
            return copySubTree();
        } else {
            return Q.when(self.<span class="apidocCodeKeywordSpan">makeDirectory</span>(target, stat.node.mode), copySubTree);
        }
    });
} else if (stat.isSymbolicLink()) {
    // TODO copy the link and type with readPath (but what about
    // Windows junction type?)
    return self.symbolicCopy(source, target);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.makeTree" id="apidoc.element.q-io.fs.makeTree">
        function <span class="apidocSignatureSpan">q-io.fs.</span>makeTree
        <span class="apidocSignatureSpan">(path, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeTree = function (path, mode) {
    path = String(path);
    var self = this;
    var parts = self.split(path);
    var at = [];
    if (self.isAbsolute(path)) {
        // On Windows use the root drive (e.g. &#x22;C:&#x22;), on *nix the first
        // part is the falsey &#x22;&#x22;, and so use the ROOT (&#x22;/&#x22;)
        at.push(parts.shift() || self.ROOT);
    }
    return parts.reduce(function (parent, part) {
        return Q.when(parent, function () {
            at.push(part);
            var parts = self.join(at) || &#x22;.&#x22;;
            var made = self.makeDirectory(parts, mode);
            return Q.when(made, null, function rejected(error) {
                // throw away errors for already made directories
                if (error.exists) {
                    return;
                } else {
                    throw error;
                }
            });
        });
    }, undefined);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }).catch(function (error) {
        throw new Error(&#x22;Can&#x27;t remove &#x22; + JSON.stringify(path));
    });
};

inner.makeTree = function (path) {
    return attenuate(path).then(function (path) {
        return outer.<span class="apidocCodeKeywordSpan">makeTree</span>(path.outer);
    }).catch(function (error) {
        throw new Error(&#x22;Can&#x27;t make tree &#x22; + JSON.stringify(path));
    });
};

inner.removeTree = function (path) {
    return attenuate(path).then(function (path) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.merge" id="apidoc.element.q-io.fs.merge">
        function <span class="apidocSignatureSpan">q-io.fs.</span>merge
        <span class="apidocSignatureSpan">(fss)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (fss) {
    var tree = {};
    var done;
    fss.forEach(function (fs) {
        done = Q.when(done, function () {
            return fs.listTree(&#x22;&#x22;, function (path, stat) {
                return stat.isFile();
            })
            .then(function (list) {
                return Q.all(list.map(function (path) {
                    return Q.when(fs.read(path, &#x22;rb&#x22;), function (content) {
                        tree[path] = content;
                    });
                }));
            });
        });
    })
    return Q.when(done, function () {
        return MockFs(tree);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.mock" id="apidoc.element.q-io.fs.mock">
        function <span class="apidocSignatureSpan">q-io.fs.</span>mock
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mock = function (path) {
    return Mock.mock(this, path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

You can also instantiate a mock file system with the content of a
subtree of a real file system.  You receive a promise for the mock
filesystem.

```javascript
var FS = require(&#x22;q-io/fs&#x22;);
FS.<span class="apidocCodeKeywordSpan">mock</span>(__dirname)
.then(function (fs) {
    //
})
.done();
```

## HTTP
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.move" id="apidoc.element.q-io.fs.move">
        function <span class="apidocSignatureSpan">q-io.fs.</span>move
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">move = function (source, target) {
    var self = this;
    return this.rename(source, target)
    .catch(function (error) {
        if (error.crossDevice) {
            return self.copyTree(source, target)
            .then(function () {
                return self.removeTree(source);
            });
        } else {
            throw error;
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.normal" id="apidoc.element.q-io.fs.normal">
        function <span class="apidocSignatureSpan">q-io.fs.</span>normal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normal = function () {
    var root = &#x22;&#x22;;
    var parents = [];
    var children = [];
    for (var i = 0, ii = arguments.length; i &#x3c; ii; i++) {
        var path = String(arguments[i]);
        // empty paths have no affect
        if (path === &#x22;&#x22;)
            continue;
        var parts = path.split(exports.SEPARATORS_RE());
        if (exports.isAbsolute(path)) {
            root = parts.shift() + exports.SEPARATOR;
            parents = [];
            children = [];
        }
        for (var j = 0, jj = parts.length; j &#x3c; jj; j++) {
            var part = parts[j];
            if (part === &#x22;.&#x22; || part === &#x22;&#x22;) {
            } else if (part == &#x22;..&#x22;) {
                if (children.length) {
                    children.pop();
                } else {
                    if (root) {
                    } else {
                        parents.push(&#x22;..&#x22;);
                    }
                }
            } else {
                children.push(part);
            }
        }
    }
    path = parents.concat(children).join(exports.SEPARATOR);
    return root + path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return exports.join(parts[0], &#x22;&#x22;);
};

/**
 * @returns {String} the parent directory of the given path.
 */
exports.directory = function (path) {
path = exports.<span class="apidocCodeKeywordSpan">normal</span>(path);
var absolute = exports.isAbsolute(path);
var parts = exports.split(path);
// XXX needs to be sensitive to the root for
// Windows compatibility
if (parts.length) {
    if (parts[parts.length - 1] == &#x22;..&#x22;) {
        parts.push(&#x22;..&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.open" id="apidoc.element.q-io.fs.open">
        function <span class="apidocSignatureSpan">q-io.fs.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
    var args = arguments;
    var ready = backOffDelay ? Q.delay(backOffDelay) : Q.resolve();
    return ready.then(function () {
        return Q.when(wrapped.apply(thisp, args), function (stream) {
            backOffDelay = Math.max(0, backOffDelay - 1);
            return stream;
        }, function (error) {
            if (error.code === &#x22;EMFILE&#x22;) {
                backOffDelay = (backOffDelay + 1) * backOffFactor;
                return retry.apply(null, args);
            } else {
                throw error;
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    options.flags = flags;
} else {
    options = options || {};
    options.flags = flags;
    options.charset = charset;
}
options.flags = options.flags || &#x22;r&#x22;;
return Q.when(this.<span class="apidocCodeKeywordSpan">open</span>(path, options), function (stream) {
    return stream.read();
}, function (error) {
    error.message = &#x22;Can&#x27;t read &#x22; + path + &#x22; because &#x22; + error.message;
    error.path = path;
    error.flags = flags;
    error.charset = charset;
    throw error;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.read" id="apidoc.element.q-io.fs.read">
        function <span class="apidocSignatureSpan">q-io.fs.</span>read
        <span class="apidocSignatureSpan">(path, flags, charset, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (path, flags, charset, options) {
    if (typeof flags === &#x22;object&#x22;) {
        options = flags;
    } else if (typeof charset === &#x22;object&#x22;) {
        options = charset;
        options.flags = flags;
    } else {
        options = options || {};
        options.flags = flags;
        options.charset = charset;
    }
    options.flags = options.flags || &#x22;r&#x22;;
    return Q.when(this.open(path, options), function (stream) {
        return stream.read();
    }, function (error) {
        error.message = &#x22;Can&#x27;t read &#x22; + path + &#x22; because &#x22; + error.message;
        error.path = path;
        error.flags = flags;
        error.charset = charset;
        throw error;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
into memory.  It returns a promise for the whole file contents.  By
default, `read` provides a string decoded from UTF-8.  With the bytewise
mode flag, provides a `Buffer`.

The options argument is identical to that of `open`.

```javascript
return FS.<span class="apidocCodeKeywordSpan">read</span>(__filename, &#x22;b&#x22;)
.then(function (content) {
    // ...
})
```

```javascript
return FS.read(__filename, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.readLink" id="apidoc.element.q-io.fs.readLink">
        function <span class="apidocSignatureSpan">q-io.fs.</span>readLink
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readLink = function (path) {
    var result = Q.defer();
    FS.readlink(path, function (error, path) {
        if (error) {
            error.message = &#x22;Can&#x27;t get link from &#x22; + JSON.stringify(path) + &#x22; by way of C readlink: &#x22; + error.message;
            result.reject(error);
        } else {
            result.resolve(path);
        }
    });
    return result.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.relative" id="apidoc.element.q-io.fs.relative">
        function <span class="apidocSignatureSpan">q-io.fs.</span>relative
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">relative = function (source, target) {
    var self = this;
    return Q.when(this.isDirectory(source), function (isDirectory) {
        if (isDirectory) {
            return self.relativeFromDirectory(source, target);
        } else {
            return self.relativeFromFile(source, target);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return self.remove(path);
        }
    });
};

exports.symbolicCopy = function (source, target, type) {
    var self = this;
    return Q.when(self.<span class="apidocCodeKeywordSpan">relative</span>(target, source), function (relative) {
        return self.symbolicLink(target, relative, type || &#x22;file&#x22;);
    });
};

exports.exists = function (path) {
    return Q.when(this.stat(path), function () {
        return true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.relativeFromDirectory" id="apidoc.element.q-io.fs.relativeFromDirectory">
        function <span class="apidocSignatureSpan">q-io.fs.</span>relativeFromDirectory
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">relativeFromDirectory = function (source, target) {
    if (!target) {
        target = source;
        source = workingDirectory();
    }
    source = this.absolute(source);
    target = this.absolute(target);
    source = source.split(this.SEPARATORS_RE());
    target = target.split(this.SEPARATORS_RE());
    if (source.length === 2 &#x26;&#x26; source[1] === &#x22;&#x22;)
        source.pop();
    while (
        source.length &#x26;&#x26;
        target.length &#x26;&#x26;
        target[0] == source[0]
    ) {
        source.shift();
        target.shift();
    }
    while (source.length) {
        source.shift();
        target.unshift(&#x22;..&#x22;);
    }
    return target.join(this.SEPARATOR);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return this.join(workingDirectory(), path);
};

exports.relative = function (source, target) {
    var self = this;
    return Q.when(this.isDirectory(source), function (isDirectory) {
        if (isDirectory) {
            return self.<span class="apidocCodeKeywordSpan">relativeFromDirectory</span>(source, target);
        } else {
            return self.relativeFromFile(source, target);
        }
    });
};

exports.relativeFromFile = function (source, target) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.relativeFromFile" id="apidoc.element.q-io.fs.relativeFromFile">
        function <span class="apidocSignatureSpan">q-io.fs.</span>relativeFromFile
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">relativeFromFile = function (source, target) {
    var self = this;
    source = self.absolute(source);
    target = self.absolute(target);
    source = source.split(self.SEPARATORS_RE());
    target = target.split(self.SEPARATORS_RE());
    source.pop();
    while (
        source.length &#x26;&#x26;
        target.length &#x26;&#x26;
        target[0] == source[0]
    ) {
        source.shift();
        target.shift();
    }
    while (source.length) {
        source.shift();
        target.unshift(&#x22;..&#x22;);
    }
    return target.join(self.SEPARATOR);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.relative = function (source, target) {
    var self = this;
    return Q.when(this.isDirectory(source), function (isDirectory) {
        if (isDirectory) {
            return self.relativeFromDirectory(source, target);
        } else {
            return self.<span class="apidocCodeKeywordSpan">relativeFromFile</span>(source, target);
        }
    });
};

exports.relativeFromFile = function (source, target) {
    var self = this;
    source = self.absolute(source);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.remove" id="apidoc.element.q-io.fs.remove">
        function <span class="apidocSignatureSpan">q-io.fs.</span>remove
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (path) {
    path = String(path);
    var done = Q.defer();
    FS.unlink(path, function (error) {
        if (error) {
            error.message = &#x22;Can&#x27;t remove &#x22; + JSON.stringify(path) + &#x22;: &#x22; + error.message;
            done.reject(error);
        } else {
            done.resolve();
        }
    });
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }, undefined);
};

exports.removeTree = function (path) {
    var self = this;
    return Q.when(self.statLink(path), function (stat) {
        if (stat.isSymbolicLink()) {
            return self.<span class="apidocCodeKeywordSpan">remove</span>(path);
        } else if (stat.isDirectory()) {
            return self.list(path)
            .then(function (list) {
                // asynchronously remove every subtree
                return Q.all(list.map(function (name) {
                    return self.removeTree(self.join(path, name));
                }))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.removeDirectory" id="apidoc.element.q-io.fs.removeDirectory">
        function <span class="apidocSignatureSpan">q-io.fs.</span>removeDirectory
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeDirectory = function (path) {
    path = String(path);
    var done = Q.defer();
    FS.rmdir(path, function (error) {
        if (error) {
            error.message = &#x22;Can&#x27;t removeDirectory &#x22; + JSON.stringify(path) + &#x22;: &#x22; + error.message;
            done.reject(error);
        } else {
            done.resolve();
        }
    });
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return self.list(path)
            .then(function (list) {
                // asynchronously remove every subtree
                return Q.all(list.map(function (name) {
                    return self.removeTree(self.join(path, name));
                }))
                .then(function () {
                    return self.<span class="apidocCodeKeywordSpan">removeDirectory</span>(path);
                });
            });
        } else {
            return self.remove(path);
        }
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.removeTree" id="apidoc.element.q-io.fs.removeTree">
        function <span class="apidocSignatureSpan">q-io.fs.</span>removeTree
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTree = function (path) {
    var self = this;
    return Q.when(self.statLink(path), function (stat) {
        if (stat.isSymbolicLink()) {
            return self.remove(path);
        } else if (stat.isDirectory()) {
            return self.list(path)
            .then(function (list) {
                // asynchronously remove every subtree
                return Q.all(list.map(function (name) {
                    return self.removeTree(self.join(path, name));
                }))
                .then(function () {
                    return self.removeDirectory(path);
                });
            });
        } else {
            return self.remove(path);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.move = function (source, target) {
    var self = this;
    return this.rename(source, target)
    .catch(function (error) {
        if (error.crossDevice) {
            return self.copyTree(source, target)
            .then(function () {
                return self.<span class="apidocCodeKeywordSpan">removeTree</span>(source);
            });
        } else {
            throw error;
        }
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.rename" id="apidoc.element.q-io.fs.rename">
        function <span class="apidocSignatureSpan">q-io.fs.</span>rename
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rename = function (source, target) {
    source = String(source);
    target = String(target);
    return Q.ninvoke(FS, &#x22;rename&#x22;, source, target)
    .fail(function (error) {
        if (error.code === &#x22;EXDEV&#x22;) {
            error.message = &#x22;source and target are on different devices: &#x22; + error.message;
            error.crossDevice = true;
        }
        error.message = (
            &#x22;Can&#x27;t move &#x22; + JSON.stringify(source) + &#x22; to &#x22; +
            JSON.stringify(target) + &#x22; because &#x22; + error.message
        );
        throw error;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return stream.close();
        });
    });
};

exports.move = function (source, target) {
    var self = this;
    return this.<span class="apidocCodeKeywordSpan">rename</span>(source, target)
    .catch(function (error) {
        if (error.crossDevice) {
            return self.copyTree(source, target)
            .then(function () {
                return self.removeTree(source);
            });
        } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.reroot" id="apidoc.element.q-io.fs.reroot">
        function <span class="apidocSignatureSpan">q-io.fs.</span>reroot
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reroot(path) {
    var self = this;
    path = path || this.ROOT;
    return RootFs(self, path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.resolve" id="apidoc.element.q-io.fs.resolve">
        function <span class="apidocSignatureSpan">q-io.fs.</span>resolve
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function () {
    var root = &#x22;&#x22;;
    var parents = [];
    var children = [];
    var leaf = &#x22;&#x22;;
    for (var i = 0; i &#x3c; arguments.length; i++) {
        var path = String(arguments[i]);
        if (path == &#x22;&#x22;)
            continue;
        var parts = path.split(exports.SEPARATORS_RE());
        if (exports.isAbsolute(path)) {
            root = parts.shift() + exports.SEPARATOR;
            parents = [];
            children = [];
        }
        leaf = parts.pop();
        if (leaf == &#x22;.&#x22; || leaf == &#x22;..&#x22;) {
            parts.push(leaf);
            leaf = &#x22;&#x22;;
        }
        for (var j = 0; j &#x3c; parts.length; j++) {
            var part = parts[j];
            if (part == &#x22;.&#x22; || part == &#x22;&#x22;) {
            } else if (part == &#x22;..&#x22;) {
                if (children.length) {
                    children.pop();
                } else {
                    if (root) {
                    } else {
                        parents.push(&#x22;..&#x22;);
                    }
                }
            } else {
                children.push(part);
            }
        };
    }
    path = parents.concat(children).join(exports.SEPARATOR);
    if (path) leaf = exports.SEPARATOR + leaf;
    return root + path + leaf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

BufferStream.prototype.read = function () {
var result;
result = Reader.join(this._chunks);
if (this._charset) {
    result = result.toString(this._charset);
}
return Q.<span class="apidocCodeKeywordSpan">resolve</span>(result);
};

BufferStream.prototype.write = function (chunk) {
if (this._charset) {
    chunk = new Buffer(String(chunk), this._charset);
} else {
    if (!(chunk instanceof Buffer)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.root" id="apidoc.element.q-io.fs.root">
        function <span class="apidocSignatureSpan">q-io.fs.</span>root
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">root = function (path) {
    if (!exports.isAbsolute(path))
        path = require(&#x22;./fs&#x22;).absolute(path);
    var parts = exports.split(path);
    return exports.join(parts[0], &#x22;&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.split" id="apidoc.element.q-io.fs.split">
        function <span class="apidocSignatureSpan">q-io.fs.</span>split
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (path) {
    var parts;
    try {
        parts = String(path).split(exports.SEPARATORS_RE());
    } catch (exception) {
        throw new Error(&#x22;Cannot split &#x22; + (typeof path) + &#x22;, &#x22; + JSON.stringify(path));
    }
    // this special case helps isAbsolute
    // distinguish an empty path from an absolute path
    // &#x22;&#x22; -&#x3e; [] NOT [&#x22;&#x22;]
    if (parts.length === 1 &#x26;&#x26; parts[0] === &#x22;&#x22;)
        return [];
    // &#x22;a&#x22; -&#x3e; [&#x22;a&#x22;]
    // &#x22;/a&#x22; -&#x3e; [&#x22;&#x22;, &#x22;a&#x22;]
    return parts;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * file system, indicated by an empty string on Unix, and a
 * drive letter followed by a colon on Windows.
 * @returns {Array * String}
 */
exports.split = function (path) {
var parts;
try {
    parts = String(path).<span class="apidocCodeKeywordSpan">split</span>(exports.SEPARATORS_RE());
} catch (exception) {
    throw new Error(&#x22;Cannot split &#x22; + (typeof path) + &#x22;, &#x22; + JSON.stringify(path));
}
// this special case helps isAbsolute
// distinguish an empty path from an absolute path
// &#x22;&#x22; -&#x3e; [] NOT [&#x22;&#x22;]
if (parts.length === 1 &#x26;&#x26; parts[0] === &#x22;&#x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.stat" id="apidoc.element.q-io.fs.stat">
        function <span class="apidocSignatureSpan">q-io.fs.</span>stat
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stat = function (path) {
    var self = this;
    path = String(path);
    var done = Q.defer();
    try {
        FS.stat(path, function (error, stat) {
            if (error) {
                error.message = &#x22;Can&#x27;t stat &#x22; + JSON.stringify(path) + &#x22;: &#x22; + error;
                done.reject(error);
            } else {
                done.resolve(new self.Stats(stat));
            }
        });
    } catch (error) {
        done.reject(error);
    }
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            throw error;
        }
    });
};

exports.copy = function (source, target) {
    var self = this;
    return Q.when(self.<span class="apidocCodeKeywordSpan">stat</span>(source), function (stat) {
        var mode = stat.node.mode;
        return Q.all([
            self.open(source, {flags: &#x22;rb&#x22;}),
            self.open(target, {flags: &#x22;wb&#x22;, mode: mode})
        ]);
    })
    .spread(function (reader, writer) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.statFd" id="apidoc.element.q-io.fs.statFd">
        function <span class="apidocSignatureSpan">q-io.fs.</span>statFd
        <span class="apidocSignatureSpan">(fd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statFd = function (fd) {
    fd = Number(fd);
    var done = Q.defer();
    try {
        FS.fstat(fd, function (error, stat) {
            if (error) {
                error.message = &#x22;Can&#x27;t statFd file descriptor &#x22; + JSON.stringify(fd) + &#x22;: &#x22; + error.message;
                done.reject(error);
            } else {
                done.resolve(stat);
            }
        });
    } catch (error) {
        done.reject(error);
    }
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.statLink" id="apidoc.element.q-io.fs.statLink">
        function <span class="apidocSignatureSpan">q-io.fs.</span>statLink
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statLink = function (path) {
    path = String(path);
    var done = Q.defer();
    try {
        FS.lstat(path, function (error, stat) {
            if (error) {
                error.message = &#x22;Can&#x27;t statLink &#x22; + JSON.stringify(path) + &#x22;: &#x22; + error.message;
                done.reject(error);
            } else {
                done.resolve(stat);
            }
        });
    } catch (error) {
        done.reject(error);
    }
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            });
        });
    }, undefined);
};

exports.removeTree = function (path) {
    var self = this;
    return Q.when(self.<span class="apidocCodeKeywordSpan">statLink</span>(path), function (stat) {
        if (stat.isSymbolicLink()) {
            return self.remove(path);
        } else if (stat.isDirectory()) {
            return self.list(path)
            .then(function (list) {
                // asynchronously remove every subtree
                return Q.all(list.map(function (name) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.symbolicCopy" id="apidoc.element.q-io.fs.symbolicCopy">
        function <span class="apidocSignatureSpan">q-io.fs.</span>symbolicCopy
        <span class="apidocSignatureSpan">(source, target, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symbolicCopy = function (source, target, type) {
    var self = this;
    return Q.when(self.relative(target, source), function (relative) {
        return self.symbolicLink(target, relative, type || &#x22;file&#x22;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                } else {
                    return Q.when(self.makeDirectory(target, stat.node.mode), copySubTree);
                }
            });
        } else if (stat.isSymbolicLink()) {
            // TODO copy the link and type with readPath (but what about
            // Windows junction type?)
            return self.<span class="apidocCodeKeywordSpan">symbolicCopy</span>(source, target);
        }
    });
};

exports.listTree = function (basePath, guard) {
    var self = this;
    basePath = String(basePath || &#x27;&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.symbolicLink" id="apidoc.element.q-io.fs.symbolicLink">
        function <span class="apidocSignatureSpan">q-io.fs.</span>symbolicLink
        <span class="apidocSignatureSpan">(target, relative, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symbolicLink = function (target, relative, type) {
    if (!linkTypes.hasOwnProperty(type)) {
        console.warn(new Error(&#x22;For Windows compatibility, symbolicLink must be called with a type argument \&#x22;file\&#x22;, \&#x22;directory\&#x22;, or \&#x22;junction\&#x22;&#x22;));
    }
    type = linkTypes[type];
    target = String(target);
    relative = String(relative);
    var done = Q.defer();
    try {
        FS.symlink(relative, target, type || &#x27;file&#x27;, function (error) {
            if (error) {
                error.message = &#x22;Can&#x27;t create symbolicLink &#x22; + JSON.stringify(target) + &#x22; to relative location &#x22; + JSON.stringify
(relative) + &#x22;: &#x22; + error.message;
                done.reject(error);
            } else {
                done.resolve();
            }
        });
    } catch (error) {
        done.reject(error);
    }
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    });
};

exports.symbolicCopy = function (source, target, type) {
    var self = this;
    return Q.when(self.relative(target, source), function (relative) {
        return self.<span class="apidocCodeKeywordSpan">symbolicLink</span>(target, relative, type || &#x22;file&#x22;);
    });
};

exports.exists = function (path) {
    return Q.when(this.stat(path), function () {
        return true;
    }, function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.toObject" id="apidoc.element.q-io.fs.toObject">
        function <span class="apidocSignatureSpan">q-io.fs.</span>toObject
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toObject = function (path) {
    var self = this;
    var list = self.listTree(path || &#x22;&#x22;, function (path, stat) {
        return stat.isFile();
    });
    return Q.when(list, function (list) {
        var tree = {};
        return Q.all(list.map(function (path) {
            return Q.when(self.read(path, &#x22;rb&#x22;), function (content) {
                tree[path] = content;
            });
        })).then(function () {
            return tree;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.write" id="apidoc.element.q-io.fs.write">
        function <span class="apidocSignatureSpan">q-io.fs.</span>write
        <span class="apidocSignatureSpan">(path, content, flags, charset, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (path, content, flags, charset, options) {
    var self = this;
    if (typeof flags === &#x22;object&#x22;) {
        options = flags;
    } else if (typeof charset === &#x22;object&#x22;) {
        options = charset;
        options.flags = flags;
    } else {
        options = options || {};
        options.flags = flags;
        options.charset = charset;
    }
    flags = options.flags || &#x22;w&#x22;;
    if (flags.indexOf(&#x22;b&#x22;) !== -1) {
        if (!(content instanceof Buffer)) {
            content = new Buffer(content);
        }
    } else if (content instanceof Buffer) {
        flags += &#x22;b&#x22;;
    }
    options.flags = flags;
    return Q.when(self.open(path, options), function (stream) {
        return Q.when(stream.write(content), function () {
            return stream.close();
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`write` is a shortcut for opening a file and writing its entire content
from a single string or buffer.

The options are identical to that of `open`, but the &#x22;w&#x22; flag is
implied, and the &#x22;b&#x22; flag is implied if the content is a buffer.

```javascript
return FS.<span class="apidocCodeKeywordSpan">write</span>(&#x22;hello.txt&#x22;, &#x22;Hello, World!\n&#x22;)
.then(function () {
    return FS.read(&#x22;hello.txt&#x22;)
})
.then(function (hello) {
    expect(hello).toBe(&#x22;Hello, World!\n&#x22;)
})
```
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.fs2http" id="apidoc.module.q-io.fs2http">module q-io.fs2http</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.fs2http.Client" id="apidoc.element.q-io.fs2http.Client">
        function <span class="apidocSignatureSpan">q-io.fs2http.</span>Client
        <span class="apidocSignatureSpan">(fs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client(fs) {
    var self = Object.create(Client.prototype);

    self.request = function (request) {
        return Q.when(request, function (request) {
            request = HTTP.normalizeRequest(request);
            var url = URL.parse(request.url);
            if (url.protocol !== &#x22;file:&#x22;) {
                return {
                    status: 404,
                    headers: {},
                    body: [&#x22;Can&#x27;t access protocol &#x22; + url.protocol]
                };
            } else {
                var path = url.pathname;
                return fs.open(path, {
                    charset: request.charset
                }).then(function (body) {
                    return {
                        status: 200,
                        headers: {},
                        body: body
                    };
                });
            }
        });
    };

    self.read = function (request, qualifier) {
        qualifier = qualifier || function (response) {
            return response.status === 200;
        };
        return Q.when(exports.request(request), function (response) {
            if (!qualifier(response)){
                var error = new Error(&#x22;HTTP request failed with code &#x22; + response.status);
                error.response = response;
                throw error;
            }
            return Q.invoke(response.body, &#x22;read&#x22;);
        });
    };

    return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs2http.read" id="apidoc.element.q-io.fs2http.read">
        function <span class="apidocSignatureSpan">q-io.fs2http.</span>read
        <span class="apidocSignatureSpan">(request, qualifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (request, qualifier) {
    return Q.fcall(require.async || require, &#x22;./fs&#x22;)
    .then(function (fs) {
        return Client(fs).read(request);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
into memory.  It returns a promise for the whole file contents.  By
default, `read` provides a string decoded from UTF-8.  With the bytewise
mode flag, provides a `Buffer`.

The options argument is identical to that of `open`.

```javascript
return FS.<span class="apidocCodeKeywordSpan">read</span>(__filename, &#x22;b&#x22;)
.then(function (content) {
    // ...
})
```

```javascript
return FS.read(__filename, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs2http.request" id="apidoc.element.q-io.fs2http.request">
        function <span class="apidocSignatureSpan">q-io.fs2http.</span>request
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">request = function (request) {
    return Q.fcall(require.async || require, &#x22;./fs&#x22;)
    .then(function (fs) {
        return Client(fs).request(request);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
};

self.read = function (request, qualifier) {
    qualifier = qualifier || function (response) {
        return response.status === 200;
    };
    return Q.when(exports.<span class="apidocCodeKeywordSpan">request</span>(request), function (response) {
        if (!qualifier(response)){
            var error = new Error(&#x22;HTTP request failed with code &#x22; + response.status);
            error.response = response;
            throw error;
        }
        return Q.invoke(response.body, &#x22;read&#x22;);
    });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.fs_boot" id="apidoc.module.q-io.fs_boot">module q-io.fs_boot</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.fs_boot.SEPARATORS_RE" id="apidoc.element.q-io.fs_boot.SEPARATORS_RE">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>SEPARATORS_RE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SEPARATORS_RE = function () {
    if (
        separatorCached !== exports.SEPARATOR ||
        altSeparatorCached !== exports.ALT_SEPARATOR
    ) {
        separatorCached = exports.SEPARATOR;
        altSeparatorCached = exports.ALT_SEPARATOR;
        separatorReCached = new RegExp(&#x22;[&#x22; +
            (separatorCached || &#x22;&#x22;).replace(/[-[\]{}()*+?.\\^$|,#\s]/g, &#x22;\\$&#x26;&#x22;) +
            (altSeparatorCached || &#x22;&#x22;).replace(/[-[\]{}()*+?.\\^$|,#\s]/g, &#x22;\\$&#x26;&#x22;) +
        &#x22;]&#x22;, &#x22;g&#x22;);
    }
    return separatorReCached;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * file system, indicated by an empty string on Unix, and a
 * drive letter followed by a colon on Windows.
 * @returns {Array * String}
 */
exports.split = function (path) {
var parts;
try {
    parts = String(path).split(exports.<span class="apidocCodeKeywordSpan">SEPARATORS_RE</span>());
} catch (exception) {
    throw new Error(&#x22;Cannot split &#x22; + (typeof path) + &#x22;, &#x22; + JSON.stringify(path));
}
// this special case helps isAbsolute
// distinguish an empty path from an absolute path
// &#x22;&#x22; -&#x3e; [] NOT [&#x22;&#x22;]
if (parts.length === 1 &#x26;&#x26; parts[0] === &#x22;&#x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.base" id="apidoc.element.q-io.fs_boot.base">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>base
        <span class="apidocSignatureSpan">(path, extension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base = function (path, extension) {
    var base = path.split(exports.SEPARATORS_RE()).pop();
    if (extension)
        base = base.replace(
            new RegExp(regExpEscape(extension) + &#x22;$&#x22;),
            &#x22;&#x22;
        );
    return base;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * @returns {String} the extension (e.g., `txt`) of the file
 * at the given path.
 */
exports.extension = function (path) {
    path = exports.<span class="apidocCodeKeywordSpan">base</span>(path);
    path = path.replace(/^\.*/, &#x22;&#x22;);
    var index = path.lastIndexOf(&#x22;.&#x22;);
    return index &#x3c;= 0 ? &#x22;&#x22; : path.substring(index);
};

})(typeof exports !== &#x22;undefined&#x22; ? exports : FS_BOOT = {});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.directory" id="apidoc.element.q-io.fs_boot.directory">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>directory
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directory = function (path) {
    path = exports.normal(path);
    var absolute = exports.isAbsolute(path);
    var parts = exports.split(path);
    // XXX needs to be sensitive to the root for
    // Windows compatibility
    if (parts.length) {
        if (parts[parts.length - 1] == &#x22;..&#x22;) {
            parts.push(&#x22;..&#x22;);
        } else {
            parts.pop();
        }
    } else {
        parts.unshift(&#x22;..&#x22;);
    }
    return parts.join(exports.SEPARATOR) || (
        exports.isRelative(path) ?
        &#x22;&#x22; : exports.ROOT
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.extension" id="apidoc.element.q-io.fs_boot.extension">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>extension
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extension = function (path) {
    path = exports.base(path);
    path = path.replace(/^\.*/, &#x22;&#x22;);
    var index = path.lastIndexOf(&#x22;.&#x22;);
    return index &#x3c;= 0 ? &#x22;&#x22; : path.substring(index);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.isAbsolute" id="apidoc.element.q-io.fs_boot.isAbsolute">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>isAbsolute
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAbsolute = function (path) {
    // for absolute paths on any operating system,
    // the first path component always determines
    // whether it is relative or absolute.  On Unix,
    // it is empty, so [&#x22;&#x22;, &#x22;foo&#x22;].join(&#x22;/&#x22;) == &#x22;/foo&#x22;,
    // &#x22;/foo&#x22;.split(&#x22;/&#x22;) == [&#x22;&#x22;, &#x22;foo&#x22;].
    var parts = exports.split(path);
    // split(&#x22;&#x22;) == [].  &#x22;&#x22; is not absolute.
    // split(&#x22;/&#x22;) == [&#x22;&#x22;, &#x22;&#x22;] is absolute.
    // split(?) == [&#x22;&#x22;] does not occur.
    if (parts.length == 0)
        return false;
    return exports.isRoot(parts[0]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var children = [];
var leaf = &#x22;&#x22;;
for (var i = 0; i &#x3c; arguments.length; i++) {
    var path = String(arguments[i]);
    if (path == &#x22;&#x22;)
        continue;
    var parts = path.split(exports.SEPARATORS_RE());
    if (exports.<span class="apidocCodeKeywordSpan">isAbsolute</span>(path)) {
        root = parts.shift() + exports.SEPARATOR;
        parents = [];
        children = [];
    }
    leaf = parts.pop();
    if (leaf == &#x22;.&#x22; || leaf == &#x22;..&#x22;) {
        parts.push(leaf);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.isRelative" id="apidoc.element.q-io.fs_boot.isRelative">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>isRelative
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRelative = function (path) {
    return !exports.isAbsolute(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       } else {
           parts.pop();
       }
   } else {
       parts.unshift(&#x22;..&#x22;);
   }
   return parts.join(exports.SEPARATOR) || (
       exports.<span class="apidocCodeKeywordSpan">isRelative</span>(path) ?
       &#x22;&#x22; : exports.ROOT
   );
};

/**
* @returns {String} the last component of a path, without
* the given extension if the extension is provided and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.isRoot" id="apidoc.element.q-io.fs_boot.isRoot">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>isRoot
        <span class="apidocSignatureSpan">(first)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRoot = function (first) {
    if (exports.SEPARATOR === &#x22;\\&#x22;) {
        return /[a-zA-Z]:$/.test(first);
    } else {
        return first == &#x22;&#x22;;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // &#x22;/foo&#x22;.split(&#x22;/&#x22;) == [&#x22;&#x22;, &#x22;foo&#x22;].
    var parts = exports.split(path);
    // split(&#x22;&#x22;) == [].  &#x22;&#x22; is not absolute.
    // split(&#x22;/&#x22;) == [&#x22;&#x22;, &#x22;&#x22;] is absolute.
    // split(?) == [&#x22;&#x22;] does not occur.
    if (parts.length == 0)
        return false;
    return exports.<span class="apidocCodeKeywordSpan">isRoot</span>(parts[0]);
};

/**
 * @returns {Boolean} whether the given path does not begin
 * at the root of the file system or a drive letter.
 */
exports.isRelative = function (path) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.join" id="apidoc.element.q-io.fs_boot.join">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>join
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">join = function () {
    if (arguments.length === 1 &#x26;&#x26; Array.isArray(arguments[0]))
        return exports.normal.apply(exports, arguments[0]);
    return exports.normal.apply(exports, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return Q.fcall(function () {
        chunks.splice(0, chunks.length).forEach(write, thisp);
    });
};

BufferStream.prototype.read = function () {
    var result;
    result = Reader.<span class="apidocCodeKeywordSpan">join</span>(this._chunks);
    if (this._charset) {
        result = result.toString(this._charset);
    }
    return Q.resolve(result);
};

BufferStream.prototype.write = function (chunk) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.normal" id="apidoc.element.q-io.fs_boot.normal">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>normal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normal = function () {
    var root = &#x22;&#x22;;
    var parents = [];
    var children = [];
    for (var i = 0, ii = arguments.length; i &#x3c; ii; i++) {
        var path = String(arguments[i]);
        // empty paths have no affect
        if (path === &#x22;&#x22;)
            continue;
        var parts = path.split(exports.SEPARATORS_RE());
        if (exports.isAbsolute(path)) {
            root = parts.shift() + exports.SEPARATOR;
            parents = [];
            children = [];
        }
        for (var j = 0, jj = parts.length; j &#x3c; jj; j++) {
            var part = parts[j];
            if (part === &#x22;.&#x22; || part === &#x22;&#x22;) {
            } else if (part == &#x22;..&#x22;) {
                if (children.length) {
                    children.pop();
                } else {
                    if (root) {
                    } else {
                        parents.push(&#x22;..&#x22;);
                    }
                }
            } else {
                children.push(part);
            }
        }
    }
    path = parents.concat(children).join(exports.SEPARATOR);
    return root + path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return exports.join(parts[0], &#x22;&#x22;);
};

/**
 * @returns {String} the parent directory of the given path.
 */
exports.directory = function (path) {
path = exports.<span class="apidocCodeKeywordSpan">normal</span>(path);
var absolute = exports.isAbsolute(path);
var parts = exports.split(path);
// XXX needs to be sensitive to the root for
// Windows compatibility
if (parts.length) {
    if (parts[parts.length - 1] == &#x22;..&#x22;) {
        parts.push(&#x22;..&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.resolve" id="apidoc.element.q-io.fs_boot.resolve">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>resolve
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function () {
    var root = &#x22;&#x22;;
    var parents = [];
    var children = [];
    var leaf = &#x22;&#x22;;
    for (var i = 0; i &#x3c; arguments.length; i++) {
        var path = String(arguments[i]);
        if (path == &#x22;&#x22;)
            continue;
        var parts = path.split(exports.SEPARATORS_RE());
        if (exports.isAbsolute(path)) {
            root = parts.shift() + exports.SEPARATOR;
            parents = [];
            children = [];
        }
        leaf = parts.pop();
        if (leaf == &#x22;.&#x22; || leaf == &#x22;..&#x22;) {
            parts.push(leaf);
            leaf = &#x22;&#x22;;
        }
        for (var j = 0; j &#x3c; parts.length; j++) {
            var part = parts[j];
            if (part == &#x22;.&#x22; || part == &#x22;&#x22;) {
            } else if (part == &#x22;..&#x22;) {
                if (children.length) {
                    children.pop();
                } else {
                    if (root) {
                    } else {
                        parents.push(&#x22;..&#x22;);
                    }
                }
            } else {
                children.push(part);
            }
        };
    }
    path = parents.concat(children).join(exports.SEPARATOR);
    if (path) leaf = exports.SEPARATOR + leaf;
    return root + path + leaf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

BufferStream.prototype.read = function () {
var result;
result = Reader.join(this._chunks);
if (this._charset) {
    result = result.toString(this._charset);
}
return Q.<span class="apidocCodeKeywordSpan">resolve</span>(result);
};

BufferStream.prototype.write = function (chunk) {
if (this._charset) {
    chunk = new Buffer(String(chunk), this._charset);
} else {
    if (!(chunk instanceof Buffer)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.root" id="apidoc.element.q-io.fs_boot.root">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>root
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">root = function (path) {
    if (!exports.isAbsolute(path))
        path = require(&#x22;./fs&#x22;).absolute(path);
    var parts = exports.split(path);
    return exports.join(parts[0], &#x22;&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.split" id="apidoc.element.q-io.fs_boot.split">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>split
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (path) {
    var parts;
    try {
        parts = String(path).split(exports.SEPARATORS_RE());
    } catch (exception) {
        throw new Error(&#x22;Cannot split &#x22; + (typeof path) + &#x22;, &#x22; + JSON.stringify(path));
    }
    // this special case helps isAbsolute
    // distinguish an empty path from an absolute path
    // &#x22;&#x22; -&#x3e; [] NOT [&#x22;&#x22;]
    if (parts.length === 1 &#x26;&#x26; parts[0] === &#x22;&#x22;)
        return [];
    // &#x22;a&#x22; -&#x3e; [&#x22;a&#x22;]
    // &#x22;/a&#x22; -&#x3e; [&#x22;&#x22;, &#x22;a&#x22;]
    return parts;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * file system, indicated by an empty string on Unix, and a
 * drive letter followed by a colon on Windows.
 * @returns {Array * String}
 */
exports.split = function (path) {
var parts;
try {
    parts = String(path).<span class="apidocCodeKeywordSpan">split</span>(exports.SEPARATORS_RE());
} catch (exception) {
    throw new Error(&#x22;Cannot split &#x22; + (typeof path) + &#x22;, &#x22; + JSON.stringify(path));
}
// this special case helps isAbsolute
// distinguish an empty path from an absolute path
// &#x22;&#x22; -&#x3e; [] NOT [&#x22;&#x22;]
if (parts.length === 1 &#x26;&#x26; parts[0] === &#x22;&#x22;)
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.fs_common" id="apidoc.module.q-io.fs_common">module q-io.fs_common</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.fs_common.update" id="apidoc.element.q-io.fs_common.update">
        function <span class="apidocSignatureSpan">q-io.fs_common.</span>update
        <span class="apidocSignatureSpan">(exports, workingDirectory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (exports, workingDirectory) {

    for (var name in Boot) {
        exports[name] = Boot[name];
    }

<span class="apidocCodeCommentSpan">    /**
     * Read a complete file.
     * @param {String} path    Path to the file.
     * @param {String} [options.flags]  The mode to open the file with.
     * @param {String} [options.charset]  The charset to open the file with.
     * @param {Object} [options]   An object with options.
     * second argument.
     * @returns {Promise * (String || Buffer)}
     */
</span>    exports.read = function (path, flags, charset, options) {
        if (typeof flags === &#x22;object&#x22;) {
            options = flags;
        } else if (typeof charset === &#x22;object&#x22;) {
            options = charset;
            options.flags = flags;
        } else {
            options = options || {};
            options.flags = flags;
            options.charset = charset;
        }
        options.flags = options.flags || &#x22;r&#x22;;
        return Q.when(this.open(path, options), function (stream) {
            return stream.read();
        }, function (error) {
            error.message = &#x22;Can&#x27;t read &#x22; + path + &#x22; because &#x22; + error.message;
            error.path = path;
            error.flags = flags;
            error.charset = charset;
            throw error;
        });
    };

    /**
     * Write content to a file, overwriting the existing content.
     * @param {String} path    Path to the file.
     * @param {String || Buffer} content
     * @param {String} [options.flags]  The mode to open the file with.
     * @param {String} [options.charset]  The charset to open the file with.
     * @param {Object} [options]   An object with options.
     * @returns {Promise * Undefined} a promise that resolves
     * when the writing is complete.
     */
    exports.write = function (path, content, flags, charset, options) {
        var self = this;
        if (typeof flags === &#x22;object&#x22;) {
            options = flags;
        } else if (typeof charset === &#x22;object&#x22;) {
            options = charset;
            options.flags = flags;
        } else {
            options = options || {};
            options.flags = flags;
            options.charset = charset;
        }
        flags = options.flags || &#x22;w&#x22;;
        if (flags.indexOf(&#x22;b&#x22;) !== -1) {
            if (!(content instanceof Buffer)) {
                content = new Buffer(content);
            }
        } else if (content instanceof Buffer) {
            flags += &#x22;b&#x22;;
        }
        options.flags = flags;
        return Q.when(self.open(path, options), function (stream) {
            return Q.when(stream.write(content), function () {
                return stream.close();
            });
        });
    };

    /**
     * Append content to the end of a file.
     * @param {String} path    Path to the file.
     * @param {String || Buffer} content
     * @param {String} [options.flags]  The mode to open the file with.
     * @param {String} [options.charset]  The charset to open the file with.
     * @param {Object} [options]   An object with options.
     * @returns {Promise * Undefined} a promise that resolves
     * when the writing is complete.
     */
    exports.append = function (path, content, flags, charset, options) {
        var self = this;
        if (typeof flags === &#x22;object&#x22;) {
            options = flags;
        } else if (typeof charset === &#x22;object&#x22;) {
            options = charset;
            options.flags = flags;
        } else {
            options = options || {};
            options.flags = flags;
            options.charset = charset;
        }
        flags = options.flags || &#x22;a&#x22;;
        if (content instanceof Buffer) {
            flags += &#x22;b&#x22;;
        }
        options.flags = flags;
        return Q.when(self.open(path, options), function (stream) {
            return Q.when(stream.write(content), function () {
                return stream.close();
            });
        });
    };

    exports.move = function (source, target) {
        var self = this;
        return this.rename(source, target)
        .catch(function (error) {
            if (error.crossDevic ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
}

function workingDirectory() {
    return outer.ROOT;
}

COMMON.<span class="apidocCodeKeywordSpan">update</span>(inner, workingDirectory);

inner.list = function (path) {
    return attenuate(path).then(function (path) {
        return outer.list(path.outer);
    }).then(null, function (reason) {
        return Q.reject(&#x22;Can&#x27;t list &#x22; + JSON.stringify(path));
    });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.fs_root" id="apidoc.module.q-io.fs_root">module q-io.fs_root</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.fs_root.fs_root" id="apidoc.element.q-io.fs_root.fs_root">
        function <span class="apidocSignatureSpan">q-io.</span>fs_root
        <span class="apidocSignatureSpan">(outer, root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RootFs(outer, root) {
    var inner = Object.create(BOOT);

    function attenuate(path) {

        // the machinations of projecting a path inside a
        // subroot
        var actual;
        // if it&#x27;s absolute, we want the path relative to
        // the root of the inner file system
        if (outer.isAbsolute(path)) {
            actual = outer.relativeFromDirectory(outer.ROOT, path);
        } else {
            actual = path;
        }
        // we join the path onto the root of the inner file
        // system so that parent references from the root
        // return to the root, emulating standard unix
        // behavior
        actual = outer.join(outer.ROOT, actual);
        // then we reconstruct the path relative to the
        // inner root
        actual = outer.relativeFromDirectory(outer.ROOT, actual);
        // and rejoin it on the outer root
        actual = outer.join(root, actual);
        // and find the corresponding real path
        return outer.canonical(actual)
        .then(function (actual) {
            return actual;
        }, function () {
            return actual;
        }).then(function (actual) {
            // and verify that the outer canonical path is
            // actually inside the inner canonical path, to
            // prevent break-outs
            if (outer.contains(root, actual)) {
                return {
                    &#x22;inner&#x22;: outer.join(outer.ROOT, outer.relativeFromDirectory(root, actual)),
                    &#x22;outer&#x22;: actual
                };
            } else {
                return Q.reject(&#x22;Can&#x27;t find: &#x22; + JSON.stringify(path));
            }
        });
    }

    function workingDirectory() {
        return outer.ROOT;
    }

    COMMON.update(inner, workingDirectory);

    inner.list = function (path) {
        return attenuate(path).then(function (path) {
            return outer.list(path.outer);
        }).then(null, function (reason) {
            return Q.reject(&#x22;Can&#x27;t list &#x22; + JSON.stringify(path));
        });
    };

    inner.open = function (path, flags, charset) {
        return attenuate(path).then(function (path) {
            return outer.open(path.outer, flags, charset);
        }).then(null, function (reason) {
            return Q.reject(&#x22;Can&#x27;t open &#x22; + JSON.stringify(path));
        });
    };

    inner.stat = function (path) {
        return attenuate(path).then(function (path) {
            return outer.stat(path.outer);
        }).then(null, function (reason) {
            return Q.reject(&#x22;Can&#x27;t stat &#x22; + JSON.stringify(path));
        });
    };

    inner.statLink = function (path) {
        return attenuate(path).then(function (path) {
            return outer.statLink(path.outer);
        }).then(null, function (reason) {
            return Q.reject(&#x22;Can&#x27;t statLink &#x22; + JSON.stringify(path));
        });
    };

    inner.canonical = function (path) {
        return attenuate(path).then(function (path) {
            return path.inner;
        }).then(null, function (reason) {
            return Q.reject(&#x22;Can&#x27;t find canonical of &#x22; + JSON.stringify(path));
        });
    };

    inner.makeDirectory = function (path) {
        return attenuate(path).then(function (path) {
            return outer.makeDirectory(path.outer);
        }).catch(function (error) {
            throw new Error(&#x22;Can&#x27;t make directory &#x22; + JSON.stringify(path));
        });
    };

    inner.removeDirectory = function (path) {
        return attenuate(path).then(function (path) {
            return outer.removeDirectory(path.outer);
        }).catch(function (error) {
            throw new Error(&#x22;Can&#x27;t remove directory &#x22; + JSON.stringify(path));
        });
    };

    inner.remove = function (path) {
        return attenuate(path).then(function (path) {
            return outer.remove(path.outer);
        }).catch(function (error) {
            throw new Error(&#x22;Can&#x27;t remove &#x22; + JSON.stringify(path));
        });
    };

    inner.makeTree = function (path) {
        return attenuate(path).then(function (path) {
            return outer.makeT ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.html" id="apidoc.module.q-io.html">module q-io.html</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.html.HandleHtmlFragmentResponses" id="apidoc.element.q-io.html.HandleHtmlFragmentResponses">
        function <span class="apidocSignatureSpan">q-io.html.</span>HandleHtmlFragmentResponses
        <span class="apidocSignatureSpan">(app, handleHtmlFragmentResponse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HandleHtmlFragmentResponses = function (app, handleHtmlFragmentResponse) {
    handleHtmlFragmentResponse = handleHtmlFragmentResponse || exports.handleHtmlFragmentResponse;
    return function (request) {
        request.handleHtmlFragmentResponse = handleHtmlFragmentResponse;
        return Q.fcall(app, request)
        .then(function (response) {
            if (response.htmlFragment) {
                return Q.fcall(handleHtmlFragmentResponse, response);
            } else {
                return response;
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.html.escapeHtml" id="apidoc.element.q-io.html.escapeHtml">
        function <span class="apidocSignatureSpan">q-io.html.</span>escapeHtml
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escapeHtml(text) {
    return String(text)
        .replace(/&#x26;/g, &#x22;&#x26;amp;&#x22;)
        .replace(/&#x3c;/g, &#x22;&#x26;lt;&#x22;)
        .replace(/&#x3e;/g, &#x22;&#x26;gt;&#x22;)
        .replace(/&#x22;/g, &#x22;&#x26;quot;&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
headers: {
    location: location,
    &#x22;content-type&#x22;: &#x22;text/html&#x22;
},
htmlTitle: title,
htmlFragment: {
    forEach: function (write) {
        write(&#x22;&#x3c;h1&#x3e;&#x22; + HtmlApps.<span class="apidocCodeKeywordSpan">escapeHtml</span>(title) + &#x22;&#x3c;/
h1&#x3e;\n&#x22;);
        write(
            &#x22;&#x3c;p&#x3e;See: &#x3c;a href=\&#x22;&#x22; + HtmlApps.escapeHtml(location) + &#x22;\&#x22;&#x3e;&#x22; +
            HtmlApps.escapeHtml(location) +
            &#x22;&#x3c;/a&#x3e;&#x3c;/p&#x3e;\n&#x22;
        );
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.html.handleHtmlFragmentResponse" id="apidoc.element.q-io.html.handleHtmlFragmentResponse">
        function <span class="apidocSignatureSpan">q-io.html.</span>handleHtmlFragmentResponse
        <span class="apidocSignatureSpan">(response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleHtmlFragmentResponse = function (response) {
    var htmlFragment = response.htmlFragment;
    delete response.htmlFragment;
    response.headers[&#x22;content-type&#x22;] = &#x22;text/html; charset=utf-8&#x22;;
    response.body = {
        forEach: function (write) {
            write(&#x22;&#x3c;!doctype html&#x3e;\n&#x22;);
            write(&#x22;&#x3c;html&#x3e;\n&#x22;);
            write(&#x22;    &#x3c;head&#x3e;\n&#x22;);
            if (response.htmlTitle !== void 0) {
                write(&#x22;        &#x3c;title&#x3e;&#x22; + escapeHtml(response.htmlTitle) + &#x22;&#x3c;/title&#x3e;\n&#x22;);
            }
            write(&#x22;    &#x3c;/head&#x3e;\n&#x22;);
            write(&#x22;    &#x3c;body&#x3e;\n&#x22;);
            htmlFragment.forEach(function (line) {
                write(&#x22;        &#x22; + line);
            });
            write(&#x22;    &#x3c;/body&#x3e;\n&#x22;);
            write(&#x22;&#x3c;/html&#x3e;\n&#x22;);
        }
    };
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.http" id="apidoc.module.q-io.http">module q-io.http</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.http.ClientResponse" id="apidoc.element.q-io.http.ClientResponse">
        function <span class="apidocSignatureSpan">q-io.http.</span>ClientResponse
        <span class="apidocSignatureSpan">(_response, charset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ClientResponse = function (_response, charset) {
    var response = Object.create(exports.ClientResponse.prototype);
<span class="apidocCodeCommentSpan">    /*** {Number} HTTP status code */
</span>    response.status = _response.statusCode;
    /*** HTTP version */
    response.version = _response.httpVersion;
    /*** {Object} HTTP headers */
    response.headers = _response.headers;
    /***
     * A Q IO asynchronous text reader.
     */
    response.node = _response;
    response.nodeResponse = _response; // Deprecated
    response.nodeConnection = _response.connection; // Deprecated
    return Q.when(Reader(_response, charset), function (body) {
        response.body = body;
        return response;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

if (request.agent !== undefined) {
    requestOptions.agent = request.agent;
}

var _request = http.request(requestOptions, function (_response) {
    deferred.resolve(exports.<span class="apidocCodeKeywordSpan">ClientResponse</span>(_response, request.charset));
    _response.on(&#x22;error&#x22;, function (error) {
        // TODO find a better way to channel
        // this into the response
        console.warn(error &#x26;&#x26; error.stack || error);
        deferred.reject(error);
    });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http.Server" id="apidoc.element.q-io.http.Server">
        function <span class="apidocSignatureSpan">q-io.http.</span>Server
        <span class="apidocSignatureSpan">(respond)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server = function (respond) {
    var self = Object.create(exports.Server.prototype);

    var server = HTTP.createServer(function (_request, _response) {
        var request = exports.ServerRequest(_request);
        var response = exports.ServerResponse(_response);

        var closed = Q.defer();
        _request.on(&#x22;end&#x22;, function (error, value) {
            if (error) {
                closed.reject(error);
            } else {
                closed.resolve(value);
            }
        });

        Q.when(request, function (request) {
            return Q.when(respond(request, response), function (response) {
                if (!response)
                    return;

                _response.writeHead(response.status, response.headers);

                if (response.onclose || response.onClose)
                    Q.when(closed, response.onclose || response.onClose);

                return Q.when(response.body, function (body) {
                    var length;
                    if (
                        Array.isArray(body) &#x26;&#x26;
                        (length = body.length) &#x26;&#x26;
                        body.every(function (chunk) {
                            return typeof chunk === &#x22;string&#x22;
                        })
                    ) {
                        body.forEach(function (chunk, i) {
                            if (i &#x3c; length - 1) {
                                _response.write(chunk, response.charset);
                            } else {
                                _response.end(chunk, response.charset);
                            }
                        });
                    } else if (body) {
                        var end;
                        var done = body.forEach(function (chunk) {
                            end = Q.when(end, function () {
                                return Q.when(chunk, function (chunk) {
                                    _response.write(chunk, response.charset);
                                });
                            });
                        });
                        return Q.when(done, function () {
                            return Q.when(end, function () {
                                _response.end();
                            });
                        });
                    } else {
                        _response.end();
                    }
                });

            })
        })
        .done(); // should be .fail(self.emitter(&#x22;error&#x22;))

    });

    var stopped = Q.defer();
    server.on(&#x22;close&#x22;, function (err) {
        if (err) {
            stopped.reject(err);
        } else {
            stopped.resolve();
        }
    });

<span class="apidocCodeCommentSpan">    /***
     * Stops the server.
     * @returns {Promise * Undefined} a promise that will
     * resolve when the server is stopped.
     */
</span>    self.stop = function () {
        server.close();
        listening = undefined;
        return stopped.promise;
    };

    var listening = Q.defer();
    server.on(&#x22;listening&#x22;, function (err) {
        if (err) {
            listening.reject(err);
        } else {
            listening.resolve(self);
        }
    });

    /***
     * Starts the server, listening on the given port
     * @param {Number} port
     * @returns {Promise * Undefined} a promise that will
     * resolve when the server is ready to receive
     * connections
     */
    self.listen = function (/*...args*/) {
        if (typeof server.port !== &#x22;undefined&#x22;)
            return Q.reject(new Error(&#x22;A server cannot be restarted or &#x22; +
            &#x22;started on a new port&#x22;));
        server.listen.apply(server, arguments);
        return listening.promise;
    };

    self.stopped = stopped.promise;

    self.node = server;
    self.nodeServer = server; // Deprecated
    self.address = server.address.bind(server);

    return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http.ServerRequest" id="apidoc.element.q-io.http.ServerRequest">
        function <span class="apidocSignatureSpan">q-io.http.</span>ServerRequest
        <span class="apidocSignatureSpan">(_request, ssl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ServerRequest = function (_request, ssl) {
    var request = Object.create(_request, requestDescriptor);
<span class="apidocCodeCommentSpan">    /*** {Array} HTTP version. (JSGI) */
</span>    request.version = _request.httpVersion.split(&#x22;.&#x22;).map(Math.floor);
    /*** {String} HTTP method, e.g., `&#x22;GET&#x22;` (JSGI) */
    request.method = _request.method;
    /*** {String} path, starting with `&#x22;/&#x22;` */
    request.path = _request.url;
    /*** {String} pathInfo, starting with `&#x22;/&#x22;`, the
     * portion of the path that has not yet
     * been routed (JSGI) */
    request._pathInfo = null;
    /*** {String} scriptName, the portion of the path that
     * has already been routed (JSGI) */
    request.scriptName = &#x22;&#x22;;
    /*** {String} (JSGI) */
    request.scheme = &#x22;http&#x22;;

    var address = _request.connection.address();
    /*** {String} hostname */
    if (_request.headers.host) {
        request.hostname = _request.headers.host.split(&#x22;:&#x22;)[0];
    } else {
        request.hostname = address.address;
    }
    /*** {String} host */
    request.port = address.port;
    var defaultPort = request.port === (ssl ? 443 : 80);
    request.host = request.hostname + (defaultPort ? &#x22;&#x22; : &#x22;:&#x22; + request.port);

    var socket = _request.socket;
    /*** {String} */
    request.remoteHost = socket.remoteAddress;
    /*** {Number} */
    request.remotePort = socket.remotePort;

    /*** {String} url */
    request.url = URL.format({
        protocol: request.scheme,
        host: _request.headers.host,
        port: request.port === (ssl ? 443 : 80) ? null : request.port,
        path: request.path
    });
    /*** A Q IO asynchronous text reader */
    request.body = Reader(_request);
    /*** {Object} HTTP headers (JSGI)*/
    request.headers = _request.headers;
    /*** The underlying Node request */
    request.node = _request;
    request.nodeRequest = _request; // Deprecated
    /*** The underlying Node TCP connection */
    request.nodeConnection = _request.connection;

    return Q.when(request.body, function (body) {
        request.body = body;
        return request;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * written.
 * @returns a Node Server object.
 */
exports.Server = function (respond) {
    var self = Object.create(exports.Server.prototype);

    var server = HTTP.createServer(function (_request, _response) {
var request = exports.<span class="apidocCodeKeywordSpan">ServerRequest</span>(_request);
var response = exports.ServerResponse(_response);

var closed = Q.defer();
_request.on(&#x22;end&#x22;, function (error, value) {
    if (error) {
        closed.reject(error);
    } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http.ServerResponse" id="apidoc.element.q-io.http.ServerResponse">
        function <span class="apidocSignatureSpan">q-io.http.</span>ServerResponse
        <span class="apidocSignatureSpan">(_response, ssl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ServerResponse = function (_response, ssl) {
    var response = Object.create(_response);
    response.ssl = ssl;
    response.node = _response;
    response.nodeResponse = _response; // Deprecated
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns a Node Server object.
 */
exports.Server = function (respond) {
    var self = Object.create(exports.Server.prototype);

    var server = HTTP.createServer(function (_request, _response) {
var request = exports.ServerRequest(_request);
var response = exports.<span class="apidocCodeKeywordSpan">ServerResponse</span>(_response);

var closed = Q.defer();
_request.on(&#x22;end&#x22;, function (error, value) {
    if (error) {
        closed.reject(error);
    } else {
        closed.resolve(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http.normalizeRequest" id="apidoc.element.q-io.http.normalizeRequest">
        function <span class="apidocSignatureSpan">q-io.http.</span>normalizeRequest
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeRequest = function (request) {
    if (typeof request === &#x22;string&#x22;) {
        request = {url: request};
    }
    request.method = request.method || &#x22;GET&#x22;;
    request.headers = request.headers || {};
    if (request.url) {
        var url = URL.parse(request.url);
        request.ssl = url.protocol === &#x22;https:&#x22;;
        request.hostname = url.hostname;
        request.host = url.host;
        request.port = +url.port;
        request.path = (url.pathname || &#x22;&#x22;) + (url.search || &#x22;&#x22;);
        request.auth = url.auth || void 0;
    }
    request.host = request.host || request.headers.host;
    request.port = request.port || (request.ssl ? 443 : 80);
    if (request.host &#x26;&#x26; !request.hostname) {
        request.hostname = request.host.split(&#x22;:&#x22;)[0];
    }
    if (request.hostname &#x26;&#x26; request.port &#x26;&#x26; !request.host) {
        var defaultPort = request.ssl ? 443 : 80;
        request.host = request.hostname + (defaultPort ? &#x22;&#x22; : &#x22;:&#x22; + request.port);
    }
    request.headers.host = request.headers.host || request.host;
    request.path = request.path || &#x22;/&#x22;;
    return request;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.Client = Client;
function Client(fs) {
var self = Object.create(Client.prototype);

self.request = function (request) {
    return Q.when(request, function (request) {
        request = HTTP.<span class="apidocCodeKeywordSpan">normalizeRequest</span>(request);
        var url = URL.parse(request.url);
        if (url.protocol !== &#x22;file:&#x22;) {
            return {
                status: 404,
                headers: {},
                body: [&#x22;Can&#x27;t access protocol &#x22; + url.protocol]
            };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http.normalizeResponse" id="apidoc.element.q-io.http.normalizeResponse">
        function <span class="apidocSignatureSpan">q-io.http.</span>normalizeResponse
        <span class="apidocSignatureSpan">(response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeResponse = function (response) {
    if (response === void 0) {
        return;
    }
    if (typeof response == &#x22;string&#x22;) {
        response = [response];
    }
    if (response.forEach) {
        response = {
            status: 200,
            headers: {},
            body: response
        }
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var RouteApps = require(&#x22;./route&#x22;);
var StatusApps = require(&#x22;./status&#x22;);

exports.Normalize = function (app) {
return function (request, response) {
    var request = HTTP.normalizeRequest(request);
    return Q.when(app(request, response), function (response) {
        return HTTP.<span class="apidocCodeKeywordSpan">normalizeResponse</span>(response);
    });
};
};

exports.Date = function (app, present) {
present = present || function () {
    return new Date();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http.read" id="apidoc.element.q-io.http.read">
        function <span class="apidocSignatureSpan">q-io.http.</span>read
        <span class="apidocSignatureSpan">(request, qualifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (request, qualifier) {
    qualifier = qualifier || function (response) {
        return response.status === 200;
    };
    return Q.when(exports.request(request), function (response) {
        if (!qualifier(response)){
            var error = new Error(&#x22;HTTP request failed with code &#x22; + response.status);
            error.response = response;
            throw error;
        }
        return Q.post(response.body, &#x27;read&#x27;, []);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
into memory.  It returns a promise for the whole file contents.  By
default, `read` provides a string decoded from UTF-8.  With the bytewise
mode flag, provides a `Buffer`.

The options argument is identical to that of `open`.

```javascript
return FS.<span class="apidocCodeKeywordSpan">read</span>(__filename, &#x22;b&#x22;)
.then(function (content) {
    // ...
})
```

```javascript
return FS.read(__filename, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http.request" id="apidoc.element.q-io.http.request">
        function <span class="apidocSignatureSpan">q-io.http.</span>request
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">request = function (request) {
    return Q.when(request, function (request) {

        request = exports.normalizeRequest(request);

        var deferred = Q.defer();
        var http = request.ssl ? HTTPS : HTTP;

        var requestOptions = {
            hostname: request.hostname,
            port: request.port || (request.ssl ? 443 : 80),
            localAddress: request.localAddress,
            socketPath: request.socketPath,
            method: request.method,
            path: request.path,
            headers: request.headers,
            auth: request.auth // Generates the appropriate header
        };

        if (request.agent !== undefined) {
            requestOptions.agent = request.agent;
        }

        var _request = http.request(requestOptions, function (_response) {
            deferred.resolve(exports.ClientResponse(_response, request.charset));
            _response.on(&#x22;error&#x22;, function (error) {
                // TODO find a better way to channel
                // this into the response
                console.warn(error &#x26;&#x26; error.stack || error);
                deferred.reject(error);
            });
        });

        _request.on(&#x22;error&#x22;, function (error) {
            deferred.reject(error);
        });

        if (request.timeout) {
            _request.setTimeout(request.timeout, function() {
                _request.abort();
            });
        }

        Q.when(request.body, function (body) {
            var end, done;
            if (body) {
                done = body.forEach(function (chunk) {
                    end = Q.when(end, function () {
                        return Q.when(chunk, function (chunk) {
                            _request.write(chunk, request.charset);
                        });
                    });
                });
            }
            return Q.when(end, function () {
                return Q.when(done, function () {
                    _request.end();
                });
            });
        }).done();

        return deferred.promise;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
};

self.read = function (request, qualifier) {
    qualifier = qualifier || function (response) {
        return response.status === 200;
    };
    return Q.when(exports.<span class="apidocCodeKeywordSpan">request</span>(request), function (response) {
        if (!qualifier(response)){
            var error = new Error(&#x22;HTTP request failed with code &#x22; + response.status);
            error.response = response;
            throw error;
        }
        return Q.invoke(response.body, &#x22;read&#x22;);
    });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.http_apps" id="apidoc.module.q-io.http_apps">module q-io.http_apps</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.http_apps.Branch" id="apidoc.element.q-io.http_apps.Branch">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Branch
        <span class="apidocSignatureSpan">(paths, notFound)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Branch = function (paths, notFound) {
    if (!paths)
        paths = {};
    if (!notFound)
        notFound = StatusApps.notFound;
    return function (request, response) {
        if (!/^\//.test(request.pathInfo)) {
            return notFound(request, response);
        }
        var path = request.pathInfo.slice(1);
        var parts = path.split(&#x22;/&#x22;);
        var part = decodeURIComponent(parts.shift());
        if (Object.has(paths, part)) {
            request.scriptName = request.scriptName + part + &#x22;/&#x22;;
            request.pathInfo = path.slice(part.length);
            return Object.get(paths, part)(request, response);
        }
        return notFound(request, response);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Cap" id="apidoc.element.q-io.http_apps.Cap">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Cap
        <span class="apidocSignatureSpan">(app, notFound)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Cap = function (app, notFound) {
    notFound = notFound || StatusApps.notFound;
    return function (request, response) {
        // TODO Distinguish these cases
        if (request.pathInfo === &#x22;&#x22; || request.pathInfo === &#x22;/&#x22;) {
            return app(request, response);
        } else {
            return notFound(request, response);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Chain" id="apidoc.element.q-io.http_apps.Chain">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Chain
        <span class="apidocSignatureSpan">(end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(end) {
    var self = Object.create(Chain.prototype);
    self.end = end || function (next) {
        return next;
    };
    return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Charset" id="apidoc.element.q-io.http_apps.Charset">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Charset
        <span class="apidocSignatureSpan">(types, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Charset = function (types, notAcceptable) {
    var keys = Object.keys(types);
    if (!notAcceptable)
        notAcceptable = Status.notAcceptable;
    return function (request) {
        var accept = request.headers[requestHeader] || &#x22;*&#x22;;
        var type = MimeParse.bestMatch(keys, accept);
        request.terms = request.terms || {};
        request.terms[responseHeader] = type;
        if (Object.has(keys, type)) {
            return Q.when(types[type](request), function (response) {
                if (
                    respond !== null &#x26;&#x26;
                    response &#x26;&#x26;
                    response.status === 200 &#x26;&#x26;
                    response.headers
                ) {
                    response.headers[responseHeader] = type;
                }
                return response;
            });
        } else {
            return notAcceptable(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Content" id="apidoc.element.q-io.http_apps.Content">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Content
        <span class="apidocSignatureSpan">(body, contentType, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Content = function (body, contentType, status) {
    return function () {
        return exports.content(body, contentType, status);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.ContentRequest" id="apidoc.element.q-io.http_apps.ContentRequest">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>ContentRequest
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ContentRequest = function (app) {
    return function (request, response) {
        return Q.when(request.body.read(), function (body) {
            return app(body, request, response);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function(Request, Object):Response} app
 * @param {App} badRequest
 * @returns {App}
 */
exports.JsonRequest = function (app, badRequest) {
if (!badRequest)
    badRequest = Status.badRequest;
return Content.<span class="apidocCodeKeywordSpan">ContentRequest</span>(function (content, request, response) {
    try {
        var object = JSON.parse(content);
    } catch (error) {
        return badRequest(request, error);
    }
    return app(object, request, response);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.ContentType" id="apidoc.element.q-io.http_apps.ContentType">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>ContentType
        <span class="apidocSignatureSpan">(types, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ContentType = function (types, notAcceptable) {
    var keys = Object.keys(types);
    if (!notAcceptable)
        notAcceptable = Status.notAcceptable;
    return function (request) {
        var accept = request.headers[requestHeader] || &#x22;*&#x22;;
        var type = MimeParse.bestMatch(keys, accept);
        request.terms = request.terms || {};
        request.terms[responseHeader] = type;
        if (Object.has(keys, type)) {
            return Q.when(types[type](request), function (response) {
                if (
                    respond !== null &#x26;&#x26;
                    response &#x26;&#x26;
                    response.status === 200 &#x26;&#x26;
                    response.headers
                ) {
                    response.headers[responseHeader] = type;
                }
                return response;
            });
        } else {
            return notAcceptable(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.CookieJar" id="apidoc.element.q-io.http_apps.CookieJar">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>CookieJar
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CookieJar = function (app) {
    var hostCookies = {}; // to {} of pathCookies to [] of cookies
    return function (request) {

        if (!request.headers.host) {
            throw new Error(&#x22;Requests must have a host header&#x22;);
        }
        var hosts = allHostsContaining(request.headers.host);

        var now = new Date();

        // delete expired cookies
        for (var host in hostCookies) {
            var pathCookies = hostCookies[host];
            for (var path in pathCookies) {
                var cookies = pathCookies[path];
                for (var name in cookies) {
                    var cookie = cookies[name];
                    if (cookie.expires &#x26;&#x26; cookie.expires &#x3e; now) {
                        delete cookie[name];
                    }
                }
            }
        }

        // collect applicable cookies
        var requestCookies = concat(
            Object.keys(hostCookies)
            .map(function (host) {
                if (!hostContains(host, request.headers.host)) {
                    return [];
                }
                var pathCookies = hostCookies[host];
                return concat(
                    Object.keys(pathCookies)
                    .map(function (path) {
                        if (!pathContains(path, request.path))
                            return [];
                        var cookies = pathCookies[path];
                        return (
                            Object.keys(cookies)
                            .map(function (name) {
                                return cookies[name];
                            })
                            .filter(function (cookie) {
                                return cookie.secure ?
                                    request.ssl :
                                    true;
                            })
                        );
                    })
                )
            })
        );

        if (requestCookies.length) {
            request.headers[&#x22;cookie&#x22;] = (
                requestCookies
                .map(function (cookie) {
                    return Cookie.stringify(
                        cookie.key,
                        cookie.value
                    );
                })
                .join(&#x22;; &#x22;)
            );
        }

        return Q.when(app.apply(this, arguments), function (response) {
            response.headers = response.headers || {};
            if (response.headers[&#x22;set-cookie&#x22;]) {
                var host = request.headers.host;
                var hostParts = splitHost(host);
                var hostname = hostParts[0];
                var requestHost = ipRe.test(hostname) ? host : &#x22;.&#x22; + host;
                // normalize to array
                if (!Array.isArray(response.headers[&#x22;set-cookie&#x22;])) {
                    response.headers[&#x22;set-cookie&#x22;] = [response.headers[&#x22;set-cookie&#x22;]];
                }
                response.headers[&#x22;set-cookie&#x22;].forEach(function (cookie) {
                    var date = response.headers[&#x22;date&#x22;] ?
                        new Date(response.headers[&#x22;date&#x22;]) :
                        new Date();
                    cookie = Cookie.parse(cookie, date);
                    // ignore illegal host
                    if (cookie.host &#x26;&#x26; !hostContains(requestHost, cookie.host))
                        delete cookie.host;
                    var host = requestHost || cookie.host;
                    var path = cookie.path || &#x22;/&#x22;;
                    var pathCookies = hostCookies[host] = hostCookies[host] || {};
                    var cookies = pathCookies[path] = pathCookies[path] || {};
                    cookies[cookie.key] = cookie;
                })
                delete response.headers[&#x22;set-cookie&#x22;];
            }

            return response;
        });

    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Date" id="apidoc.element.q-io.http_apps.Date">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Date
        <span class="apidocSignatureSpan">(app, present)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Date = function (app, present) {
    present = present || function () {
        return new Date();
    };
    return RouteApps.Trap(app, function (response, request) {
        response.headers[&#x22;date&#x22;] = &#x22;&#x22; + present();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Debug" id="apidoc.element.q-io.http_apps.Debug">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Debug
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Debug = function (app) {
    return exports.Error(app, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Decorators" id="apidoc.element.q-io.http_apps.Decorators">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Decorators
        <span class="apidocSignatureSpan">(decorators, app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Decorators = function (decorators, app) {
    decorators.reversed().forEach(function (Middleware) {
        app = Middleware(app);
    });
    return app;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.DirectoryIndex" id="apidoc.element.q-io.http_apps.DirectoryIndex">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>DirectoryIndex
        <span class="apidocSignatureSpan">(app, indexFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DirectoryIndex = function (app, indexFile) {
    indexFile = indexFile || &#x22;index.html&#x22;;
    return function (request) {
        request.directoryIndex = true;
        request.location = URL.parse(request.path);
        // redirect index.html to containing directory
        // TODO worry about whether this file actually exists
        if (request.location.file === indexFile) {
            return RedirectApps.redirect(request, &#x22;.&#x22;);
        } else {
            return Q.fcall(app, request)
            .then(function (response) {
                if (response.directory !== void 0) {
                    if (request.location.file) {
                        return RedirectApps.redirect(request, request.location.file + &#x22;/&#x22;);
                    } else {
                        var index = request.fs.join(response.directory, indexFile);
                        return Q.invoke(request.fs, &#x22;isFile&#x22;, index)
                        .then(function (isFile) {
                            if (isFile) {
                                request.url = URL.resolve(request.url, indexFile);
                                request.pathInfo += indexFile;
                                return app(request);
                            } else {
                                return response;
                            }
                        });
                    }
                } else {
                    return response;
                }
            });
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Encoding" id="apidoc.element.q-io.http_apps.Encoding">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Encoding
        <span class="apidocSignatureSpan">(types, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Encoding = function (types, notAcceptable) {
    var keys = Object.keys(types);
    if (!notAcceptable)
        notAcceptable = Status.notAcceptable;
    return function (request) {
        var accept = request.headers[requestHeader] || &#x22;*&#x22;;
        var type = MimeParse.bestMatch(keys, accept);
        request.terms = request.terms || {};
        request.terms[responseHeader] = type;
        if (Object.has(keys, type)) {
            return Q.when(types[type](request), function (response) {
                if (
                    respond !== null &#x26;&#x26;
                    response &#x26;&#x26;
                    response.status === 200 &#x26;&#x26;
                    response.headers
                ) {
                    response.headers[responseHeader] = type;
                }
                return response;
            });
        } else {
            return notAcceptable(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Error" id="apidoc.element.q-io.http_apps.Error">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Error
        <span class="apidocSignatureSpan">(app, debug)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error = function (app, debug) {
    return function (request, response) {
        return Q.when(app(request, response), null, function (error) {
            if (!debug)
                error = undefined;
            return StatusApps.responseForStatus(request, 500, error &#x26;&#x26; error.stack || error);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
               error = undefined;
           return StatusApps.responseForStatus(request, 500, error &#x26;&#x26; error.stack || error);
       });
   };
};

exports.Debug = function (app) {
   return exports.<span class="apidocCodeKeywordSpan">Error</span>(app, true);
};

/**
* Decorates a Q-JSGI application such that all requests and responses
* are logged.
*
* @param {App} app
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.File" id="apidoc.element.q-io.http_apps.File">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>File
        <span class="apidocSignatureSpan">(path, contentType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">File = function (path, contentType) {
    return function (request, response) {
        return exports.file(request, String(path), contentType);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.FileTree" id="apidoc.element.q-io.http_apps.FileTree">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>FileTree
        <span class="apidocSignatureSpan">(root, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FileTree = function (root, options) {
    if (!options)
        options = {};
    options.notFound = options.notFound || StatusApps.notFound;
    options.file = options.file || exports.file;
    options.directory = options.directory || exports.directory;
    options.fs = options.fs || FS;
    var fs = options.fs;
    root = fs.canonical(root);
    return function (request, response) {
        var location = URL.parse(request.url);
        request.fs = fs;
        var redirect = options.redirect || (
            request.permanent || options.permanent ?
            RedirectApps.permanentRedirect :
            RedirectApps.temporaryRedirect
        );
        return Q.when(root, function (root) {
            var path = fs.join(root, request.pathInfo.slice(1));
            return Q.when(fs.canonical(path), function (canonical) {
                //TODO remove for 2.0.0
                if (options.followInsecureSymlinks) {
                    Deprecate.deprecationWarning(&#x22;followInsecureSymlinks&#x22;, &#x22;followInsecureSymbolicLinks&#x22;);
                    options.followInsecureSymbolicLinks = true;
                }
                if (!fs.contains(root, canonical) &#x26;&#x26; !options.followInsecureSymbolicLinks)
                    return options.notFound(request, response);
                if (path !== canonical &#x26;&#x26; options.redirectSymbolicLinks)
                    return redirect(request, fs.relativeFromFile(path, canonical));
                // TODO: relativeFromFile should be designed for URL’s, not generalized paths.
                // HTTP.relative(pathToDirectoryLocation(path), pathToFile/DirectoryLocation(canonical))
                return Q.when(fs.stat(canonical), function (stat) {
                    if (stat.isFile()) {
                        return options.file(request, canonical, options.contentType, fs);
                    } else if (stat.isDirectory()) {
                        return options.directory(request, canonical, options.contentType, fs);
                    } else {
                        return options.notFound(request, response);
                    }
                });
            }, function (reason) {
                return options.notFound(request, response);
            });
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.HandleHtmlFragmentResponses" id="apidoc.element.q-io.http_apps.HandleHtmlFragmentResponses">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>HandleHtmlFragmentResponses
        <span class="apidocSignatureSpan">(app, handleHtmlFragmentResponse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HandleHtmlFragmentResponses = function (app, handleHtmlFragmentResponse) {
    handleHtmlFragmentResponse = handleHtmlFragmentResponse || exports.handleHtmlFragmentResponse;
    return function (request) {
        request.handleHtmlFragmentResponse = handleHtmlFragmentResponse;
        return Q.fcall(app, request)
        .then(function (response) {
            if (response.htmlFragment) {
                return Q.fcall(handleHtmlFragmentResponse, response);
            } else {
                return response;
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.HandleJsonResponses" id="apidoc.element.q-io.http_apps.HandleJsonResponses">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>HandleJsonResponses
        <span class="apidocSignatureSpan">(app, reviver, tab)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HandleJsonResponses = function (app, reviver, tab) {
    return function (request) {
        request.handleJsonResponse = exports.handleJsonResponse;
        return Q.fcall(app, request)
        .then(function (response) {
            if (response.data !== void 0) {
                return Q.fcall(exports.handleJsonResponse, response, reviver, tab);
            } else {
                return response;
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Headers" id="apidoc.element.q-io.http_apps.Headers">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Headers
        <span class="apidocSignatureSpan">(app, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Headers = function (app, headers) {
    return function (request, response) {
        return Q.when(app(request, response), function (response) {
            if (response &#x26;&#x26; response.headers) {
                Object.keys(headers).forEach(function (key) {
                    if (!(key in response.headers)) {
                        response.headers[key] = headers[key];
                    }
                });
            }
            return response;
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Host" id="apidoc.element.q-io.http_apps.Host">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Host
        <span class="apidocSignatureSpan">(appForHost, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Host = function (appForHost, notAcceptable) {
    var table = Object.keys(appForHost).map(function (pattern) {
        var parts = pattern.split(&#x22;:&#x22;);
        return [
            pattern,
            parts[0] || &#x22;*&#x22;,
            parts[1] || &#x22;*&#x22;,
            appForHost[pattern]
        ];
    });
    if (!notAcceptable) {
        notAcceptable = Status.notAcceptable;
    }
    return function (request) {
        // find first matching host for app
        for (var index = 0; index &#x3c; table.length; index++) {
            var row = table[index]; // [hostname, port, app]
            var pattern = row[0];
            var hostname = row[1];
            var port = row[2];
            var app = row[3];
            if (
                (hostname === &#x22;*&#x22; || hostname === request.hostname) &#x26;&#x26;
                (port === &#x22;*&#x22; || port === &#x22;&#x22; + request.port)
            ) {
                request.terms = request.terms || {};
                request.terms.host = pattern;
                return app(request);
            }
        }
        return notAcceptable(request);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Inspect" id="apidoc.element.q-io.http_apps.Inspect">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Inspect
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Inspect = function (app) {
    return Negotiate.Method({&#x22;GET&#x22;: function (request, response) {
        return Q.when(app(request, response), function (object) {
            return {
                status: 200,
                headers: {
                    &#x22;content-type&#x22;: &#x22;text/plain&#x22;
                },
                body: [inspect(object)]
            }
        });
    }});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Json" id="apidoc.element.q-io.http_apps.Json">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Json
        <span class="apidocSignatureSpan">(app, reviver, tabs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Json = function (app, reviver, tabs) {
    return function (request, response) {
        return Q.when(app(request, response), function (object) {
            return exports.json(object, reviver, tabs);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.JsonRequest" id="apidoc.element.q-io.http_apps.JsonRequest">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>JsonRequest
        <span class="apidocSignatureSpan">(app, badRequest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JsonRequest = function (app, badRequest) {
    if (!badRequest)
        badRequest = Status.badRequest;
    return Content.ContentRequest(function (content, request, response) {
        try {
            var object = JSON.parse(content);
        } catch (error) {
            return badRequest(request, error);
        }
        return app(object, request, response);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Language" id="apidoc.element.q-io.http_apps.Language">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Language
        <span class="apidocSignatureSpan">(types, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Language = function (types, notAcceptable) {
    var keys = Object.keys(types);
    if (!notAcceptable)
        notAcceptable = Status.notAcceptable;
    return function (request) {
        var accept = request.headers[requestHeader] || &#x22;*&#x22;;
        var type = MimeParse.bestMatch(keys, accept);
        request.terms = request.terms || {};
        request.terms[responseHeader] = type;
        if (Object.has(keys, type)) {
            return Q.when(types[type](request), function (response) {
                if (
                    respond !== null &#x26;&#x26;
                    response &#x26;&#x26;
                    response.status === 200 &#x26;&#x26;
                    response.headers
                ) {
                    response.headers[responseHeader] = type;
                }
                return response;
            });
        } else {
            return notAcceptable(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.ListDirectories" id="apidoc.element.q-io.http_apps.ListDirectories">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>ListDirectories
        <span class="apidocSignatureSpan">(app, listDirectory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ListDirectories = function (app, listDirectory) {
    listDirectory = listDirectory || exports.listDirectory;
    return function (request) {
        if (request.directoryIndex) {
            throw new Error(&#x22;DirectoryIndex must be used after ListDirectories&#x22;);
        }
        request.listDirectories = true;
        return Q.fcall(app, request)
        .then(function (response) {
            if (response.directory !== void 0) {
                return listDirectory(request, response);
            } else {
                return response;
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Log" id="apidoc.element.q-io.http_apps.Log">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Log
        <span class="apidocSignatureSpan">(app, log, stamp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Log = function (app, log, stamp) {
    log = log || console.log;
    stamp = stamp || function (message) {
        return new Date().toISOString() + &#x22; &#x22; + message;
    };
    return function (request, response) {
        var remoteHost =
            request.remoteHost + &#x22;:&#x22; +
            request.remotePort;
        var requestLine =
            request.method + &#x22; &#x22; +
            request.path + &#x22; &#x22; +
            &#x22;HTTP/&#x22; + request.version.join(&#x22;.&#x22;);
        log(stamp(
            remoteHost + &#x22; &#x22; +
            &#x22;--&#x3e;     &#x22; +
            requestLine
        ));
        return Q.when(app(request, response), function (response) {
            if (response) {
                log(stamp(
                    remoteHost + &#x22; &#x22; +
                    &#x22;&#x3c;== &#x22; +
                    response.status + &#x22; &#x22; +
                    requestLine + &#x22; &#x22; +
                    (response.headers[&#x22;content-length&#x22;] || &#x22;-&#x22;)
                ));
            } else {
                log(stamp(
                    remoteHost + &#x22; &#x22; +
                    &#x22;... &#x22; +
                    &#x22;... &#x22; +
                    requestLine + &#x22; (response undefined / presumed streaming)&#x22;
                ));
            }
            return response;
        }, function (reason) {
            log(stamp(
                remoteHost + &#x22; &#x22; +
                &#x22;!!!     &#x22; +
                requestLine + &#x22; &#x22; +
                (reason &#x26;&#x26; reason.message || reason)
            ));
            return Q.reject(reason);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Method" id="apidoc.element.q-io.http_apps.Method">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Method
        <span class="apidocSignatureSpan">(methods, methodNotAllowed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Method = function (methods, methodNotAllowed) {
    var keys = Object.keys(methods);
    if (!methodNotAllowed)
        methodNotAllowed = Status.methodNotAllowed;
    return function (request) {
        var method = request.method;
        if (Object.has(keys, method)) {
            return Object.get(methods, method)(request);
        } else {
            return methodNotAllowed(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * @param {Function(Request):Object}
 * @returns {App}
 */
exports.Inspect = function (app) {
return Negotiate.<span class="apidocCodeKeywordSpan">Method</span>({&#x22;GET&#x22;: function (request, response) {
    return Q.when(app(request, response), function (object) {
        return {
            status: 200,
            headers: {
                &#x22;content-type&#x22;: &#x22;text/plain&#x22;
            },
            body: [inspect(object)]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Normalize" id="apidoc.element.q-io.http_apps.Normalize">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Normalize
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Normalize = function (app) {
    return function (request, response) {
        var request = HTTP.normalizeRequest(request);
        return Q.when(app(request, response), function (response) {
            return HTTP.normalizeResponse(response);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.ParseQuery" id="apidoc.element.q-io.http_apps.ParseQuery">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>ParseQuery
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ParseQuery = function (app) {
    return function (request, response) {
        request.query = QS.parse(URL.parse(request.url).query || &#x22;&#x22;);
        return app(request, response);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Permanent" id="apidoc.element.q-io.http_apps.Permanent">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Permanent
        <span class="apidocSignatureSpan">(app, future)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Permanent = function (app, future) {
    future = future || function () {
        return new Date(new Date().getTime() + farFuture);
    };
    app = RouteApps.Tap(app, function (request, response) {
        request.permanent = future;
    });
    app = RouteApps.Trap(app, function (response, request) {
        response.headers[&#x22;expires&#x22;] = &#x22;&#x22; + future();
    });
    return app;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.PermanentRedirect" id="apidoc.element.q-io.http_apps.PermanentRedirect">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>PermanentRedirect
        <span class="apidocSignatureSpan">(location, status, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PermanentRedirect = function (location, status, tree) {
    return function (request, response) {
        return exports.permanentRedirect(request, location, status, tree);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.PermanentRedirectTree" id="apidoc.element.q-io.http_apps.PermanentRedirectTree">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>PermanentRedirectTree
        <span class="apidocSignatureSpan">(location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PermanentRedirectTree = function (location, status) {
    return function (request, response) {
        return exports.permanentRedirect(request, location, status, true);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Proxy" id="apidoc.element.q-io.http_apps.Proxy">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Proxy
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Proxy = function (app) {
    if (typeof app === &#x22;string&#x22;) {
        var location = app;
        app = function (request) {
            request.url = location;
            return request;
        };
    }
    return function (request, response) {
        return Q.when(app.apply(this, arguments), function (request) {
            return HTTP.request(request);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return Q.when(app.apply(this, arguments), function (request) {
            return HTTP.request(request);
        });
    };
};

exports.ProxyTree = function (url) {
    return exports.<span class="apidocCodeKeywordSpan">Proxy</span>(function (request) {
        request.url = URL.resolve(url, request.pathInfo.replace(/^\//, &#x22;&#x22;));
        return request;
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.ProxyTree" id="apidoc.element.q-io.http_apps.ProxyTree">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>ProxyTree
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ProxyTree = function (url) {
    return exports.Proxy(function (request) {
        request.url = URL.resolve(url, request.pathInfo.replace(/^\//, &#x22;&#x22;));
        return request;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Redirect" id="apidoc.element.q-io.http_apps.Redirect">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Redirect
        <span class="apidocSignatureSpan">(location, status, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Redirect = function (location, status, tree) {
    return function (request, response) {
        return exports.redirect(request, location, status, tree);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.RedirectTrap" id="apidoc.element.q-io.http_apps.RedirectTrap">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>RedirectTrap
        <span class="apidocSignatureSpan">(app, maxRedirects)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RedirectTrap = function (app, maxRedirects) {
    maxRedirects = maxRedirects || 20;
    return function (request, response) {
        var remaining = maxRedirects;
        var deferred = Q.defer();
        var self = this;
        var args = arguments;

        request = Http.normalizeRequest(request);

        // try redirect loop
        function next() {
            Q.fcall(function () {
                return app(request, response);
            })
            .then(function (response) {
                if (exports.isRedirect(response)) {
                    if (remaining--) {
                        request.url = response.headers.location;
                        next();
                    } else {
                        throw new Error(&#x22;Maximum redirects.&#x22;);
                    }
                } else {
                    deferred.resolve(response);
                }
            })
            .fail(deferred.reject)
        }
        next();

        return deferred.promise;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.RedirectTree" id="apidoc.element.q-io.http_apps.RedirectTree">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>RedirectTree
        <span class="apidocSignatureSpan">(location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RedirectTree = function (location, status) {
    return function (request, response) {
        return exports.redirect(request, location, status, true);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Select" id="apidoc.element.q-io.http_apps.Select">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Select
        <span class="apidocSignatureSpan">(select)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Select = function (select) {
    return function (request) {
        return Q.when(select(request), function (app) {
            return app(request);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Tap" id="apidoc.element.q-io.http_apps.Tap">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Tap
        <span class="apidocSignatureSpan">(app, tap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Tap = function (app, tap) {
    return function (request, response) {
        var self = this, args = arguments;
        return Q.when(tap.apply(this, arguments), function (response) {
            if (response) {
                return response;
            } else {
                return app.apply(self, args);
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    24 * // h
    365 * // d
    10; // years
exports.Permanent = function (app, future) {
    future = future || function () {
        return new Date(new Date().getTime() + farFuture);
    };
    app = RouteApps.<span class="apidocCodeKeywordSpan">Tap</span>(app, function (request, response) {
        request.permanent = future;
    });
    app = RouteApps.Trap(app, function (response, request) {
        response.headers[&#x22;expires&#x22;] = &#x22;&#x22; + future();
    });
    return app;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.TemporaryRedirect" id="apidoc.element.q-io.http_apps.TemporaryRedirect">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>TemporaryRedirect
        <span class="apidocSignatureSpan">(location, status, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TemporaryRedirect = function (location, status, tree) {
    return function (request, response) {
        return exports.temporaryRedirect(request, location, status, tree);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.TemporaryRedirectTree" id="apidoc.element.q-io.http_apps.TemporaryRedirectTree">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>TemporaryRedirectTree
        <span class="apidocSignatureSpan">(location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TemporaryRedirectTree = function (location, status) {
    return function (request, response) {
        return exports.temporaryRedirect(request, location, status, true);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Time" id="apidoc.element.q-io.http_apps.Time">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Time
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Time = function (app) {
    return function (request, response) {
        var start = new Date();
        return Q.when(app(request, response), function (response) {
            var stop = new Date();
            if (response &#x26;&#x26; response.headers) {
                response.headers[&#x22;x-response-time&#x22;] = &#x22;&#x22; + (stop - start);
            }
            return response;
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Trap" id="apidoc.element.q-io.http_apps.Trap">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Trap
        <span class="apidocSignatureSpan">(app, trap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Trap = function (app, trap) {
    return function (request, response) {
        return Q.when(app.apply(this, arguments), function (response) {
            if (response) {
                response.headers = response.headers || {};
                return trap(response, request) || response;
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   };
};

exports.Date = function (app, present) {
   present = present || function () {
       return new Date();
   };
   return RouteApps.<span class="apidocCodeKeywordSpan">Trap</span>(app, function (response, request) {
       response.headers[&#x22;date&#x22;] = &#x22;&#x22; + present();
   });
};

/**
* Decorates a JSGI application such that rejected response promises
* get translated into `500` server error responses with no content.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.appForStatus" id="apidoc.element.q-io.http_apps.appForStatus">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>appForStatus
        <span class="apidocSignatureSpan">(status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appForStatus = function (status) {
    return function (request) {
        return exports.responseForStatus(request, status, request.method + &#x22; &#x22; + request.path);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       }
   }
};

/**
* {App} an application that returns a 400 response.
*/
exports.badRequest = exports.<span class="apidocCodeKeywordSpan">appForStatus</span>(400);
/**
* {App} an application that returns a 404 response.
*/
exports.notFound = exports.appForStatus(404);
/**
* {App} an application that returns a 405 response.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.badRequest" id="apidoc.element.q-io.http_apps.badRequest">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>badRequest
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">badRequest = function (request) {
    return exports.responseForStatus(request, status, request.method + &#x22; &#x22; + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.content" id="apidoc.element.q-io.http_apps.content">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>content
        <span class="apidocSignatureSpan">(content, contentType, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">content = function (content, contentType, status) {
    status = status || 200;
    content = content || &#x22;&#x22;;
    if (typeof content === &#x22;string&#x22;) {
        content = [content];
    }
    contentType = contentType || &#x22;text/plain&#x22;;
    return {
        &#x22;status&#x22;: status,
        &#x22;headers&#x22;: {
            &#x22;content-type&#x22;: contentType
        },
        &#x22;body&#x22;: content
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* response body
* @param {String} contentType
* @param {Number} status
* @returns {App} a Q-JSGI app
*/
exports.Content = function (body, contentType, status) {
   return function () {
       return exports.<span class="apidocCodeKeywordSpan">content</span>(body, contentType, status);
   };
};

/**
* Returns a Q-JSGI response with the given content.
* @param {Body} content (optional) defaults to `[&#x22;&#x22;]`
* @param {String} contentType (optional) defaults to `&#x22;text/plain&#x22;`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.directory" id="apidoc.element.q-io.http_apps.directory">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>directory
        <span class="apidocSignatureSpan">(request, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directory = function (request, path) {
    var response = StatusApps.notFound(request);
    response.directory = path;
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.escapeHtml" id="apidoc.element.q-io.http_apps.escapeHtml">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>escapeHtml
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escapeHtml(text) {
    return String(text)
        .replace(/&#x26;/g, &#x22;&#x26;amp;&#x22;)
        .replace(/&#x3c;/g, &#x22;&#x26;lt;&#x22;)
        .replace(/&#x3e;/g, &#x22;&#x26;gt;&#x22;)
        .replace(/&#x22;/g, &#x22;&#x26;quot;&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
headers: {
    location: location,
    &#x22;content-type&#x22;: &#x22;text/html&#x22;
},
htmlTitle: title,
htmlFragment: {
    forEach: function (write) {
        write(&#x22;&#x3c;h1&#x3e;&#x22; + HtmlApps.<span class="apidocCodeKeywordSpan">escapeHtml</span>(title) + &#x22;&#x3c;/
h1&#x3e;\n&#x22;);
        write(
            &#x22;&#x3c;p&#x3e;See: &#x3c;a href=\&#x22;&#x22; + HtmlApps.escapeHtml(location) + &#x22;\&#x22;&#x3e;&#x22; +
            HtmlApps.escapeHtml(location) +
            &#x22;&#x3c;/a&#x3e;&#x3c;/p&#x3e;\n&#x22;
        );
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.etag" id="apidoc.element.q-io.http_apps.etag">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>etag
        <span class="apidocSignatureSpan">(stat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">etag = function (stat) {
    return [
        stat.node.ino,
        stat.size,
        stat.lastModified().getTime()
    ].join(&#x22;-&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.file" id="apidoc.element.q-io.http_apps.file">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>file
        <span class="apidocSignatureSpan">(request, path, contentType, fs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file = function (request, path, contentType, fs) {
    fs = fs || FS;
    // TODO last-modified header
    contentType = contentType || MimeTypes.lookup(path);
    return Q.when(fs.stat(path), function (stat) {
        var etag = exports.etag(stat);
        var options = {
            flags: &#x22;rb&#x22;
        };
        var range;
        var status = 200;
        var headers = {
            &#x22;content-type&#x22;: contentType,
            etag: etag
        };

        // Partial range requests
        if (&#x22;range&#x22; in request.headers) {
            // Invalid cache
            if (
                &#x22;if-range&#x22; in request.headers &#x26;&#x26;
                etag != request.headers[&#x22;if-range&#x22;]
            ) {
                // Normal 200 for entire, altered content
            } else {
                // Truncate to the first requested continuous range
                range = interpretFirstRange(request.headers[&#x22;range&#x22;], stat.size);
                // Like Apache, ignore the range header if it is invalid
                if (range) {
                    if (range.end &#x3e; stat.size) {
                        range.end = stat.size;
                    }
                    if (range.end &#x3c;= range.begin) {
                        return StatusApps.responseForStatus(request, 416); // not satisfiable
                    }
                    status = 206; // partial content
                    headers[&#x22;content-range&#x22;] = (
                        &#x22;bytes &#x22; +
                        range.begin + &#x22;-&#x22; + (range.end - 1) +
                        &#x22;/&#x22; + stat.size
                    );
                    headers[&#x22;content-length&#x22;] = &#x22;&#x22; + (range.end - range.begin);
                    options.begin = range.begin;
                    options.end = range.end;
                } else {
                    return StatusApps.responseForStatus(request, 416); // not satisfiable
                }
            }
        // Full requests
        } else {
            // Cached
            // We do not use date-based caching
            // TODO consider if-match?
            if (etag == request.headers[&#x22;if-none-match&#x22;])
                return StatusApps.responseForStatus(request, 304);
            headers[&#x22;content-length&#x22;] = &#x22;&#x22; + stat.size;
        }

        // TODO sendfile
        return {
            status: status,
            headers: headers,
            body: fs.open(path, options),
            file: path,
            range: range
        };
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.handleHtmlFragmentResponse" id="apidoc.element.q-io.http_apps.handleHtmlFragmentResponse">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>handleHtmlFragmentResponse
        <span class="apidocSignatureSpan">(response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleHtmlFragmentResponse = function (response) {
    var htmlFragment = response.htmlFragment;
    delete response.htmlFragment;
    response.headers[&#x22;content-type&#x22;] = &#x22;text/html; charset=utf-8&#x22;;
    response.body = {
        forEach: function (write) {
            write(&#x22;&#x3c;!doctype html&#x3e;\n&#x22;);
            write(&#x22;&#x3c;html&#x3e;\n&#x22;);
            write(&#x22;    &#x3c;head&#x3e;\n&#x22;);
            if (response.htmlTitle !== void 0) {
                write(&#x22;        &#x3c;title&#x3e;&#x22; + escapeHtml(response.htmlTitle) + &#x22;&#x3c;/title&#x3e;\n&#x22;);
            }
            write(&#x22;    &#x3c;/head&#x3e;\n&#x22;);
            write(&#x22;    &#x3c;body&#x3e;\n&#x22;);
            htmlFragment.forEach(function (line) {
                write(&#x22;        &#x22; + line);
            });
            write(&#x22;    &#x3c;/body&#x3e;\n&#x22;);
            write(&#x22;&#x3c;/html&#x3e;\n&#x22;);
        }
    };
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.handleJsonResponse" id="apidoc.element.q-io.http_apps.handleJsonResponse">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>handleJsonResponse
        <span class="apidocSignatureSpan">(response, revivier, tab)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleJsonResponse = function (response, revivier, tab) {
    response.headers[&#x22;content-type&#x22;] = &#x22;application/json&#x22;;
    response.body = {
        forEach: function (write) {
            write(JSON.stringify(response.data, revivier, tab));
        }
    };
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.htmlResponseForStatus" id="apidoc.element.q-io.http_apps.htmlResponseForStatus">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>htmlResponseForStatus
        <span class="apidocSignatureSpan">(request, status, message, addendum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">htmlResponseForStatus = function (request, status, message, addendum) {
    return {
        status: status,
        statusMessage: message,
        headers: {},
        htmlTitle: message,
        htmlFragment: {
            forEach: function (write) {
                write(&#x22;&#x3c;h1&#x3e;&#x22; + HtmlApps.escapeHtml(message) + &#x22;&#x3c;/h1&#x3e;\n&#x22;);
                write(&#x22;&#x3c;p&#x3e;Status: &#x22; + status + &#x22;&#x3c;/p&#x3e;\n&#x22;);
                if (addendum) {
                    write(&#x22;&#x3c;pre&#x3e;&#x22; + HtmlApps.escapeHtml(addendum) + &#x22;&#x3c;/pre&#x3e;\n&#x22;);
                }
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.isRedirect" id="apidoc.element.q-io.http_apps.isRedirect">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>isRedirect
        <span class="apidocSignatureSpan">(response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRedirect = function (response) {
    return isRedirect[response.status] || false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// try redirect loop
function next() {
    Q.fcall(function () {
        return app(request, response);
    })
    .then(function (response) {
        if (exports.<span class="apidocCodeKeywordSpan">isRedirect</span>(response)) {
            if (remaining--) {
                request.url = response.headers.location;
                next();
            } else {
                throw new Error(&#x22;Maximum redirects.&#x22;);
            }
        } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.json" id="apidoc.element.q-io.http_apps.json">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>json
        <span class="apidocSignatureSpan">(content, reviver, tabs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json = function (content, reviver, tabs) {
    try {
        var json = JSON.stringify(content, reviver, tabs);
    } catch (exception) {
        return Q.reject(exception);
    }
    return Content.ok([json], &#x22;application/json&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function(Request):Object} app an application that accepts a
* request and returns a JSON serializable object.
* @returns {App}
*/
exports.Json = function (app, reviver, tabs) {
   return function (request, response) {
       return Q.when(app(request, response), function (object) {
           return exports.<span class="apidocCodeKeywordSpan">json</span>(object, reviver, tabs);
       });
   };
};

/**
* @param {Object} content data to serialize as JSON
* @param {Function} reviver
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.listDirectory" id="apidoc.element.q-io.http_apps.listDirectory">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectory
        <span class="apidocSignatureSpan">(request, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listDirectory = function (request, response) {
    // TODO advisory to have JSON or HTML fragment handler.
    request.location = URL.parse(request.path);
    if (request.location.file) {
        return RedirectApps.redirect(request, request.location.file + &#x22;/&#x22;);
    }
    var handlers = {};
    handlers[&#x22;text/plain&#x22;] = exports.listDirectoryText;
    handlers[&#x22;text/markdown&#x22;] = exports.listDirectoryMarkdown;
    if (request.handleHtmlFragmentResponse) {
        handlers[&#x22;text/html&#x22;] = exports.listDirectoryHtmlFragment;
    }
    if (request.handleJsonResponse) {
        handlers[&#x22;application/json&#x22;] = exports.listDirectoryJson;
    }
    var handleResponse = Negotiation.negotiate(request, handlers) || function () {
        return response;
    };
    return handleResponse(request, response);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.listDirectoryData" id="apidoc.element.q-io.http_apps.listDirectoryData">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryData
        <span class="apidocSignatureSpan">(request, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listDirectoryData = function (request, response) {
    if (!request.fs) {
        throw new Error(&#x22;Can&#x27;t list a directory without a designated file system&#x22;);
    }
    var fs = request.fs;
    return Q.invoke(fs, &#x22;list&#x22;, response.directory)
    .then(function (list) {
        list.sort();
        return list.map(function (name) {
            return Q.invoke(fs, &#x22;stat&#x22;, fs.join(response.directory, name))
            .then(function (stat) {
                if (stat.isDirectory()) {
                    return {name: name, stat: {
                        type: &#x22;directory&#x22;
                    }};
                } else if (stat.isFile()) {
                    return {name: name, stat: {
                        type: &#x22;file&#x22;
                    }};
                }
            }, function () {
                // ignore unstatable entries
            });
        })
    })
    .all()
    .then(function (stats) {
        var data = {};
        stats.forEach(function (entry) {
            if (entry) {
                data[entry.name] = entry.stat;
            }
        });
        return data;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.listDirectoryHtmlFragment" id="apidoc.element.q-io.http_apps.listDirectoryHtmlFragment">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryHtmlFragment
        <span class="apidocSignatureSpan">(request, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listDirectoryHtmlFragment = function (request, response) {
    return exports.listDirectoryData(request, response)
    .then(function (data) {
        return {
            status: 200,
            headers: {
                &#x22;content-type&#x22;: &#x22;text/html&#x22;
            },
            htmlTitle: &#x22;Directory Index&#x22;,
            htmlFragment: {
                forEach: function (write) {
                    write(&#x22;&#x3c;ul class=\&#x22;directory-index\&#x22;&#x3e;\n&#x22;);
                    Object.keys(data).sort().forEach(function (name) {
                        var stat = data[name];
                        var suffix = &#x22;&#x22;;
                        if (stat.type === &#x22;directory&#x22;) {
                            suffix = &#x22;/&#x22;;
                        }
                        write(&#x22;    &#x3c;li class=\&#x22;entry &#x22; + stat.type + &#x22;\&#x22;&#x3e;&#x3c;a href=\&#x22;&#x22; + HtmlApps.escapeHtml(name + suffix) + &#x22;\&#x22;&#x3e;&#x22; +
HtmlApps.escapeHtml(name + suffix) + &#x22;&#x3c;/a&#x3e;&#x3c;/li&#x3e;\n&#x22;);
                    });
                    write(&#x22;&#x3c;/ul&#x3e;\n&#x22;);
                }
            }
        };
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.listDirectoryJson" id="apidoc.element.q-io.http_apps.listDirectoryJson">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryJson
        <span class="apidocSignatureSpan">(request, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listDirectoryJson = function (request, response) {
    return exports.listDirectoryData(request, response)
    .then(function (data) {
        return {
            status: 200,
            headers: {},
            data: data
        };
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.listDirectoryMarkdown" id="apidoc.element.q-io.http_apps.listDirectoryMarkdown">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryMarkdown
        <span class="apidocSignatureSpan">(request, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listDirectoryMarkdown = function (request, response) {
    return exports.listDirectoryData(request, response)
    .then(function (data) {
        return {
            status: 200,
            headers: {
                &#x22;content-type&#x22;: &#x22;text/plain&#x22;
            },
            body: {
                forEach: function (write) {
                    write(&#x22;\n# Directory Index\n\n&#x22;);
                    Object.keys(data).forEach(function (name) {
                        var stat = data[name];
                        var suffix = &#x22;&#x22;;
                        if (stat.type === &#x22;directory&#x22;) {
                            suffix = &#x22;/&#x22;;
                        }
                        write(&#x22;-   &#x22; + name + suffix + &#x22;\n&#x22;);
                    });
                    write(&#x22;\n&#x22;);
                }
            }
        };
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.listDirectoryText" id="apidoc.element.q-io.http_apps.listDirectoryText">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryText
        <span class="apidocSignatureSpan">(request, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listDirectoryText = function (request, response) {
    return exports.listDirectoryData(request, response)
    .then(function (data) {
        return {
            status: 200,
            headers: {
                &#x22;content-type&#x22;: &#x22;text/plain&#x22;
            },
            body: {
                forEach: function (write) {
                    Object.keys(data).sort().forEach(function (name) {
                        var stat = data[name];
                        var suffix = &#x22;&#x22;;
                        if (stat.type === &#x22;directory&#x22;) {
                            suffix = &#x22;/&#x22;;
                        }
                        write(name + suffix + &#x22;\n&#x22;);
                    });
                }
            }
        };
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.methodNotAllowed" id="apidoc.element.q-io.http_apps.methodNotAllowed">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>methodNotAllowed
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">methodNotAllowed = function (request) {
    return exports.responseForStatus(request, status, request.method + &#x22; &#x22; + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.negotiate" id="apidoc.element.q-io.http_apps.negotiate">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>negotiate
        <span class="apidocSignatureSpan">(request, types, header)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function negotiate(request, types, header) {
    var keys = Object.keys(types);
    var accept = request.headers[header || &#x22;accept&#x22;] || &#x22;*&#x22;;
    var best = MimeParse.bestMatch(keys, accept);
    return types[best];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var handlers = {};
handlers[&#x22;text/plain&#x22;] = exports.redirectText;
if (request.handleHtmlFragmentResponse) {
    handlers[&#x22;text/html&#x22;] = exports.redirectHtml;
}
var handler = Negotiation.<span class="apidocCodeKeywordSpan">negotiate</span>(request, handlers) || exports.redirectText;
return handler(request, location, status);

};

exports.redirectText = function (request, location, status) {
var content = (
    (request.permanent ? &#x22;Permanent redirect\n&#x22; : &#x22;Temporary redirect\n&#x22;) +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.noLanguage" id="apidoc.element.q-io.http_apps.noLanguage">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>noLanguage
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noLanguage = function (request) {
    return exports.responseForStatus(request, status, request.method + &#x22; &#x22; + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.notAcceptable" id="apidoc.element.q-io.http_apps.notAcceptable">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>notAcceptable
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notAcceptable = function (request) {
    return exports.responseForStatus(request, status, request.method + &#x22; &#x22; + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.notFound" id="apidoc.element.q-io.http_apps.notFound">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>notFound
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notFound = function (request) {
    return exports.responseForStatus(request, status, request.method + &#x22; &#x22; + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.ok" id="apidoc.element.q-io.http_apps.ok">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>ok
        <span class="apidocSignatureSpan">(content, contentType, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ok = function (content, contentType, status) {
    status = status || 200;
    content = content || &#x22;&#x22;;
    if (typeof content === &#x22;string&#x22;) {
        content = [content];
    }
    contentType = contentType || &#x22;text/plain&#x22;;
    return {
        &#x22;status&#x22;: status,
        &#x22;headers&#x22;: {
            &#x22;content-type&#x22;: contentType
        },
        &#x22;body&#x22;: content
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
exports.json = function (content, reviver, tabs) {
   try {
       var json = JSON.stringify(content, reviver, tabs);
   } catch (exception) {
       return Q.reject(exception);
   }
   return Content.<span class="apidocCodeKeywordSpan">ok</span>([json], &#x22;application/json&#x22;);
};

/**
* @param {Function(Request, Object):Response} app
* @param {App} badRequest
* @returns {App}
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.permanentRedirect" id="apidoc.element.q-io.http_apps.permanentRedirect">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>permanentRedirect
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">permanentRedirect = function (request, location, status) {
    return exports.redirect(request, location, status || 301);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* @param {String} path
* @param {Number} status (optional) default is `301`
* @returns {App}
*/
exports.PermanentRedirect = function (location, status, tree) {
   return function (request, response) {
       return exports.<span class="apidocCodeKeywordSpan">permanentRedirect</span>(request, location, status, tree);
   };
};

/**
* @param {String} path
* @param {Number} status (optional) default is `301`
* @returns {App}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.permanentRedirectTree" id="apidoc.element.q-io.http_apps.permanentRedirectTree">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>permanentRedirectTree
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">permanentRedirectTree = function (request, location, status) {
    return exports.redirect(request, location, status || 301, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.redirect" id="apidoc.element.q-io.http_apps.redirect">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>redirect
        <span class="apidocSignatureSpan">(request, location, status, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redirect = function (request, location, status, tree) {

    // request.permanent gets set by Permanent middleware
    status = status || (request.permanent ? 301 : 307);

    // ascertain that the location is absolute, per spec
    location = URL.resolve(request.url, location);

    // redirect into a subtree with the remaining unrouted
    // portion of the path, if so configured
    if (tree) {
        location = URL.resolve(
            location,
            request.pathInfo.replace(/^\//, &#x22;&#x22;)
        );
    }

    var handlers = {};
    handlers[&#x22;text/plain&#x22;] = exports.redirectText;
    if (request.handleHtmlFragmentResponse) {
        handlers[&#x22;text/html&#x22;] = exports.redirectHtml;
    }
    var handler = Negotiation.negotiate(request, handlers) || exports.redirectText;
    return handler(request, location, status);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* @param {String} path
* @param {Number} status (optional) default is `307`
* @returns {App}
*/
exports.Redirect = function (location, status, tree) {
   return function (request, response) {
       return exports.<span class="apidocCodeKeywordSpan">redirect</span>(request, location, status, tree);
   };
};

/**
* @param {String} path
* @param {Number} status (optional) default is `307`
* @returns {App}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.redirectHtml" id="apidoc.element.q-io.http_apps.redirectHtml">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>redirectHtml
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redirectHtml = function (request, location, status) {
    var title = request.permanent ? &#x22;Permanent redirect&#x22; : &#x22;Temporary redirect&#x22;;
    return {
        status: status,
        headers: {
            location: location,
            &#x22;content-type&#x22;: &#x22;text/html&#x22;
        },
        htmlTitle: title,
        htmlFragment: {
            forEach: function (write) {
                write(&#x22;&#x3c;h1&#x3e;&#x22; + HtmlApps.escapeHtml(title) + &#x22;&#x3c;/h1&#x3e;\n&#x22;);
                write(
                    &#x22;&#x3c;p&#x3e;See: &#x3c;a href=\&#x22;&#x22; + HtmlApps.escapeHtml(location) + &#x22;\&#x22;&#x3e;&#x22; +
                    HtmlApps.escapeHtml(location) +
                    &#x22;&#x3c;/a&#x3e;&#x3c;/p&#x3e;\n&#x22;
                );
            }
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.redirectText" id="apidoc.element.q-io.http_apps.redirectText">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>redirectText
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redirectText = function (request, location, status) {
    var content = (
        (request.permanent ? &#x22;Permanent redirect\n&#x22; : &#x22;Temporary redirect\n&#x22;) +
        &#x22;See: &#x22; + location + &#x22;\n&#x22;
    );
    var contentLength = content.length;
    return {
        status: status,
        headers: {
            location: location,
            &#x22;content-type&#x22;: &#x22;text/plain&#x22;
        },
        body: [content]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.redirectTree" id="apidoc.element.q-io.http_apps.redirectTree">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>redirectTree
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redirectTree = function (request, location, status) {
    return exports.redirect(request, location, status, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.responseForStatus" id="apidoc.element.q-io.http_apps.responseForStatus">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>responseForStatus
        <span class="apidocSignatureSpan">(request, status, addendum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">responseForStatus = function (request, status, addendum) {
    if (exports.statusCodes[status] === undefined)
        throw &#x22;Unknown status code&#x22;;

    var message = exports.statusCodes[status];

    // RFC 2616, 10.2.5:
    // The 204 response MUST NOT include a message-body, and thus is always
    // terminated by the first empty line after the header fields.
    // RFC 2616, 10.3.5:
    // The 304 response MUST NOT contain a message-body, and thus is always
    // terminated by the first empty line after the header fields.
    if (exports.statusWithNoEntityBody(status)) {
        return {status: status, headers: {}};
    } else {
        var handlers = {};
        handlers[&#x22;text/plain&#x22;] = exports.textResponseForStatus;
        if (request.handleHtmlFragmentResponse) {
            handlers[&#x22;text/html&#x22;] = exports.htmlResponseForStatus;
        }
        var responseForStatus = Negotiation.negotiate(request, handlers) || exports.textResponseForStatus;
        return responseForStatus(request, status, message, addendum);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {App}
 */
exports.Error = function (app, debug) {
    return function (request, response) {
        return Q.when(app(request, response), null, function (error) {
            if (!debug)
                error = undefined;
            return StatusApps.<span class="apidocCodeKeywordSpan">responseForStatus</span>(request, 500, error &#x26;&#x26; error
.stack || error);
        });
    };
};

exports.Debug = function (app) {
    return exports.Error(app, true);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.statusWithNoEntityBody" id="apidoc.element.q-io.http_apps.statusWithNoEntityBody">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>statusWithNoEntityBody
        <span class="apidocSignatureSpan">(status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statusWithNoEntityBody = function (status) {
    return (status &#x3e;= 100 &#x26;&#x26; status &#x3c;= 199) ||
        status == 204 || status == 304;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// RFC 2616, 10.2.5:
// The 204 response MUST NOT include a message-body, and thus is always
// terminated by the first empty line after the header fields.
// RFC 2616, 10.3.5:
// The 304 response MUST NOT contain a message-body, and thus is always
// terminated by the first empty line after the header fields.
if (exports.<span class="apidocCodeKeywordSpan">statusWithNoEntityBody</span>(status)) {
    return {status: status, headers: {}};
} else {
    var handlers = {};
    handlers[&#x22;text/plain&#x22;] = exports.textResponseForStatus;
    if (request.handleHtmlFragmentResponse) {
        handlers[&#x22;text/html&#x22;] = exports.htmlResponseForStatus;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.temporaryRedirect" id="apidoc.element.q-io.http_apps.temporaryRedirect">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>temporaryRedirect
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">temporaryRedirect = function (request, location, status) {
    return exports.redirect(request, location, status || 307);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* @param {String} path
* @param {Number} status (optional) default is `307`
* @returns {App}
*/
exports.TemporaryRedirect = function (location, status, tree) {
   return function (request, response) {
       return exports.<span class="apidocCodeKeywordSpan">temporaryRedirect</span>(request, location, status, tree);
   };
};

/**
* @param {String} path
* @param {Number} status (optional) default is `307`
* @returns {App}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.temporaryRedirectTree" id="apidoc.element.q-io.http_apps.temporaryRedirectTree">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>temporaryRedirectTree
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">temporaryRedirectTree = function (request, location, status) {
    return exports.redirect(request, location, status || 307, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.textResponseForStatus" id="apidoc.element.q-io.http_apps.textResponseForStatus">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>textResponseForStatus
        <span class="apidocSignatureSpan">(request, status, message, addendum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">textResponseForStatus = function (request, status, message, addendum) {
    var content = message + &#x22;\n&#x22;;
    if (addendum) {
        content += addendum + &#x22;\n&#x22;;
    }
    var contentLength = content.length;
    return {
        status: status,
        statusMessage: message,
        headers: {
            &#x22;content-length&#x22;: contentLength
        },
        body: [content]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.http_cookie" id="apidoc.module.q-io.http_cookie">module q-io.http_cookie</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.http_cookie.parse" id="apidoc.element.q-io.http_cookie.parse">
        function <span class="apidocSignatureSpan">q-io.http_cookie.</span>parse
        <span class="apidocSignatureSpan">(cookie, date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (cookie, date) {
    date = date || new Date();
    var parsed = {};
    var terms = cookie.split(/[;,]/g);
    var keyValue = terms.shift().split(&#x22;=&#x22;);
    parsed.key = decodeURIComponent(keyValue[0]);
    parsed.value = decodeURIComponent(keyValue[1]);
    terms.forEach(function (term) {
        var parts = term.split(&#x22;=&#x22;).map(function (part) {
            return part.trim();
        });
        var key = parts[0], value = parts[1];
        if (/^domain$/i.test(key)) {
            parsed.domain = value;
        } else if (/^path$/i.test(key)) {
            parsed.path = value;
        } else if (/^expires$/i.test(key)) {
            parsed.expires = new Date(
                +new Date() + // actual now
                (new Date(value) - date) // server offset
            );
        } else if (/^max-age$/i.test(key)) {
            parsed.expires = new Date(
                new Date().getTime() +
                (value * 1000)
            );
        } else if (/^secure$/i.test(key)) {
            parsed.secure = true;
        } else if (/^httponly$/i.test(key)) {
            parsed.httpOnly = true;
        }
    });
    return parsed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.Client = Client;
function Client(fs) {
var self = Object.create(Client.prototype);

self.request = function (request) {
    return Q.when(request, function (request) {
        request = HTTP.normalizeRequest(request);
        var url = URL.<span class="apidocCodeKeywordSpan">parse</span>(request.url);
        if (url.protocol !== &#x22;file:&#x22;) {
            return {
                status: 404,
                headers: {},
                body: [&#x22;Can&#x27;t access protocol &#x22; + url.protocol]
            };
        } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_cookie.stringify" id="apidoc.element.q-io.http_cookie.stringify">
        function <span class="apidocSignatureSpan">q-io.http_cookie.</span>stringify
        <span class="apidocSignatureSpan">(key, value, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (key, value, options) {
    var cookie = (
        encodeURIComponent(key) + &#x22;=&#x22; +
        encodeURIComponent(value)
    );
    if (options) {
        if (options.domain)
            cookie += &#x22;; Domain=&#x22; + encodeURIComponent(options.domain);
        if (options.path)
            cookie += &#x22;; Path=&#x22; + encodeURIComponent(options.path);
        if (options.expires)
            cookie += &#x22;; Expires=&#x22; + options.expires.toGMTString();
        if (options.secure)
            cookie += &#x22;; Secure&#x22;;
        if (options.httpOnly)
            cookie += &#x22;; HttpOnly&#x22;;
    }
    return cookie;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {Array * String}
 */
exports.split = function (path) {
var parts;
try {
    parts = String(path).split(exports.SEPARATORS_RE());
} catch (exception) {
    throw new Error(&#x22;Cannot split &#x22; + (typeof path) + &#x22;, &#x22; + JSON.<span class="apidocCodeKeywordSpan">stringify
</span>(path));
}
// this special case helps isAbsolute
// distinguish an empty path from an absolute path
// &#x22;&#x22; -&#x3e; [] NOT [&#x22;&#x22;]
if (parts.length === 1 &#x26;&#x26; parts[0] === &#x22;&#x22;)
    return [];
// &#x22;a&#x22; -&#x3e; [&#x22;a&#x22;]
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.json" id="apidoc.module.q-io.json">module q-io.json</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.json.json" id="apidoc.element.q-io.json.json">
        function <span class="apidocSignatureSpan">q-io.</span>json
        <span class="apidocSignatureSpan">(content, reviver, tabs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json = function (content, reviver, tabs) {
    try {
        var json = JSON.stringify(content, reviver, tabs);
    } catch (exception) {
        return Q.reject(exception);
    }
    return Content.ok([json], &#x22;application/json&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function(Request):Object} app an application that accepts a
* request and returns a JSON serializable object.
* @returns {App}
*/
exports.Json = function (app, reviver, tabs) {
   return function (request, response) {
       return Q.when(app(request, response), function (object) {
           return exports.<span class="apidocCodeKeywordSpan">json</span>(object, reviver, tabs);
       });
   };
};

/**
* @param {Object} content data to serialize as JSON
* @param {Function} reviver
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.json.HandleJsonResponses" id="apidoc.element.q-io.json.HandleJsonResponses">
        function <span class="apidocSignatureSpan">q-io.json.</span>HandleJsonResponses
        <span class="apidocSignatureSpan">(app, reviver, tab)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HandleJsonResponses = function (app, reviver, tab) {
    return function (request) {
        request.handleJsonResponse = exports.handleJsonResponse;
        return Q.fcall(app, request)
        .then(function (response) {
            if (response.data !== void 0) {
                return Q.fcall(exports.handleJsonResponse, response, reviver, tab);
            } else {
                return response;
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.json.Json" id="apidoc.element.q-io.json.Json">
        function <span class="apidocSignatureSpan">q-io.json.</span>Json
        <span class="apidocSignatureSpan">(app, reviver, tabs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Json = function (app, reviver, tabs) {
    return function (request, response) {
        return Q.when(app(request, response), function (object) {
            return exports.json(object, reviver, tabs);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.json.JsonRequest" id="apidoc.element.q-io.json.JsonRequest">
        function <span class="apidocSignatureSpan">q-io.json.</span>JsonRequest
        <span class="apidocSignatureSpan">(app, badRequest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JsonRequest = function (app, badRequest) {
    if (!badRequest)
        badRequest = Status.badRequest;
    return Content.ContentRequest(function (content, request, response) {
        try {
            var object = JSON.parse(content);
        } catch (error) {
            return badRequest(request, error);
        }
        return app(object, request, response);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.json.handleJsonResponse" id="apidoc.element.q-io.json.handleJsonResponse">
        function <span class="apidocSignatureSpan">q-io.json.</span>handleJsonResponse
        <span class="apidocSignatureSpan">(response, revivier, tab)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleJsonResponse = function (response, revivier, tab) {
    response.headers[&#x22;content-type&#x22;] = &#x22;application/json&#x22;;
    response.body = {
        forEach: function (write) {
            write(JSON.stringify(response.data, revivier, tab));
        }
    };
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.negotiate" id="apidoc.module.q-io.negotiate">module q-io.negotiate</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.negotiate.negotiate" id="apidoc.element.q-io.negotiate.negotiate">
        function <span class="apidocSignatureSpan">q-io.</span>negotiate
        <span class="apidocSignatureSpan">(request, types, header)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function negotiate(request, types, header) {
    var keys = Object.keys(types);
    var accept = request.headers[header || &#x22;accept&#x22;] || &#x22;*&#x22;;
    var best = MimeParse.bestMatch(keys, accept);
    return types[best];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var handlers = {};
handlers[&#x22;text/plain&#x22;] = exports.redirectText;
if (request.handleHtmlFragmentResponse) {
    handlers[&#x22;text/html&#x22;] = exports.redirectHtml;
}
var handler = Negotiation.<span class="apidocCodeKeywordSpan">negotiate</span>(request, handlers) || exports.redirectText;
return handler(request, location, status);

};

exports.redirectText = function (request, location, status) {
var content = (
    (request.permanent ? &#x22;Permanent redirect\n&#x22; : &#x22;Temporary redirect\n&#x22;) +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.negotiate.Charset" id="apidoc.element.q-io.negotiate.Charset">
        function <span class="apidocSignatureSpan">q-io.negotiate.</span>Charset
        <span class="apidocSignatureSpan">(types, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Charset = function (types, notAcceptable) {
    var keys = Object.keys(types);
    if (!notAcceptable)
        notAcceptable = Status.notAcceptable;
    return function (request) {
        var accept = request.headers[requestHeader] || &#x22;*&#x22;;
        var type = MimeParse.bestMatch(keys, accept);
        request.terms = request.terms || {};
        request.terms[responseHeader] = type;
        if (Object.has(keys, type)) {
            return Q.when(types[type](request), function (response) {
                if (
                    respond !== null &#x26;&#x26;
                    response &#x26;&#x26;
                    response.status === 200 &#x26;&#x26;
                    response.headers
                ) {
                    response.headers[responseHeader] = type;
                }
                return response;
            });
        } else {
            return notAcceptable(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.negotiate.ContentType" id="apidoc.element.q-io.negotiate.ContentType">
        function <span class="apidocSignatureSpan">q-io.negotiate.</span>ContentType
        <span class="apidocSignatureSpan">(types, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ContentType = function (types, notAcceptable) {
    var keys = Object.keys(types);
    if (!notAcceptable)
        notAcceptable = Status.notAcceptable;
    return function (request) {
        var accept = request.headers[requestHeader] || &#x22;*&#x22;;
        var type = MimeParse.bestMatch(keys, accept);
        request.terms = request.terms || {};
        request.terms[responseHeader] = type;
        if (Object.has(keys, type)) {
            return Q.when(types[type](request), function (response) {
                if (
                    respond !== null &#x26;&#x26;
                    response &#x26;&#x26;
                    response.status === 200 &#x26;&#x26;
                    response.headers
                ) {
                    response.headers[responseHeader] = type;
                }
                return response;
            });
        } else {
            return notAcceptable(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.negotiate.Encoding" id="apidoc.element.q-io.negotiate.Encoding">
        function <span class="apidocSignatureSpan">q-io.negotiate.</span>Encoding
        <span class="apidocSignatureSpan">(types, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Encoding = function (types, notAcceptable) {
    var keys = Object.keys(types);
    if (!notAcceptable)
        notAcceptable = Status.notAcceptable;
    return function (request) {
        var accept = request.headers[requestHeader] || &#x22;*&#x22;;
        var type = MimeParse.bestMatch(keys, accept);
        request.terms = request.terms || {};
        request.terms[responseHeader] = type;
        if (Object.has(keys, type)) {
            return Q.when(types[type](request), function (response) {
                if (
                    respond !== null &#x26;&#x26;
                    response &#x26;&#x26;
                    response.status === 200 &#x26;&#x26;
                    response.headers
                ) {
                    response.headers[responseHeader] = type;
                }
                return response;
            });
        } else {
            return notAcceptable(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.negotiate.Host" id="apidoc.element.q-io.negotiate.Host">
        function <span class="apidocSignatureSpan">q-io.negotiate.</span>Host
        <span class="apidocSignatureSpan">(appForHost, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Host = function (appForHost, notAcceptable) {
    var table = Object.keys(appForHost).map(function (pattern) {
        var parts = pattern.split(&#x22;:&#x22;);
        return [
            pattern,
            parts[0] || &#x22;*&#x22;,
            parts[1] || &#x22;*&#x22;,
            appForHost[pattern]
        ];
    });
    if (!notAcceptable) {
        notAcceptable = Status.notAcceptable;
    }
    return function (request) {
        // find first matching host for app
        for (var index = 0; index &#x3c; table.length; index++) {
            var row = table[index]; // [hostname, port, app]
            var pattern = row[0];
            var hostname = row[1];
            var port = row[2];
            var app = row[3];
            if (
                (hostname === &#x22;*&#x22; || hostname === request.hostname) &#x26;&#x26;
                (port === &#x22;*&#x22; || port === &#x22;&#x22; + request.port)
            ) {
                request.terms = request.terms || {};
                request.terms.host = pattern;
                return app(request);
            }
        }
        return notAcceptable(request);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.negotiate.Language" id="apidoc.element.q-io.negotiate.Language">
        function <span class="apidocSignatureSpan">q-io.negotiate.</span>Language
        <span class="apidocSignatureSpan">(types, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Language = function (types, notAcceptable) {
    var keys = Object.keys(types);
    if (!notAcceptable)
        notAcceptable = Status.notAcceptable;
    return function (request) {
        var accept = request.headers[requestHeader] || &#x22;*&#x22;;
        var type = MimeParse.bestMatch(keys, accept);
        request.terms = request.terms || {};
        request.terms[responseHeader] = type;
        if (Object.has(keys, type)) {
            return Q.when(types[type](request), function (response) {
                if (
                    respond !== null &#x26;&#x26;
                    response &#x26;&#x26;
                    response.status === 200 &#x26;&#x26;
                    response.headers
                ) {
                    response.headers[responseHeader] = type;
                }
                return response;
            });
        } else {
            return notAcceptable(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.negotiate.Method" id="apidoc.element.q-io.negotiate.Method">
        function <span class="apidocSignatureSpan">q-io.negotiate.</span>Method
        <span class="apidocSignatureSpan">(methods, methodNotAllowed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Method = function (methods, methodNotAllowed) {
    var keys = Object.keys(methods);
    if (!methodNotAllowed)
        methodNotAllowed = Status.methodNotAllowed;
    return function (request) {
        var method = request.method;
        if (Object.has(keys, method)) {
            return Object.get(methods, method)(request);
        } else {
            return methodNotAllowed(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * @param {Function(Request):Object}
 * @returns {App}
 */
exports.Inspect = function (app) {
return Negotiate.<span class="apidocCodeKeywordSpan">Method</span>({&#x22;GET&#x22;: function (request, response) {
    return Q.when(app(request, response), function (object) {
        return {
            status: 200,
            headers: {
                &#x22;content-type&#x22;: &#x22;text/plain&#x22;
            },
            body: [inspect(object)]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.negotiate.Select" id="apidoc.element.q-io.negotiate.Select">
        function <span class="apidocSignatureSpan">q-io.negotiate.</span>Select
        <span class="apidocSignatureSpan">(select)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Select = function (select) {
    return function (request) {
        return Q.when(select(request), function (app) {
            return app(request);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.proxy" id="apidoc.module.q-io.proxy">module q-io.proxy</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.proxy.Proxy" id="apidoc.element.q-io.proxy.Proxy">
        function <span class="apidocSignatureSpan">q-io.proxy.</span>Proxy
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Proxy = function (app) {
    if (typeof app === &#x22;string&#x22;) {
        var location = app;
        app = function (request) {
            request.url = location;
            return request;
        };
    }
    return function (request, response) {
        return Q.when(app.apply(this, arguments), function (request) {
            return HTTP.request(request);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return Q.when(app.apply(this, arguments), function (request) {
            return HTTP.request(request);
        });
    };
};

exports.ProxyTree = function (url) {
    return exports.<span class="apidocCodeKeywordSpan">Proxy</span>(function (request) {
        request.url = URL.resolve(url, request.pathInfo.replace(/^\//, &#x22;&#x22;));
        return request;
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.proxy.ProxyTree" id="apidoc.element.q-io.proxy.ProxyTree">
        function <span class="apidocSignatureSpan">q-io.proxy.</span>ProxyTree
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ProxyTree = function (url) {
    return exports.Proxy(function (request) {
        request.url = URL.resolve(url, request.pathInfo.replace(/^\//, &#x22;&#x22;));
        return request;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.reader" id="apidoc.module.q-io.reader">module q-io.reader</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.reader.reader" id="apidoc.element.q-io.reader.reader">
        function <span class="apidocSignatureSpan">q-io.</span>reader
        <span class="apidocSignatureSpan">(_stream, charset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(_stream, charset) {
    var self = Object.create(Reader.prototype);

    if (charset &#x26;&#x26; _stream.setEncoding) // TODO complain about inconsistency
        _stream.setEncoding(charset);

    var begin = Q.defer();
    var end = Q.defer();

    _stream.on(&#x22;error&#x22;, function (reason) {
        begin.reject(reason);
    });

    var chunks = [];
    var receiver;

    _stream.on(&#x22;end&#x22;, function () {
        begin.resolve(self);
        end.resolve()
    });

    _stream.on(&#x22;data&#x22;, function (chunk) {
        begin.resolve(self);
        if (receiver) {
            receiver(chunk);
        } else {
            chunks.push(chunk);
        }
    });

    function slurp() {
        var result;
        if (charset) {
            result = chunks.join(&#x22;&#x22;);
        } else {
            result = self.constructor.join(chunks);
        }
        chunks.splice(0, chunks.length);
        return result;
    }

<span class="apidocCodeCommentSpan">    /***
     * Reads all of the remaining data from the stream.
     * @returns {Promise * String} a promise for a String
     * containing the entirety the remaining stream.
     */
</span>    self.read = function () {
        receiver = undefined;
        var deferred = Q.defer();
        Q.done(end.promise, function () {
            deferred.resolve(slurp());
        });
        return deferred.promise;
    };

    /***
     * Reads and writes all of the remaining data from the
     * stream in chunks.
     * @param {Function(Promise * String)} write a function
     * to be called on each chunk of input from this stream.
     * @returns {Promise * Undefined} a promise that will
     * be resolved when the input is depleted.
     */
    self.forEach = function (write) {
        if (chunks &#x26;&#x26; chunks.length)
            write(slurp());
        receiver = write;
        return Q.when(end.promise, function () {
            receiver = undefined;
        });
    };

    self.close = function () {
        _stream.destroy();
    };

    self.node = _stream;

    return begin.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.reader.join" id="apidoc.element.q-io.reader.join">
        function <span class="apidocSignatureSpan">q-io.reader.</span>join
        <span class="apidocSignatureSpan">(buffers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function join(buffers) {
    var length = 0;
    var at;
    var i;
    var ii = buffers.length;
    var buffer;
    var result;
    for (i = 0; i &#x3c; ii; i++) {
        buffer = buffers[i];
        length += buffer.length;
    }
    result = new Buffer(length);
    at = 0;
    for (i = 0; i &#x3c; ii; i++) {
        buffer = buffers[i];
        buffer.copy(result, at, 0);
        at += buffer.length;
    }
    buffers.splice(0, ii, result);
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return Q.fcall(function () {
        chunks.splice(0, chunks.length).forEach(write, thisp);
    });
};

BufferStream.prototype.read = function () {
    var result;
    result = Reader.<span class="apidocCodeKeywordSpan">join</span>(this._chunks);
    if (this._charset) {
        result = result.toString(this._charset);
    }
    return Q.resolve(result);
};

BufferStream.prototype.write = function (chunk) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.reader.read" id="apidoc.element.q-io.reader.read">
        function <span class="apidocSignatureSpan">q-io.reader.</span>read
        <span class="apidocSignatureSpan">(stream, charset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read(stream, charset) {
    var chunks = [];
    stream.forEach(function (chunk) {
        chunks.push(chunk);
    });
    if (charset) {
        return chunks.join(&#x22;&#x22;);
    } else {
        return join(chunks);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
into memory.  It returns a promise for the whole file contents.  By
default, `read` provides a string decoded from UTF-8.  With the bytewise
mode flag, provides a `Buffer`.

The options argument is identical to that of `open`.

```javascript
return FS.<span class="apidocCodeKeywordSpan">read</span>(__filename, &#x22;b&#x22;)
.then(function (content) {
    // ...
})
```

```javascript
return FS.read(__filename, {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.redirect" id="apidoc.module.q-io.redirect">module q-io.redirect</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.redirect.redirect" id="apidoc.element.q-io.redirect.redirect">
        function <span class="apidocSignatureSpan">q-io.</span>redirect
        <span class="apidocSignatureSpan">(request, location, status, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redirect = function (request, location, status, tree) {

    // request.permanent gets set by Permanent middleware
    status = status || (request.permanent ? 301 : 307);

    // ascertain that the location is absolute, per spec
    location = URL.resolve(request.url, location);

    // redirect into a subtree with the remaining unrouted
    // portion of the path, if so configured
    if (tree) {
        location = URL.resolve(
            location,
            request.pathInfo.replace(/^\//, &#x22;&#x22;)
        );
    }

    var handlers = {};
    handlers[&#x22;text/plain&#x22;] = exports.redirectText;
    if (request.handleHtmlFragmentResponse) {
        handlers[&#x22;text/html&#x22;] = exports.redirectHtml;
    }
    var handler = Negotiation.negotiate(request, handlers) || exports.redirectText;
    return handler(request, location, status);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* @param {String} path
* @param {Number} status (optional) default is `307`
* @returns {App}
*/
exports.Redirect = function (location, status, tree) {
   return function (request, response) {
       return exports.<span class="apidocCodeKeywordSpan">redirect</span>(request, location, status, tree);
   };
};

/**
* @param {String} path
* @param {Number} status (optional) default is `307`
* @returns {App}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.PermanentRedirect" id="apidoc.element.q-io.redirect.PermanentRedirect">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>PermanentRedirect
        <span class="apidocSignatureSpan">(location, status, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PermanentRedirect = function (location, status, tree) {
    return function (request, response) {
        return exports.permanentRedirect(request, location, status, tree);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.PermanentRedirectTree" id="apidoc.element.q-io.redirect.PermanentRedirectTree">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>PermanentRedirectTree
        <span class="apidocSignatureSpan">(location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PermanentRedirectTree = function (location, status) {
    return function (request, response) {
        return exports.permanentRedirect(request, location, status, true);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.Redirect" id="apidoc.element.q-io.redirect.Redirect">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>Redirect
        <span class="apidocSignatureSpan">(location, status, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Redirect = function (location, status, tree) {
    return function (request, response) {
        return exports.redirect(request, location, status, tree);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.RedirectTrap" id="apidoc.element.q-io.redirect.RedirectTrap">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>RedirectTrap
        <span class="apidocSignatureSpan">(app, maxRedirects)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RedirectTrap = function (app, maxRedirects) {
    maxRedirects = maxRedirects || 20;
    return function (request, response) {
        var remaining = maxRedirects;
        var deferred = Q.defer();
        var self = this;
        var args = arguments;

        request = Http.normalizeRequest(request);

        // try redirect loop
        function next() {
            Q.fcall(function () {
                return app(request, response);
            })
            .then(function (response) {
                if (exports.isRedirect(response)) {
                    if (remaining--) {
                        request.url = response.headers.location;
                        next();
                    } else {
                        throw new Error(&#x22;Maximum redirects.&#x22;);
                    }
                } else {
                    deferred.resolve(response);
                }
            })
            .fail(deferred.reject)
        }
        next();

        return deferred.promise;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.RedirectTree" id="apidoc.element.q-io.redirect.RedirectTree">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>RedirectTree
        <span class="apidocSignatureSpan">(location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RedirectTree = function (location, status) {
    return function (request, response) {
        return exports.redirect(request, location, status, true);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.TemporaryRedirect" id="apidoc.element.q-io.redirect.TemporaryRedirect">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>TemporaryRedirect
        <span class="apidocSignatureSpan">(location, status, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TemporaryRedirect = function (location, status, tree) {
    return function (request, response) {
        return exports.temporaryRedirect(request, location, status, tree);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.TemporaryRedirectTree" id="apidoc.element.q-io.redirect.TemporaryRedirectTree">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>TemporaryRedirectTree
        <span class="apidocSignatureSpan">(location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TemporaryRedirectTree = function (location, status) {
    return function (request, response) {
        return exports.temporaryRedirect(request, location, status, true);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.isRedirect" id="apidoc.element.q-io.redirect.isRedirect">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>isRedirect
        <span class="apidocSignatureSpan">(response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRedirect = function (response) {
    return isRedirect[response.status] || false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// try redirect loop
function next() {
    Q.fcall(function () {
        return app(request, response);
    })
    .then(function (response) {
        if (exports.<span class="apidocCodeKeywordSpan">isRedirect</span>(response)) {
            if (remaining--) {
                request.url = response.headers.location;
                next();
            } else {
                throw new Error(&#x22;Maximum redirects.&#x22;);
            }
        } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.permanentRedirect" id="apidoc.element.q-io.redirect.permanentRedirect">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>permanentRedirect
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">permanentRedirect = function (request, location, status) {
    return exports.redirect(request, location, status || 301);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* @param {String} path
* @param {Number} status (optional) default is `301`
* @returns {App}
*/
exports.PermanentRedirect = function (location, status, tree) {
   return function (request, response) {
       return exports.<span class="apidocCodeKeywordSpan">permanentRedirect</span>(request, location, status, tree);
   };
};

/**
* @param {String} path
* @param {Number} status (optional) default is `301`
* @returns {App}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.permanentRedirectTree" id="apidoc.element.q-io.redirect.permanentRedirectTree">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>permanentRedirectTree
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">permanentRedirectTree = function (request, location, status) {
    return exports.redirect(request, location, status || 301, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.redirectHtml" id="apidoc.element.q-io.redirect.redirectHtml">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>redirectHtml
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redirectHtml = function (request, location, status) {
    var title = request.permanent ? &#x22;Permanent redirect&#x22; : &#x22;Temporary redirect&#x22;;
    return {
        status: status,
        headers: {
            location: location,
            &#x22;content-type&#x22;: &#x22;text/html&#x22;
        },
        htmlTitle: title,
        htmlFragment: {
            forEach: function (write) {
                write(&#x22;&#x3c;h1&#x3e;&#x22; + HtmlApps.escapeHtml(title) + &#x22;&#x3c;/h1&#x3e;\n&#x22;);
                write(
                    &#x22;&#x3c;p&#x3e;See: &#x3c;a href=\&#x22;&#x22; + HtmlApps.escapeHtml(location) + &#x22;\&#x22;&#x3e;&#x22; +
                    HtmlApps.escapeHtml(location) +
                    &#x22;&#x3c;/a&#x3e;&#x3c;/p&#x3e;\n&#x22;
                );
            }
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.redirectText" id="apidoc.element.q-io.redirect.redirectText">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>redirectText
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redirectText = function (request, location, status) {
    var content = (
        (request.permanent ? &#x22;Permanent redirect\n&#x22; : &#x22;Temporary redirect\n&#x22;) +
        &#x22;See: &#x22; + location + &#x22;\n&#x22;
    );
    var contentLength = content.length;
    return {
        status: status,
        headers: {
            location: location,
            &#x22;content-type&#x22;: &#x22;text/plain&#x22;
        },
        body: [content]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.redirectTree" id="apidoc.element.q-io.redirect.redirectTree">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>redirectTree
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redirectTree = function (request, location, status) {
    return exports.redirect(request, location, status, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.temporaryRedirect" id="apidoc.element.q-io.redirect.temporaryRedirect">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>temporaryRedirect
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">temporaryRedirect = function (request, location, status) {
    return exports.redirect(request, location, status || 307);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* @param {String} path
* @param {Number} status (optional) default is `307`
* @returns {App}
*/
exports.TemporaryRedirect = function (location, status, tree) {
   return function (request, response) {
       return exports.<span class="apidocCodeKeywordSpan">temporaryRedirect</span>(request, location, status, tree);
   };
};

/**
* @param {String} path
* @param {Number} status (optional) default is `307`
* @returns {App}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.temporaryRedirectTree" id="apidoc.element.q-io.redirect.temporaryRedirectTree">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>temporaryRedirectTree
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">temporaryRedirectTree = function (request, location, status) {
    return exports.redirect(request, location, status || 307, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.route" id="apidoc.module.q-io.route">module q-io.route</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.route.Branch" id="apidoc.element.q-io.route.Branch">
        function <span class="apidocSignatureSpan">q-io.route.</span>Branch
        <span class="apidocSignatureSpan">(paths, notFound)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Branch = function (paths, notFound) {
    if (!paths)
        paths = {};
    if (!notFound)
        notFound = StatusApps.notFound;
    return function (request, response) {
        if (!/^\//.test(request.pathInfo)) {
            return notFound(request, response);
        }
        var path = request.pathInfo.slice(1);
        var parts = path.split(&#x22;/&#x22;);
        var part = decodeURIComponent(parts.shift());
        if (Object.has(paths, part)) {
            request.scriptName = request.scriptName + part + &#x22;/&#x22;;
            request.pathInfo = path.slice(part.length);
            return Object.get(paths, part)(request, response);
        }
        return notFound(request, response);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.route.Cap" id="apidoc.element.q-io.route.Cap">
        function <span class="apidocSignatureSpan">q-io.route.</span>Cap
        <span class="apidocSignatureSpan">(app, notFound)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Cap = function (app, notFound) {
    notFound = notFound || StatusApps.notFound;
    return function (request, response) {
        // TODO Distinguish these cases
        if (request.pathInfo === &#x22;&#x22; || request.pathInfo === &#x22;/&#x22;) {
            return app(request, response);
        } else {
            return notFound(request, response);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.route.FirstFound" id="apidoc.element.q-io.route.FirstFound">
        function <span class="apidocSignatureSpan">q-io.route.</span>FirstFound
        <span class="apidocSignatureSpan">(cascade)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FirstFound = function (cascade) {
    return function (request, response) {
        var i = 0, ii = cascade.length;
        function next() {
            var response = cascade[i++](request, response);
            if (i &#x3c; ii) {
                return Q.when(response, function (response) {
                    if (response.status === 404) {
                        return next();
                    } else {
                        return response;
                    }
                });
            } else {
                return response;
            }
        }
        return next();
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.route.Tap" id="apidoc.element.q-io.route.Tap">
        function <span class="apidocSignatureSpan">q-io.route.</span>Tap
        <span class="apidocSignatureSpan">(app, tap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Tap = function (app, tap) {
    return function (request, response) {
        var self = this, args = arguments;
        return Q.when(tap.apply(this, arguments), function (response) {
            if (response) {
                return response;
            } else {
                return app.apply(self, args);
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    24 * // h
    365 * // d
    10; // years
exports.Permanent = function (app, future) {
    future = future || function () {
        return new Date(new Date().getTime() + farFuture);
    };
    app = RouteApps.<span class="apidocCodeKeywordSpan">Tap</span>(app, function (request, response) {
        request.permanent = future;
    });
    app = RouteApps.Trap(app, function (response, request) {
        response.headers[&#x22;expires&#x22;] = &#x22;&#x22; + future();
    });
    return app;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.route.Trap" id="apidoc.element.q-io.route.Trap">
        function <span class="apidocSignatureSpan">q-io.route.</span>Trap
        <span class="apidocSignatureSpan">(app, trap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Trap = function (app, trap) {
    return function (request, response) {
        return Q.when(app.apply(this, arguments), function (response) {
            if (response) {
                response.headers = response.headers || {};
                return trap(response, request) || response;
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   };
};

exports.Date = function (app, present) {
   present = present || function () {
       return new Date();
   };
   return RouteApps.<span class="apidocCodeKeywordSpan">Trap</span>(app, function (response, request) {
       response.headers[&#x22;date&#x22;] = &#x22;&#x22; + present();
   });
};

/**
* Decorates a JSGI application such that rejected response promises
* get translated into `500` server error responses with no content.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.status" id="apidoc.module.q-io.status">module q-io.status</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.status.appForStatus" id="apidoc.element.q-io.status.appForStatus">
        function <span class="apidocSignatureSpan">q-io.status.</span>appForStatus
        <span class="apidocSignatureSpan">(status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appForStatus = function (status) {
    return function (request) {
        return exports.responseForStatus(request, status, request.method + &#x22; &#x22; + request.path);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       }
   }
};

/**
* {App} an application that returns a 400 response.
*/
exports.badRequest = exports.<span class="apidocCodeKeywordSpan">appForStatus</span>(400);
/**
* {App} an application that returns a 404 response.
*/
exports.notFound = exports.appForStatus(404);
/**
* {App} an application that returns a 405 response.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.badRequest" id="apidoc.element.q-io.status.badRequest">
        function <span class="apidocSignatureSpan">q-io.status.</span>badRequest
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">badRequest = function (request) {
    return exports.responseForStatus(request, status, request.method + &#x22; &#x22; + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.htmlResponseForStatus" id="apidoc.element.q-io.status.htmlResponseForStatus">
        function <span class="apidocSignatureSpan">q-io.status.</span>htmlResponseForStatus
        <span class="apidocSignatureSpan">(request, status, message, addendum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">htmlResponseForStatus = function (request, status, message, addendum) {
    return {
        status: status,
        statusMessage: message,
        headers: {},
        htmlTitle: message,
        htmlFragment: {
            forEach: function (write) {
                write(&#x22;&#x3c;h1&#x3e;&#x22; + HtmlApps.escapeHtml(message) + &#x22;&#x3c;/h1&#x3e;\n&#x22;);
                write(&#x22;&#x3c;p&#x3e;Status: &#x22; + status + &#x22;&#x3c;/p&#x3e;\n&#x22;);
                if (addendum) {
                    write(&#x22;&#x3c;pre&#x3e;&#x22; + HtmlApps.escapeHtml(addendum) + &#x22;&#x3c;/pre&#x3e;\n&#x22;);
                }
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.methodNotAllowed" id="apidoc.element.q-io.status.methodNotAllowed">
        function <span class="apidocSignatureSpan">q-io.status.</span>methodNotAllowed
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">methodNotAllowed = function (request) {
    return exports.responseForStatus(request, status, request.method + &#x22; &#x22; + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.noLanguage" id="apidoc.element.q-io.status.noLanguage">
        function <span class="apidocSignatureSpan">q-io.status.</span>noLanguage
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noLanguage = function (request) {
    return exports.responseForStatus(request, status, request.method + &#x22; &#x22; + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.notAcceptable" id="apidoc.element.q-io.status.notAcceptable">
        function <span class="apidocSignatureSpan">q-io.status.</span>notAcceptable
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notAcceptable = function (request) {
    return exports.responseForStatus(request, status, request.method + &#x22; &#x22; + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.notFound" id="apidoc.element.q-io.status.notFound">
        function <span class="apidocSignatureSpan">q-io.status.</span>notFound
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notFound = function (request) {
    return exports.responseForStatus(request, status, request.method + &#x22; &#x22; + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.responseForStatus" id="apidoc.element.q-io.status.responseForStatus">
        function <span class="apidocSignatureSpan">q-io.status.</span>responseForStatus
        <span class="apidocSignatureSpan">(request, status, addendum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">responseForStatus = function (request, status, addendum) {
    if (exports.statusCodes[status] === undefined)
        throw &#x22;Unknown status code&#x22;;

    var message = exports.statusCodes[status];

    // RFC 2616, 10.2.5:
    // The 204 response MUST NOT include a message-body, and thus is always
    // terminated by the first empty line after the header fields.
    // RFC 2616, 10.3.5:
    // The 304 response MUST NOT contain a message-body, and thus is always
    // terminated by the first empty line after the header fields.
    if (exports.statusWithNoEntityBody(status)) {
        return {status: status, headers: {}};
    } else {
        var handlers = {};
        handlers[&#x22;text/plain&#x22;] = exports.textResponseForStatus;
        if (request.handleHtmlFragmentResponse) {
            handlers[&#x22;text/html&#x22;] = exports.htmlResponseForStatus;
        }
        var responseForStatus = Negotiation.negotiate(request, handlers) || exports.textResponseForStatus;
        return responseForStatus(request, status, message, addendum);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {App}
 */
exports.Error = function (app, debug) {
    return function (request, response) {
        return Q.when(app(request, response), null, function (error) {
            if (!debug)
                error = undefined;
            return StatusApps.<span class="apidocCodeKeywordSpan">responseForStatus</span>(request, 500, error &#x26;&#x26; error
.stack || error);
        });
    };
};

exports.Debug = function (app) {
    return exports.Error(app, true);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.statusWithNoEntityBody" id="apidoc.element.q-io.status.statusWithNoEntityBody">
        function <span class="apidocSignatureSpan">q-io.status.</span>statusWithNoEntityBody
        <span class="apidocSignatureSpan">(status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statusWithNoEntityBody = function (status) {
    return (status &#x3e;= 100 &#x26;&#x26; status &#x3c;= 199) ||
        status == 204 || status == 304;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// RFC 2616, 10.2.5:
// The 204 response MUST NOT include a message-body, and thus is always
// terminated by the first empty line after the header fields.
// RFC 2616, 10.3.5:
// The 304 response MUST NOT contain a message-body, and thus is always
// terminated by the first empty line after the header fields.
if (exports.<span class="apidocCodeKeywordSpan">statusWithNoEntityBody</span>(status)) {
    return {status: status, headers: {}};
} else {
    var handlers = {};
    handlers[&#x22;text/plain&#x22;] = exports.textResponseForStatus;
    if (request.handleHtmlFragmentResponse) {
        handlers[&#x22;text/html&#x22;] = exports.htmlResponseForStatus;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.textResponseForStatus" id="apidoc.element.q-io.status.textResponseForStatus">
        function <span class="apidocSignatureSpan">q-io.status.</span>textResponseForStatus
        <span class="apidocSignatureSpan">(request, status, message, addendum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">textResponseForStatus = function (request, status, message, addendum) {
    var content = message + &#x22;\n&#x22;;
    if (addendum) {
        content += addendum + &#x22;\n&#x22;;
    }
    var contentLength = content.length;
    return {
        status: status,
        statusMessage: message,
        headers: {
            &#x22;content-length&#x22;: contentLength
        },
        body: [content]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.writer" id="apidoc.module.q-io.writer">module q-io.writer</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.writer.writer" id="apidoc.element.q-io.writer.writer">
        function <span class="apidocSignatureSpan">q-io.</span>writer
        <span class="apidocSignatureSpan">(_stream, charset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writer(_stream, charset) {
    var self = Object.create(Writer.prototype);

    if (charset &#x26;&#x26; _stream.setEncoding) // TODO complain about inconsistency
        _stream.setEncoding(charset);

    var drained = Q.defer();

    _stream.on(&#x22;error&#x22;, function (reason) {
        drained.reject(reason);
        drained = Q.defer();
    });

    _stream.on(&#x22;drain&#x22;, function () {
        drained.resolve();
        drained = Q.defer();
    });

<span class="apidocCodeCommentSpan">    /***
     * Writes content to the stream.
     * @param {String} content
     * @returns {Promise * Undefined} a promise that will
     * be resolved when the buffer is empty, meaning
     * that all of the content has been sent.
     */
</span>    self.write = function (content) {
        if (!_stream.writeable &#x26;&#x26; !_stream.writable)
            return Q.reject(new Error(&#x22;Can&#x27;t write to non-writable (possibly closed) stream&#x22;));
        if (typeof content !== &#x22;string&#x22;) {
            content = new Buffer(content);
        }
        if (!_stream.write(content)) {
            return drained.promise;
        } else {
            return Q.resolve();
        }
    };

    /***
     * Waits for all data to flush on the stream.
     *
     * @returns {Promise * Undefined} a promise that will
     * be resolved when the buffer is empty
     */
    self.flush = function () {
        return drained.promise;
    };

    /***
     * Closes the stream, waiting for the internal buffer
     * to flush.
     *
     * @returns {Promise * Undefined} a promise that will
     * be resolved when the stream has finished writing,
     * flushing, and closed.
     */
    self.close = function () {
        var finished;

        if (supportsFinish) { // new Streams, listen for `finish` event
            finished = Q.defer();
            _stream.on(&#x22;finish&#x22;, function () {
                finished.resolve();
            });
            _stream.on(&#x22;error&#x22;, function (reason) {
                finished.reject(reason);
            });
        }

        _stream.end();
        drained.resolve(); // we will get no further drain events
        if (finished) { // closing not explicitly observable
            return finished.promise;
        } else {
            return Q(); // just resolve for old Streams
        }
    };

    /***
     * Terminates writing on a stream, closing before
     * the internal buffer drains.
     *
     * @returns {Promise * Undefined} a promise that will
     * be resolved when the stream has finished closing.
     */
    self.destroy = function () {
        _stream.destroy();
        drained.resolve(); // we will get no further drain events
        return Q.resolve(); // destruction not explicitly observable
    };

    self.node = _stream;

    return Q(self); // todo returns the begin.promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
