<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://github.com/kriskowal/q-io/">q-io (v1.13.2)</a>
</h1>
<h4>IO using Q promises</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io">module q-io</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.buffer_stream">
            function <span class="apidocSignatureSpan">q-io.</span>buffer_stream
            <span class="apidocSignatureSpan">(chunks, charset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.chain">
            function <span class="apidocSignatureSpan">q-io.</span>chain
            <span class="apidocSignatureSpan">(end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.reader">
            function <span class="apidocSignatureSpan">q-io.</span>reader
            <span class="apidocSignatureSpan">(_stream, charset)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>buffer_stream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>chain.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>content</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>cookie</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>decorators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>deprecate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>fs2http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>fs_boot</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>fs_common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>html</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>http</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>http_apps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>http_cookie</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>json</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>negotiate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>proxy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>redirect</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>route</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.buffer_stream">module q-io.buffer_stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.buffer_stream.buffer_stream">
            function <span class="apidocSignatureSpan">q-io.</span>buffer_stream
            <span class="apidocSignatureSpan">(chunks, charset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.buffer_stream.prototype">module q-io.buffer_stream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.buffer_stream.prototype.close">
            function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.buffer_stream.prototype.destroy">
            function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.buffer_stream.prototype.forEach">
            function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>forEach
            <span class="apidocSignatureSpan">(write, thisp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.buffer_stream.prototype.read">
            function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.buffer_stream.prototype.write">
            function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>write
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.chain">module q-io.chain</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.chain.chain">
            function <span class="apidocSignatureSpan">q-io.</span>chain
            <span class="apidocSignatureSpan">(end)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.chain.prototype">module q-io.chain.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.chain.prototype.use">
            function <span class="apidocSignatureSpan">q-io.chain.prototype.</span>use
            <span class="apidocSignatureSpan">(App)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.content">module q-io.content</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.content.content">
            function <span class="apidocSignatureSpan">q-io.</span>content
            <span class="apidocSignatureSpan">(content, contentType, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.content.Content">
            function <span class="apidocSignatureSpan">q-io.content.</span>Content
            <span class="apidocSignatureSpan">(body, contentType, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.content.ContentRequest">
            function <span class="apidocSignatureSpan">q-io.content.</span>ContentRequest
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.content.Inspect">
            function <span class="apidocSignatureSpan">q-io.content.</span>Inspect
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.content.ParseQuery">
            function <span class="apidocSignatureSpan">q-io.content.</span>ParseQuery
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.content.ok">
            function <span class="apidocSignatureSpan">q-io.content.</span>ok
            <span class="apidocSignatureSpan">(content, contentType, status)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.cookie">module q-io.cookie</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.cookie.CookieJar">
            function <span class="apidocSignatureSpan">q-io.cookie.</span>CookieJar
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.decorators">module q-io.decorators</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Date">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Date
            <span class="apidocSignatureSpan">(app, present)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Debug">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Debug
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Decorators">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Decorators
            <span class="apidocSignatureSpan">(decorators, app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Error">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Error
            <span class="apidocSignatureSpan">(app, debug)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Headers">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Headers
            <span class="apidocSignatureSpan">(app, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Log">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Log
            <span class="apidocSignatureSpan">(app, log, stamp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Normalize">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Normalize
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Permanent">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Permanent
            <span class="apidocSignatureSpan">(app, future)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.decorators.Time">
            function <span class="apidocSignatureSpan">q-io.decorators.</span>Time
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.deprecate">module q-io.deprecate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.deprecate.deprecateMethod">
            function <span class="apidocSignatureSpan">q-io.deprecate.</span>deprecateMethod
            <span class="apidocSignatureSpan">(scope, deprecatedFunction, name, alternative)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.deprecate.deprecationWarning">
            function <span class="apidocSignatureSpan">q-io.deprecate.</span>deprecationWarning
            <span class="apidocSignatureSpan">(name, alternative, stackTraceLimit)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.fs">module q-io.fs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.Mock">
            function <span class="apidocSignatureSpan">q-io.fs.</span>Mock
            <span class="apidocSignatureSpan">(files, workingDirectory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.Root">
            function <span class="apidocSignatureSpan">q-io.fs.</span>Root
            <span class="apidocSignatureSpan">(outer, root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.SEPARATORS_RE">
            function <span class="apidocSignatureSpan">q-io.fs.</span>SEPARATORS_RE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.Stats">
            function <span class="apidocSignatureSpan">q-io.fs.</span>Stats
            <span class="apidocSignatureSpan">(nodeStat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.absolute">
            function <span class="apidocSignatureSpan">q-io.fs.</span>absolute
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.append">
            function <span class="apidocSignatureSpan">q-io.fs.</span>append
            <span class="apidocSignatureSpan">(path, content, flags, charset, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.base">
            function <span class="apidocSignatureSpan">q-io.fs.</span>base
            <span class="apidocSignatureSpan">(path, extension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.canonical">
            function <span class="apidocSignatureSpan">q-io.fs.</span>canonical
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.chmod">
            function <span class="apidocSignatureSpan">q-io.fs.</span>chmod
            <span class="apidocSignatureSpan">(path, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.chown">
            function <span class="apidocSignatureSpan">q-io.fs.</span>chown
            <span class="apidocSignatureSpan">(path, uid, gid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.contains">
            function <span class="apidocSignatureSpan">q-io.fs.</span>contains
            <span class="apidocSignatureSpan">(parent, child)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.copy">
            function <span class="apidocSignatureSpan">q-io.fs.</span>copy
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.copyTree">
            function <span class="apidocSignatureSpan">q-io.fs.</span>copyTree
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.directory">
            function <span class="apidocSignatureSpan">q-io.fs.</span>directory
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.exists">
            function <span class="apidocSignatureSpan">q-io.fs.</span>exists
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.extension">
            function <span class="apidocSignatureSpan">q-io.fs.</span>extension
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.isAbsolute">
            function <span class="apidocSignatureSpan">q-io.fs.</span>isAbsolute
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.isDirectory">
            function <span class="apidocSignatureSpan">q-io.fs.</span>isDirectory
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.isFile">
            function <span class="apidocSignatureSpan">q-io.fs.</span>isFile
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.isRelative">
            function <span class="apidocSignatureSpan">q-io.fs.</span>isRelative
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.isRoot">
            function <span class="apidocSignatureSpan">q-io.fs.</span>isRoot
            <span class="apidocSignatureSpan">(first)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.isSymbolicLink">
            function <span class="apidocSignatureSpan">q-io.fs.</span>isSymbolicLink
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.join">
            function <span class="apidocSignatureSpan">q-io.fs.</span>join
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.lastAccessed">
            function <span class="apidocSignatureSpan">q-io.fs.</span>lastAccessed
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.lastModified">
            function <span class="apidocSignatureSpan">q-io.fs.</span>lastModified
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.link">
            function <span class="apidocSignatureSpan">q-io.fs.</span>link
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.list">
            function <span class="apidocSignatureSpan">q-io.fs.</span>list
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.listDirectoryTree">
            function <span class="apidocSignatureSpan">q-io.fs.</span>listDirectoryTree
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.listTree">
            function <span class="apidocSignatureSpan">q-io.fs.</span>listTree
            <span class="apidocSignatureSpan">(basePath, guard)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.makeDirectory">
            function <span class="apidocSignatureSpan">q-io.fs.</span>makeDirectory
            <span class="apidocSignatureSpan">(path, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.makeTree">
            function <span class="apidocSignatureSpan">q-io.fs.</span>makeTree
            <span class="apidocSignatureSpan">(path, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.merge">
            function <span class="apidocSignatureSpan">q-io.fs.</span>merge
            <span class="apidocSignatureSpan">(fss)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.mock">
            function <span class="apidocSignatureSpan">q-io.fs.</span>mock
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.move">
            function <span class="apidocSignatureSpan">q-io.fs.</span>move
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.normal">
            function <span class="apidocSignatureSpan">q-io.fs.</span>normal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.open">
            function <span class="apidocSignatureSpan">q-io.fs.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.read">
            function <span class="apidocSignatureSpan">q-io.fs.</span>read
            <span class="apidocSignatureSpan">(path, flags, charset, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.readLink">
            function <span class="apidocSignatureSpan">q-io.fs.</span>readLink
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.relative">
            function <span class="apidocSignatureSpan">q-io.fs.</span>relative
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.relativeFromDirectory">
            function <span class="apidocSignatureSpan">q-io.fs.</span>relativeFromDirectory
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.relativeFromFile">
            function <span class="apidocSignatureSpan">q-io.fs.</span>relativeFromFile
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.remove">
            function <span class="apidocSignatureSpan">q-io.fs.</span>remove
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.removeDirectory">
            function <span class="apidocSignatureSpan">q-io.fs.</span>removeDirectory
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.removeTree">
            function <span class="apidocSignatureSpan">q-io.fs.</span>removeTree
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.rename">
            function <span class="apidocSignatureSpan">q-io.fs.</span>rename
            <span class="apidocSignatureSpan">(source, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.reroot">
            function <span class="apidocSignatureSpan">q-io.fs.</span>reroot
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.resolve">
            function <span class="apidocSignatureSpan">q-io.fs.</span>resolve
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.root">
            function <span class="apidocSignatureSpan">q-io.fs.</span>root
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.split">
            function <span class="apidocSignatureSpan">q-io.fs.</span>split
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.stat">
            function <span class="apidocSignatureSpan">q-io.fs.</span>stat
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.statFd">
            function <span class="apidocSignatureSpan">q-io.fs.</span>statFd
            <span class="apidocSignatureSpan">(fd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.statLink">
            function <span class="apidocSignatureSpan">q-io.fs.</span>statLink
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.symbolicCopy">
            function <span class="apidocSignatureSpan">q-io.fs.</span>symbolicCopy
            <span class="apidocSignatureSpan">(source, target, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.symbolicLink">
            function <span class="apidocSignatureSpan">q-io.fs.</span>symbolicLink
            <span class="apidocSignatureSpan">(target, relative, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.toObject">
            function <span class="apidocSignatureSpan">q-io.fs.</span>toObject
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs.write">
            function <span class="apidocSignatureSpan">q-io.fs.</span>write
            <span class="apidocSignatureSpan">(path, content, flags, charset, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">q-io.fs.</span>ROOT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">q-io.fs.</span>SEPARATOR</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.fs2http">module q-io.fs2http</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs2http.Client">
            function <span class="apidocSignatureSpan">q-io.fs2http.</span>Client
            <span class="apidocSignatureSpan">(fs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs2http.read">
            function <span class="apidocSignatureSpan">q-io.fs2http.</span>read
            <span class="apidocSignatureSpan">(request, qualifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs2http.request">
            function <span class="apidocSignatureSpan">q-io.fs2http.</span>request
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.fs_boot">module q-io.fs_boot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.SEPARATORS_RE">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>SEPARATORS_RE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.base">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>base
            <span class="apidocSignatureSpan">(path, extension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.directory">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>directory
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.extension">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>extension
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.isAbsolute">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>isAbsolute
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.isRelative">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>isRelative
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.isRoot">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>isRoot
            <span class="apidocSignatureSpan">(first)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.join">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>join
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.normal">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>normal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.resolve">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>resolve
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.root">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>root
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_boot.split">
            function <span class="apidocSignatureSpan">q-io.fs_boot.</span>split
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">q-io.fs_boot.</span>ROOT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">q-io.fs_boot.</span>SEPARATOR</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.fs_common">module q-io.fs_common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.fs_common.update">
            function <span class="apidocSignatureSpan">q-io.fs_common.</span>update
            <span class="apidocSignatureSpan">(exports, workingDirectory)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.html">module q-io.html</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.html.HandleHtmlFragmentResponses">
            function <span class="apidocSignatureSpan">q-io.html.</span>HandleHtmlFragmentResponses
            <span class="apidocSignatureSpan">(app, handleHtmlFragmentResponse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.html.escapeHtml">
            function <span class="apidocSignatureSpan">q-io.html.</span>escapeHtml
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.html.handleHtmlFragmentResponse">
            function <span class="apidocSignatureSpan">q-io.html.</span>handleHtmlFragmentResponse
            <span class="apidocSignatureSpan">(response)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.http">module q-io.http</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http.ClientResponse">
            function <span class="apidocSignatureSpan">q-io.http.</span>ClientResponse
            <span class="apidocSignatureSpan">(_response, charset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http.Server">
            function <span class="apidocSignatureSpan">q-io.http.</span>Server
            <span class="apidocSignatureSpan">(respond)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http.ServerRequest">
            function <span class="apidocSignatureSpan">q-io.http.</span>ServerRequest
            <span class="apidocSignatureSpan">(_request, ssl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http.ServerResponse">
            function <span class="apidocSignatureSpan">q-io.http.</span>ServerResponse
            <span class="apidocSignatureSpan">(_response, ssl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http.normalizeRequest">
            function <span class="apidocSignatureSpan">q-io.http.</span>normalizeRequest
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http.normalizeResponse">
            function <span class="apidocSignatureSpan">q-io.http.</span>normalizeResponse
            <span class="apidocSignatureSpan">(response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http.read">
            function <span class="apidocSignatureSpan">q-io.http.</span>read
            <span class="apidocSignatureSpan">(request, qualifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http.request">
            function <span class="apidocSignatureSpan">q-io.http.</span>request
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.http_apps">module q-io.http_apps</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Branch">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Branch
            <span class="apidocSignatureSpan">(paths, notFound)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Cap">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Cap
            <span class="apidocSignatureSpan">(app, notFound)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Chain">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Chain
            <span class="apidocSignatureSpan">(end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Charset">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Charset
            <span class="apidocSignatureSpan">(types, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Content">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Content
            <span class="apidocSignatureSpan">(body, contentType, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.ContentRequest">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>ContentRequest
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.ContentType">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>ContentType
            <span class="apidocSignatureSpan">(types, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.CookieJar">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>CookieJar
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Date">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Date
            <span class="apidocSignatureSpan">(app, present)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Debug">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Debug
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Decorators">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Decorators
            <span class="apidocSignatureSpan">(decorators, app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.DirectoryIndex">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>DirectoryIndex
            <span class="apidocSignatureSpan">(app, indexFile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Encoding">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Encoding
            <span class="apidocSignatureSpan">(types, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Error">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Error
            <span class="apidocSignatureSpan">(app, debug)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.File">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>File
            <span class="apidocSignatureSpan">(path, contentType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.FileTree">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>FileTree
            <span class="apidocSignatureSpan">(root, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.HandleHtmlFragmentResponses">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>HandleHtmlFragmentResponses
            <span class="apidocSignatureSpan">(app, handleHtmlFragmentResponse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.HandleJsonResponses">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>HandleJsonResponses
            <span class="apidocSignatureSpan">(app, reviver, tab)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Headers">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Headers
            <span class="apidocSignatureSpan">(app, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Host">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Host
            <span class="apidocSignatureSpan">(appForHost, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Inspect">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Inspect
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Json">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Json
            <span class="apidocSignatureSpan">(app, reviver, tabs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.JsonRequest">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>JsonRequest
            <span class="apidocSignatureSpan">(app, badRequest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Language">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Language
            <span class="apidocSignatureSpan">(types, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.ListDirectories">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>ListDirectories
            <span class="apidocSignatureSpan">(app, listDirectory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Log">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Log
            <span class="apidocSignatureSpan">(app, log, stamp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Method">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Method
            <span class="apidocSignatureSpan">(methods, methodNotAllowed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Normalize">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Normalize
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.ParseQuery">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>ParseQuery
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Permanent">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Permanent
            <span class="apidocSignatureSpan">(app, future)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.PermanentRedirect">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>PermanentRedirect
            <span class="apidocSignatureSpan">(location, status, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.PermanentRedirectTree">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>PermanentRedirectTree
            <span class="apidocSignatureSpan">(location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Proxy">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Proxy
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.ProxyTree">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>ProxyTree
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Redirect">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Redirect
            <span class="apidocSignatureSpan">(location, status, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.RedirectTrap">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>RedirectTrap
            <span class="apidocSignatureSpan">(app, maxRedirects)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.RedirectTree">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>RedirectTree
            <span class="apidocSignatureSpan">(location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Select">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Select
            <span class="apidocSignatureSpan">(select)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Tap">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Tap
            <span class="apidocSignatureSpan">(app, tap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.TemporaryRedirect">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>TemporaryRedirect
            <span class="apidocSignatureSpan">(location, status, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.TemporaryRedirectTree">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>TemporaryRedirectTree
            <span class="apidocSignatureSpan">(location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Time">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Time
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.Trap">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>Trap
            <span class="apidocSignatureSpan">(app, trap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.appForStatus">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>appForStatus
            <span class="apidocSignatureSpan">(status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.badRequest">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>badRequest
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.content">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>content
            <span class="apidocSignatureSpan">(content, contentType, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.directory">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>directory
            <span class="apidocSignatureSpan">(request, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.escapeHtml">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>escapeHtml
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.etag">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>etag
            <span class="apidocSignatureSpan">(stat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.file">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>file
            <span class="apidocSignatureSpan">(request, path, contentType, fs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.handleHtmlFragmentResponse">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>handleHtmlFragmentResponse
            <span class="apidocSignatureSpan">(response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.handleJsonResponse">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>handleJsonResponse
            <span class="apidocSignatureSpan">(response, revivier, tab)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.htmlResponseForStatus">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>htmlResponseForStatus
            <span class="apidocSignatureSpan">(request, status, message, addendum)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.isRedirect">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>isRedirect
            <span class="apidocSignatureSpan">(response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.json">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>json
            <span class="apidocSignatureSpan">(content, reviver, tabs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.listDirectory">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectory
            <span class="apidocSignatureSpan">(request, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.listDirectoryData">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryData
            <span class="apidocSignatureSpan">(request, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.listDirectoryHtmlFragment">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryHtmlFragment
            <span class="apidocSignatureSpan">(request, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.listDirectoryJson">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryJson
            <span class="apidocSignatureSpan">(request, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.listDirectoryMarkdown">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryMarkdown
            <span class="apidocSignatureSpan">(request, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.listDirectoryText">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryText
            <span class="apidocSignatureSpan">(request, response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.methodNotAllowed">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>methodNotAllowed
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.negotiate">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>negotiate
            <span class="apidocSignatureSpan">(request, types, header)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.noLanguage">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>noLanguage
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.notAcceptable">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>notAcceptable
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.notFound">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>notFound
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.ok">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>ok
            <span class="apidocSignatureSpan">(content, contentType, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.permanentRedirect">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>permanentRedirect
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.permanentRedirectTree">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>permanentRedirectTree
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.redirect">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>redirect
            <span class="apidocSignatureSpan">(request, location, status, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.redirectHtml">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>redirectHtml
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.redirectText">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>redirectText
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.redirectTree">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>redirectTree
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.responseForStatus">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>responseForStatus
            <span class="apidocSignatureSpan">(request, status, addendum)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.statusWithNoEntityBody">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>statusWithNoEntityBody
            <span class="apidocSignatureSpan">(status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.temporaryRedirect">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>temporaryRedirect
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.temporaryRedirectTree">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>temporaryRedirectTree
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_apps.textResponseForStatus">
            function <span class="apidocSignatureSpan">q-io.http_apps.</span>textResponseForStatus
            <span class="apidocSignatureSpan">(request, status, message, addendum)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.http_apps.</span>statusCodes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.http_apps.</span>statusMessages</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.http_cookie">module q-io.http_cookie</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_cookie.parse">
            function <span class="apidocSignatureSpan">q-io.http_cookie.</span>parse
            <span class="apidocSignatureSpan">(cookie, date)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.http_cookie.stringify">
            function <span class="apidocSignatureSpan">q-io.http_cookie.</span>stringify
            <span class="apidocSignatureSpan">(key, value, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.json">module q-io.json</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.json.json">
            function <span class="apidocSignatureSpan">q-io.</span>json
            <span class="apidocSignatureSpan">(content, reviver, tabs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.json.HandleJsonResponses">
            function <span class="apidocSignatureSpan">q-io.json.</span>HandleJsonResponses
            <span class="apidocSignatureSpan">(app, reviver, tab)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.json.Json">
            function <span class="apidocSignatureSpan">q-io.json.</span>Json
            <span class="apidocSignatureSpan">(app, reviver, tabs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.json.JsonRequest">
            function <span class="apidocSignatureSpan">q-io.json.</span>JsonRequest
            <span class="apidocSignatureSpan">(app, badRequest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.json.handleJsonResponse">
            function <span class="apidocSignatureSpan">q-io.json.</span>handleJsonResponse
            <span class="apidocSignatureSpan">(response, revivier, tab)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.negotiate">module q-io.negotiate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.negotiate.negotiate">
            function <span class="apidocSignatureSpan">q-io.</span>negotiate
            <span class="apidocSignatureSpan">(request, types, header)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.negotiate.Charset">
            function <span class="apidocSignatureSpan">q-io.negotiate.</span>Charset
            <span class="apidocSignatureSpan">(types, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.negotiate.ContentType">
            function <span class="apidocSignatureSpan">q-io.negotiate.</span>ContentType
            <span class="apidocSignatureSpan">(types, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.negotiate.Encoding">
            function <span class="apidocSignatureSpan">q-io.negotiate.</span>Encoding
            <span class="apidocSignatureSpan">(types, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.negotiate.Host">
            function <span class="apidocSignatureSpan">q-io.negotiate.</span>Host
            <span class="apidocSignatureSpan">(appForHost, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.negotiate.Language">
            function <span class="apidocSignatureSpan">q-io.negotiate.</span>Language
            <span class="apidocSignatureSpan">(types, notAcceptable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.negotiate.Method">
            function <span class="apidocSignatureSpan">q-io.negotiate.</span>Method
            <span class="apidocSignatureSpan">(methods, methodNotAllowed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.negotiate.Select">
            function <span class="apidocSignatureSpan">q-io.negotiate.</span>Select
            <span class="apidocSignatureSpan">(select)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.proxy">module q-io.proxy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.proxy.Proxy">
            function <span class="apidocSignatureSpan">q-io.proxy.</span>Proxy
            <span class="apidocSignatureSpan">(app)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.proxy.ProxyTree">
            function <span class="apidocSignatureSpan">q-io.proxy.</span>ProxyTree
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.reader">module q-io.reader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.reader.reader">
            function <span class="apidocSignatureSpan">q-io.</span>reader
            <span class="apidocSignatureSpan">(_stream, charset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.reader.join">
            function <span class="apidocSignatureSpan">q-io.reader.</span>join
            <span class="apidocSignatureSpan">(buffers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.reader.read">
            function <span class="apidocSignatureSpan">q-io.reader.</span>read
            <span class="apidocSignatureSpan">(stream, charset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.redirect">module q-io.redirect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.redirect">
            function <span class="apidocSignatureSpan">q-io.</span>redirect
            <span class="apidocSignatureSpan">(request, location, status, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.PermanentRedirect">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>PermanentRedirect
            <span class="apidocSignatureSpan">(location, status, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.PermanentRedirectTree">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>PermanentRedirectTree
            <span class="apidocSignatureSpan">(location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.Redirect">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>Redirect
            <span class="apidocSignatureSpan">(location, status, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.RedirectTrap">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>RedirectTrap
            <span class="apidocSignatureSpan">(app, maxRedirects)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.RedirectTree">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>RedirectTree
            <span class="apidocSignatureSpan">(location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.TemporaryRedirect">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>TemporaryRedirect
            <span class="apidocSignatureSpan">(location, status, tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.TemporaryRedirectTree">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>TemporaryRedirectTree
            <span class="apidocSignatureSpan">(location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.isRedirect">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>isRedirect
            <span class="apidocSignatureSpan">(response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.permanentRedirect">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>permanentRedirect
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.permanentRedirectTree">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>permanentRedirectTree
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.redirectHtml">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>redirectHtml
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.redirectText">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>redirectText
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.redirectTree">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>redirectTree
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.temporaryRedirect">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>temporaryRedirect
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.redirect.temporaryRedirectTree">
            function <span class="apidocSignatureSpan">q-io.redirect.</span>temporaryRedirectTree
            <span class="apidocSignatureSpan">(request, location, status)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.route">module q-io.route</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.route.Branch">
            function <span class="apidocSignatureSpan">q-io.route.</span>Branch
            <span class="apidocSignatureSpan">(paths, notFound)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.route.Cap">
            function <span class="apidocSignatureSpan">q-io.route.</span>Cap
            <span class="apidocSignatureSpan">(app, notFound)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.route.FirstFound">
            function <span class="apidocSignatureSpan">q-io.route.</span>FirstFound
            <span class="apidocSignatureSpan">(cascade)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.route.Tap">
            function <span class="apidocSignatureSpan">q-io.route.</span>Tap
            <span class="apidocSignatureSpan">(app, tap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.route.Trap">
            function <span class="apidocSignatureSpan">q-io.route.</span>Trap
            <span class="apidocSignatureSpan">(app, trap)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.q-io.status">module q-io.status</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.appForStatus">
            function <span class="apidocSignatureSpan">q-io.status.</span>appForStatus
            <span class="apidocSignatureSpan">(status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.badRequest">
            function <span class="apidocSignatureSpan">q-io.status.</span>badRequest
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.htmlResponseForStatus">
            function <span class="apidocSignatureSpan">q-io.status.</span>htmlResponseForStatus
            <span class="apidocSignatureSpan">(request, status, message, addendum)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.methodNotAllowed">
            function <span class="apidocSignatureSpan">q-io.status.</span>methodNotAllowed
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.noLanguage">
            function <span class="apidocSignatureSpan">q-io.status.</span>noLanguage
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.notAcceptable">
            function <span class="apidocSignatureSpan">q-io.status.</span>notAcceptable
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.notFound">
            function <span class="apidocSignatureSpan">q-io.status.</span>notFound
            <span class="apidocSignatureSpan">(request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.responseForStatus">
            function <span class="apidocSignatureSpan">q-io.status.</span>responseForStatus
            <span class="apidocSignatureSpan">(request, status, addendum)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.statusWithNoEntityBody">
            function <span class="apidocSignatureSpan">q-io.status.</span>statusWithNoEntityBody
            <span class="apidocSignatureSpan">(status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.q-io.status.textResponseForStatus">
            function <span class="apidocSignatureSpan">q-io.status.</span>textResponseForStatus
            <span class="apidocSignatureSpan">(request, status, message, addendum)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.status.</span>statusCodes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">q-io.status.</span>statusMessages</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io" id="apidoc.module.q-io">module q-io</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.buffer_stream" id="apidoc.element.q-io.buffer_stream">
        function <span class="apidocSignatureSpan">q-io.</span>buffer_stream
        <span class="apidocSignatureSpan">(chunks, charset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BufferStream(chunks, charset) {
    if (!(this instanceof BufferStream)) {
        return new BufferStream(chunks, charset);
    }
    if (!chunks) {
        chunks = [];
    } else if (!Array.isArray(chunks)) {
        chunks = [chunks];
    }
    this._charset = charset;
    this._chunks = chunks;
    this._close = Q.defer();
    this.closed = this._close.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.chain" id="apidoc.element.q-io.chain">
        function <span class="apidocSignatureSpan">q-io.</span>chain
        <span class="apidocSignatureSpan">(end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(end) {
    var self = Object.create(Chain.prototype);
    self.end = end || function (next) {
        return next;
    };
    return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.reader" id="apidoc.element.q-io.reader">
        function <span class="apidocSignatureSpan">q-io.</span>reader
        <span class="apidocSignatureSpan">(_stream, charset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(_stream, charset) {
    var self = Object.create(Reader.prototype);

    if (charset &amp;&amp; _stream.setEncoding) // TODO complain about inconsistency
        _stream.setEncoding(charset);

    var begin = Q.defer();
    var end = Q.defer();

    _stream.on("error", function (reason) {
        begin.reject(reason);
    });

    var chunks = [];
    var receiver;

    _stream.on("end", function () {
        begin.resolve(self);
        end.resolve()
    });

    _stream.on("data", function (chunk) {
        begin.resolve(self);
        if (receiver) {
            receiver(chunk);
        } else {
            chunks.push(chunk);
        }
    });

    function slurp() {
        var result;
        if (charset) {
            result = chunks.join("");
        } else {
            result = self.constructor.join(chunks);
        }
        chunks.splice(0, chunks.length);
        return result;
    }

<span class="apidocCodeCommentSpan">    /***
     * Reads all of the remaining data from the stream.
     * @returns {Promise * String} a promise for a String
     * containing the entirety the remaining stream.
     */
</span>    self.read = function () {
        receiver = undefined;
        var deferred = Q.defer();
        Q.done(end.promise, function () {
            deferred.resolve(slurp());
        });
        return deferred.promise;
    };

    /***
     * Reads and writes all of the remaining data from the
     * stream in chunks.
     * @param {Function(Promise * String)} write a function
     * to be called on each chunk of input from this stream.
     * @returns {Promise * Undefined} a promise that will
     * be resolved when the input is depleted.
     */
    self.forEach = function (write) {
        if (chunks &amp;&amp; chunks.length)
            write(slurp());
        receiver = write;
        return Q.when(end.promise, function () {
            receiver = undefined;
        });
    };

    self.close = function () {
        _stream.destroy();
    };

    self.node = _stream;

    return begin.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.buffer_stream" id="apidoc.module.q-io.buffer_stream">module q-io.buffer_stream</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.buffer_stream.buffer_stream" id="apidoc.element.q-io.buffer_stream.buffer_stream">
        function <span class="apidocSignatureSpan">q-io.</span>buffer_stream
        <span class="apidocSignatureSpan">(chunks, charset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BufferStream(chunks, charset) {
    if (!(this instanceof BufferStream)) {
        return new BufferStream(chunks, charset);
    }
    if (!chunks) {
        chunks = [];
    } else if (!Array.isArray(chunks)) {
        chunks = [chunks];
    }
    this._charset = charset;
    this._chunks = chunks;
    this._close = Q.defer();
    this.closed = this._close.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.buffer_stream.prototype" id="apidoc.module.q-io.buffer_stream.prototype">module q-io.buffer_stream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.buffer_stream.prototype.close" id="apidoc.element.q-io.buffer_stream.prototype.close">
        function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () {
    this._close.resolve();
    return Q.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    } else if (content instanceof Buffer) {
        flags += "b";
    }
    options.flags = flags;
    return Q.when(self.open(path, options), function (stream) {
        return Q.when(stream.write(content), function () {
            return stream.<span class="apidocCodeKeywordSpan">close</span>();
        });
    });
};

/**
 * Append content to the end of a file.
 * @param {String} path    Path to the file.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.buffer_stream.prototype.destroy" id="apidoc.element.q-io.buffer_stream.prototype.destroy">
        function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
    this._close.resolve();
    return Q.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        receiver = write;
        return Q.when(end.promise, function () {
            receiver = undefined;
        });
    };

    self.close = function () {
        _stream.<span class="apidocCodeKeywordSpan">destroy</span>();
    };

    self.node = _stream;

    return begin.promise;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.buffer_stream.prototype.forEach" id="apidoc.element.q-io.buffer_stream.prototype.forEach">
        function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>forEach
        <span class="apidocSignatureSpan">(write, thisp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (write, thisp) {
    var self = this;
    var chunks = self._chunks;
    return Q.fcall(function () {
        chunks.splice(0, chunks.length).forEach(write, thisp);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.closed = this._close.promise;
}

BufferStream.prototype.forEach = function (write, thisp) {
var self = this;
var chunks = self._chunks;
return Q.fcall(function () {
    chunks.splice(0, chunks.length).<span class="apidocCodeKeywordSpan">forEach</span>(write, thisp);
});
};

BufferStream.prototype.read = function () {
var result;
result = Reader.join(this._chunks);
if (this._charset) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.buffer_stream.prototype.read" id="apidoc.element.q-io.buffer_stream.prototype.read">
        function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function () {
    var result;
    result = Reader.join(this._chunks);
    if (this._charset) {
        result = result.toString(this._charset);
    }
    return Q.resolve(result);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
into memory.  It returns a promise for the whole file contents.  By
default, `read` provides a string decoded from UTF-8.  With the bytewise
mode flag, provides a `Buffer`.

The options argument is identical to that of `open`.

```javascript
return FS.<span class="apidocCodeKeywordSpan">read</span>(__filename, "b")
.then(function (content) {
    // ...
})
```

```javascript
return FS.read(__filename, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.buffer_stream.prototype.write" id="apidoc.element.q-io.buffer_stream.prototype.write">
        function <span class="apidocSignatureSpan">q-io.buffer_stream.prototype.</span>write
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (chunk) {
    if (this._charset) {
        chunk = new Buffer(String(chunk), this._charset);
    } else {
        if (!(chunk instanceof Buffer)) {
            throw new Error("Can't write strings to buffer stream without a charset: " + chunk);
        }
    }
    this._chunks.push(chunk);
    return Q.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`write` is a shortcut for opening a file and writing its entire content
from a single string or buffer.

The options are identical to that of `open`, but the "w" flag is
implied, and the "b" flag is implied if the content is a buffer.

```javascript
return FS.<span class="apidocCodeKeywordSpan">write</span>("hello.txt", "Hello, World!\n")
.then(function () {
    return FS.read("hello.txt")
})
.then(function (hello) {
    expect(hello).toBe("Hello, World!\n")
})
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.chain" id="apidoc.module.q-io.chain">module q-io.chain</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.chain.chain" id="apidoc.element.q-io.chain.chain">
        function <span class="apidocSignatureSpan">q-io.</span>chain
        <span class="apidocSignatureSpan">(end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(end) {
    var self = Object.create(Chain.prototype);
    self.end = end || function (next) {
        return next;
    };
    return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.chain.prototype" id="apidoc.module.q-io.chain.prototype">module q-io.chain.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.chain.prototype.use" id="apidoc.element.q-io.chain.prototype.use">
        function <span class="apidocSignatureSpan">q-io.chain.prototype.</span>use
        <span class="apidocSignatureSpan">(App)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">use = function (App) {
    if (!App) throw new Error("App is not defined after " + this.app);
    var args = Array.prototype.slice.call(arguments, 1);
    var self = this;
    this.end = (function (End) {
        return function Self(next) {
            if (self.end !== Self &amp;&amp; !next) throw new Error("App chain is broken after " + App);
            return End(App.apply(null, [next].concat(args)));
        };
    })(this.end);
    this.app = App;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.content" id="apidoc.module.q-io.content">module q-io.content</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.content.content" id="apidoc.element.q-io.content.content">
        function <span class="apidocSignatureSpan">q-io.</span>content
        <span class="apidocSignatureSpan">(content, contentType, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">content = function (content, contentType, status) {
    status = status || 200;
    content = content || "";
    if (typeof content === "string") {
        content = [content];
    }
    contentType = contentType || "text/plain";
    return {
        "status": status,
        "headers": {
            "content-type": contentType
        },
        "body": content
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* response body
* @param {String} contentType
* @param {Number} status
* @returns {App} a Q-JSGI app
*/
exports.Content = function (body, contentType, status) {
   return function () {
       return exports.<span class="apidocCodeKeywordSpan">content</span>(body, contentType, status);
   };
};

/**
* Returns a Q-JSGI response with the given content.
* @param {Body} content (optional) defaults to `[""]`
* @param {String} contentType (optional) defaults to `"text/plain"`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.content.Content" id="apidoc.element.q-io.content.Content">
        function <span class="apidocSignatureSpan">q-io.content.</span>Content
        <span class="apidocSignatureSpan">(body, contentType, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Content = function (body, contentType, status) {
    return function () {
        return exports.content(body, contentType, status);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.content.ContentRequest" id="apidoc.element.q-io.content.ContentRequest">
        function <span class="apidocSignatureSpan">q-io.content.</span>ContentRequest
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ContentRequest = function (app) {
    return function (request, response) {
        return Q.when(request.body.read(), function (body) {
            return app(body, request, response);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function(Request, Object):Response} app
 * @param {App} badRequest
 * @returns {App}
 */
exports.JsonRequest = function (app, badRequest) {
if (!badRequest)
    badRequest = Status.badRequest;
return Content.<span class="apidocCodeKeywordSpan">ContentRequest</span>(function (content, request, response) {
    try {
        var object = JSON.parse(content);
    } catch (error) {
        return badRequest(request, error);
    }
    return app(object, request, response);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.content.Inspect" id="apidoc.element.q-io.content.Inspect">
        function <span class="apidocSignatureSpan">q-io.content.</span>Inspect
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Inspect = function (app) {
    return Negotiate.Method({"GET": function (request, response) {
        return Q.when(app(request, response), function (object) {
            return {
                status: 200,
                headers: {
                    "content-type": "text/plain"
                },
                body: [inspect(object)]
            }
        });
    }});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.content.ParseQuery" id="apidoc.element.q-io.content.ParseQuery">
        function <span class="apidocSignatureSpan">q-io.content.</span>ParseQuery
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ParseQuery = function (app) {
    return function (request, response) {
        request.query = QS.parse(URL.parse(request.url).query || "");
        return app(request, response);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.content.ok" id="apidoc.element.q-io.content.ok">
        function <span class="apidocSignatureSpan">q-io.content.</span>ok
        <span class="apidocSignatureSpan">(content, contentType, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ok = function (content, contentType, status) {
    status = status || 200;
    content = content || "";
    if (typeof content === "string") {
        content = [content];
    }
    contentType = contentType || "text/plain";
    return {
        "status": status,
        "headers": {
            "content-type": contentType
        },
        "body": content
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
exports.json = function (content, reviver, tabs) {
   try {
       var json = JSON.stringify(content, reviver, tabs);
   } catch (exception) {
       return Q.reject(exception);
   }
   return Content.<span class="apidocCodeKeywordSpan">ok</span>([json], "application/json");
};

/**
* @param {Function(Request, Object):Response} app
* @param {App} badRequest
* @returns {App}
*/
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.cookie" id="apidoc.module.q-io.cookie">module q-io.cookie</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.cookie.CookieJar" id="apidoc.element.q-io.cookie.CookieJar">
        function <span class="apidocSignatureSpan">q-io.cookie.</span>CookieJar
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CookieJar = function (app) {
    var hostCookies = {}; // to {} of pathCookies to [] of cookies
    return function (request) {

        if (!request.headers.host) {
            throw new Error("Requests must have a host header");
        }
        var hosts = allHostsContaining(request.headers.host);

        var now = new Date();

        // delete expired cookies
        for (var host in hostCookies) {
            var pathCookies = hostCookies[host];
            for (var path in pathCookies) {
                var cookies = pathCookies[path];
                for (var name in cookies) {
                    var cookie = cookies[name];
                    if (cookie.expires &amp;&amp; cookie.expires &gt; now) {
                        delete cookie[name];
                    }
                }
            }
        }

        // collect applicable cookies
        var requestCookies = concat(
            Object.keys(hostCookies)
            .map(function (host) {
                if (!hostContains(host, request.headers.host)) {
                    return [];
                }
                var pathCookies = hostCookies[host];
                return concat(
                    Object.keys(pathCookies)
                    .map(function (path) {
                        if (!pathContains(path, request.path))
                            return [];
                        var cookies = pathCookies[path];
                        return (
                            Object.keys(cookies)
                            .map(function (name) {
                                return cookies[name];
                            })
                            .filter(function (cookie) {
                                return cookie.secure ?
                                    request.ssl :
                                    true;
                            })
                        );
                    })
                )
            })
        );

        if (requestCookies.length) {
            request.headers["cookie"] = (
                requestCookies
                .map(function (cookie) {
                    return Cookie.stringify(
                        cookie.key,
                        cookie.value
                    );
                })
                .join("; ")
            );
        }

        return Q.when(app.apply(this, arguments), function (response) {
            response.headers = response.headers || {};
            if (response.headers["set-cookie"]) {
                var host = request.headers.host;
                var hostParts = splitHost(host);
                var hostname = hostParts[0];
                var requestHost = ipRe.test(hostname) ? host : "." + host;
                // normalize to array
                if (!Array.isArray(response.headers["set-cookie"])) {
                    response.headers["set-cookie"] = [response.headers["set-cookie"]];
                }
                response.headers["set-cookie"].forEach(function (cookie) {
                    var date = response.headers["date"] ?
                        new Date(response.headers["date"]) :
                        new Date();
                    cookie = Cookie.parse(cookie, date);
                    // ignore illegal host
                    if (cookie.host &amp;&amp; !hostContains(requestHost, cookie.host))
                        delete cookie.host;
                    var host = requestHost || cookie.host;
                    var path = cookie.path || "/";
                    var pathCookies = hostCookies[host] = hostCookies[host] || {};
                    var cookies = pathCookies[path] = pathCookies[path] || {};
                    cookies[cookie.key] = cookie;
                })
                delete response.headers["set-cookie"];
            }

            return response;
        });

    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.decorators" id="apidoc.module.q-io.decorators">module q-io.decorators</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.decorators.Date" id="apidoc.element.q-io.decorators.Date">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Date
        <span class="apidocSignatureSpan">(app, present)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Date = function (app, present) {
    present = present || function () {
        return new Date();
    };
    return RouteApps.Trap(app, function (response, request) {
        response.headers["date"] = "" + present();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.decorators.Debug" id="apidoc.element.q-io.decorators.Debug">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Debug
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Debug = function (app) {
    return exports.Error(app, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.decorators.Decorators" id="apidoc.element.q-io.decorators.Decorators">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Decorators
        <span class="apidocSignatureSpan">(decorators, app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Decorators = function (decorators, app) {
    decorators.reversed().forEach(function (Middleware) {
        app = Middleware(app);
    });
    return app;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.decorators.Error" id="apidoc.element.q-io.decorators.Error">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Error
        <span class="apidocSignatureSpan">(app, debug)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error = function (app, debug) {
    return function (request, response) {
        return Q.when(app(request, response), null, function (error) {
            if (!debug)
                error = undefined;
            return StatusApps.responseForStatus(request, 500, error &amp;&amp; error.stack || error);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
               error = undefined;
           return StatusApps.responseForStatus(request, 500, error &amp;&amp; error.stack || error);
       });
   };
};

exports.Debug = function (app) {
   return exports.<span class="apidocCodeKeywordSpan">Error</span>(app, true);
};

/**
* Decorates a Q-JSGI application such that all requests and responses
* are logged.
*
* @param {App} app
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.decorators.Headers" id="apidoc.element.q-io.decorators.Headers">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Headers
        <span class="apidocSignatureSpan">(app, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Headers = function (app, headers) {
    return function (request, response) {
        return Q.when(app(request, response), function (response) {
            if (response &amp;&amp; response.headers) {
                Object.keys(headers).forEach(function (key) {
                    if (!(key in response.headers)) {
                        response.headers[key] = headers[key];
                    }
                });
            }
            return response;
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.decorators.Log" id="apidoc.element.q-io.decorators.Log">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Log
        <span class="apidocSignatureSpan">(app, log, stamp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Log = function (app, log, stamp) {
    log = log || console.log;
    stamp = stamp || function (message) {
        return new Date().toISOString() + " " + message;
    };
    return function (request, response) {
        var remoteHost =
            request.remoteHost + ":" +
            request.remotePort;
        var requestLine =
            request.method + " " +
            request.path + " " +
            "HTTP/" + request.version.join(".");
        log(stamp(
            remoteHost + " " +
            "--&gt;     " +
            requestLine
        ));
        return Q.when(app(request, response), function (response) {
            if (response) {
                log(stamp(
                    remoteHost + " " +
                    "&lt;== " +
                    response.status + " " +
                    requestLine + " " +
                    (response.headers["content-length"] || "-")
                ));
            } else {
                log(stamp(
                    remoteHost + " " +
                    "... " +
                    "... " +
                    requestLine + " (response undefined / presumed streaming)"
                ));
            }
            return response;
        }, function (reason) {
            log(stamp(
                remoteHost + " " +
                "!!!     " +
                requestLine + " " +
                (reason &amp;&amp; reason.message || reason)
            ));
            return Q.reject(reason);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.decorators.Normalize" id="apidoc.element.q-io.decorators.Normalize">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Normalize
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Normalize = function (app) {
    return function (request, response) {
        var request = HTTP.normalizeRequest(request);
        return Q.when(app(request, response), function (response) {
            return HTTP.normalizeResponse(response);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.decorators.Permanent" id="apidoc.element.q-io.decorators.Permanent">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Permanent
        <span class="apidocSignatureSpan">(app, future)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Permanent = function (app, future) {
    future = future || function () {
        return new Date(new Date().getTime() + farFuture);
    };
    app = RouteApps.Tap(app, function (request, response) {
        request.permanent = future;
    });
    app = RouteApps.Trap(app, function (response, request) {
        response.headers["expires"] = "" + future();
    });
    return app;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.decorators.Time" id="apidoc.element.q-io.decorators.Time">
        function <span class="apidocSignatureSpan">q-io.decorators.</span>Time
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Time = function (app) {
    return function (request, response) {
        var start = new Date();
        return Q.when(app(request, response), function (response) {
            var stop = new Date();
            if (response &amp;&amp; response.headers) {
                response.headers["x-response-time"] = "" + (stop - start);
            }
            return response;
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.deprecate" id="apidoc.module.q-io.deprecate">module q-io.deprecate</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.deprecate.deprecateMethod" id="apidoc.element.q-io.deprecate.deprecateMethod">
        function <span class="apidocSignatureSpan">q-io.deprecate.</span>deprecateMethod
        <span class="apidocSignatureSpan">(scope, deprecatedFunction, name, alternative)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecate(scope, deprecatedFunction, name, alternative) {
    var deprecationWrapper = function () {
        // stackTraceLimit = 3 // deprecationWarning + deprecate + caller of the deprecated method
        deprecationWarning(name, alternative, 3);
        return deprecatedFunction.apply(scope ? scope : this, arguments);
    };
    deprecationWrapper.deprecatedFunction = deprecatedFunction;
    return deprecationWrapper;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.deprecate.deprecationWarning" id="apidoc.element.q-io.deprecate.deprecationWarning">
        function <span class="apidocSignatureSpan">q-io.deprecate.</span>deprecationWarning
        <span class="apidocSignatureSpan">(name, alternative, stackTraceLimit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecationWarning(name, alternative, stackTraceLimit) {
    if (stackTraceLimit) {
        var depth = Error.stackTraceLimit;
        Error.stackTraceLimit = stackTraceLimit;
    }
    if (typeof console !== "undefined" &amp;&amp; typeof console.warn === "function") {
        var stack = (stackTraceLimit ? new Error("").stack : "") ;
        if(alternative) {
            console.warn(name + " is deprecated, use " + alternative + " instead.", stack);
        } else {
            //name is a complete message
            console.warn(name, stack);
        }
    }
    if (stackTraceLimit) {
        Error.stackTraceLimit = depth;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.fs" id="apidoc.module.q-io.fs">module q-io.fs</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.fs.Mock" id="apidoc.element.q-io.fs.Mock">
        function <span class="apidocSignatureSpan">q-io.fs.</span>Mock
        <span class="apidocSignatureSpan">(files, workingDirectory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MockFs(files, workingDirectory) {
    if (!(this instanceof MockFs)) {
        return new MockFs(files, workingDirectory);
    }
    this._root = new DirectoryNode(this, "/");

    function init() {
        // construct a file tree
    }

    Common.update(this, function () {
        return workingDirectory;
    });

    workingDirectory = workingDirectory || this.ROOT;
    if (files) {
        this._init(files);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.Root" id="apidoc.element.q-io.fs.Root">
        function <span class="apidocSignatureSpan">q-io.fs.</span>Root
        <span class="apidocSignatureSpan">(outer, root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RootFs(outer, root) {
    var inner = Object.create(BOOT);

    function attenuate(path) {

        // the machinations of projecting a path inside a
        // subroot
        var actual;
        // if it's absolute, we want the path relative to
        // the root of the inner file system
        if (outer.isAbsolute(path)) {
            actual = outer.relativeFromDirectory(outer.ROOT, path);
        } else {
            actual = path;
        }
        // we join the path onto the root of the inner file
        // system so that parent references from the root
        // return to the root, emulating standard unix
        // behavior
        actual = outer.join(outer.ROOT, actual);
        // then we reconstruct the path relative to the
        // inner root
        actual = outer.relativeFromDirectory(outer.ROOT, actual);
        // and rejoin it on the outer root
        actual = outer.join(root, actual);
        // and find the corresponding real path
        return outer.canonical(actual)
        .then(function (actual) {
            return actual;
        }, function () {
            return actual;
        }).then(function (actual) {
            // and verify that the outer canonical path is
            // actually inside the inner canonical path, to
            // prevent break-outs
            if (outer.contains(root, actual)) {
                return {
                    "inner": outer.join(outer.ROOT, outer.relativeFromDirectory(root, actual)),
                    "outer": actual
                };
            } else {
                return Q.reject("Can't find: " + JSON.stringify(path));
            }
        });
    }

    function workingDirectory() {
        return outer.ROOT;
    }

    COMMON.update(inner, workingDirectory);

    inner.list = function (path) {
        return attenuate(path).then(function (path) {
            return outer.list(path.outer);
        }).then(null, function (reason) {
            return Q.reject("Can't list " + JSON.stringify(path));
        });
    };

    inner.open = function (path, flags, charset) {
        return attenuate(path).then(function (path) {
            return outer.open(path.outer, flags, charset);
        }).then(null, function (reason) {
            return Q.reject("Can't open " + JSON.stringify(path));
        });
    };

    inner.stat = function (path) {
        return attenuate(path).then(function (path) {
            return outer.stat(path.outer);
        }).then(null, function (reason) {
            return Q.reject("Can't stat " + JSON.stringify(path));
        });
    };

    inner.statLink = function (path) {
        return attenuate(path).then(function (path) {
            return outer.statLink(path.outer);
        }).then(null, function (reason) {
            return Q.reject("Can't statLink " + JSON.stringify(path));
        });
    };

    inner.canonical = function (path) {
        return attenuate(path).then(function (path) {
            return path.inner;
        }).then(null, function (reason) {
            return Q.reject("Can't find canonical of " + JSON.stringify(path));
        });
    };

    inner.makeDirectory = function (path) {
        return attenuate(path).then(function (path) {
            return outer.makeDirectory(path.outer);
        }).catch(function (error) {
            throw new Error("Can't make directory " + JSON.stringify(path));
        });
    };

    inner.removeDirectory = function (path) {
        return attenuate(path).then(function (path) {
            return outer.removeDirectory(path.outer);
        }).catch(function (error) {
            throw new Error("Can't remove directory " + JSON.stringify(path));
        });
    };

    inner.remove = function (path) {
        return attenuate(path).then(function (path) {
            return outer.remove(path.outer);
        }).catch(function (error) {
            throw new Error("Can't remove " + JSON.stringify(path));
        });
    };

    inner.makeTree = function (path) {
        return attenuate(path).then(function (path) {
            return outer.makeT ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.SEPARATORS_RE" id="apidoc.element.q-io.fs.SEPARATORS_RE">
        function <span class="apidocSignatureSpan">q-io.fs.</span>SEPARATORS_RE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SEPARATORS_RE = function () {
    if (
        separatorCached !== exports.SEPARATOR ||
        altSeparatorCached !== exports.ALT_SEPARATOR
    ) {
        separatorCached = exports.SEPARATOR;
        altSeparatorCached = exports.ALT_SEPARATOR;
        separatorReCached = new RegExp("[" +
            (separatorCached || "").replace(/[-[\]{}()*+?.\\^$|,#\s]/g, "\\$&amp;") +
            (altSeparatorCached || "").replace(/[-[\]{}()*+?.\\^$|,#\s]/g, "\\$&amp;") +
        "]", "g");
    }
    return separatorReCached;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * file system, indicated by an empty string on Unix, and a
 * drive letter followed by a colon on Windows.
 * @returns {Array * String}
 */
exports.split = function (path) {
var parts;
try {
    parts = String(path).split(exports.<span class="apidocCodeKeywordSpan">SEPARATORS_RE</span>());
} catch (exception) {
    throw new Error("Cannot split " + (typeof path) + ", " + JSON.stringify(path));
}
// this special case helps isAbsolute
// distinguish an empty path from an absolute path
// "" -&gt; [] NOT [""]
if (parts.length === 1 &amp;&amp; parts[0] === "")
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.Stats" id="apidoc.element.q-io.fs.Stats">
        function <span class="apidocSignatureSpan">q-io.fs.</span>Stats
        <span class="apidocSignatureSpan">(nodeStat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stats(nodeStat) {
    this.node = nodeStat;
    this.size = nodeStat.size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var done = Q.defer();
    try {
        FS.stat(path, function (error, stat) {
            if (error) {
                error.message = "Can't stat " + JSON.stringify(path) + ": " + error;
                done.reject(error);
            } else {
                done.resolve(new self.<span class="apidocCodeKeywordSpan">Stats</span>(stat));
            }
        });
    } catch (error) {
        done.reject(error);
    }
    return done.promise;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.absolute" id="apidoc.element.q-io.fs.absolute">
        function <span class="apidocSignatureSpan">q-io.fs.</span>absolute
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">absolute = function (path) {
    if (this.isAbsolute(path))
        return this.normal(path);
    return this.join(workingDirectory(), path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* @returns {String} the Unix root path or corresponding
* Windows drive for a given path.
*/
exports.root = function (path) {
   if (!exports.isAbsolute(path))
       path = require("./fs").<span class="apidocCodeKeywordSpan">absolute</span>(path);
   var parts = exports.split(path);
   return exports.join(parts[0], "");
};

/**
* @returns {String} the parent directory of the given path.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.append" id="apidoc.element.q-io.fs.append">
        function <span class="apidocSignatureSpan">q-io.fs.</span>append
        <span class="apidocSignatureSpan">(path, content, flags, charset, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (path, content, flags, charset, options) {
    var self = this;
    if (typeof flags === "object") {
        options = flags;
    } else if (typeof charset === "object") {
        options = charset;
        options.flags = flags;
    } else {
        options = options || {};
        options.flags = flags;
        options.charset = charset;
    }
    flags = options.flags || "a";
    if (content instanceof Buffer) {
        flags += "b";
    }
    options.flags = flags;
    return Q.when(self.open(path, options), function (stream) {
        return Q.when(stream.write(content), function () {
            return stream.close();
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.base" id="apidoc.element.q-io.fs.base">
        function <span class="apidocSignatureSpan">q-io.fs.</span>base
        <span class="apidocSignatureSpan">(path, extension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base = function (path, extension) {
    var base = path.split(exports.SEPARATORS_RE()).pop();
    if (extension)
        base = base.replace(
            new RegExp(regExpEscape(extension) + "$"),
            ""
        );
    return base;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * @returns {String} the extension (e.g., `txt`) of the file
 * at the given path.
 */
exports.extension = function (path) {
    path = exports.<span class="apidocCodeKeywordSpan">base</span>(path);
    path = path.replace(/^\.*/, "");
    var index = path.lastIndexOf(".");
    return index &lt;= 0 ? "" : path.substring(index);
};

})(typeof exports !== "undefined" ? exports : FS_BOOT = {});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.canonical" id="apidoc.element.q-io.fs.canonical">
        function <span class="apidocSignatureSpan">q-io.fs.</span>canonical
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canonical = function (path) {
    var result = Q.defer();
    FS.realpath(path, function (error, canonicalPath) {
        if (error) {
            error.message = "Can't get canonical path of " + JSON.stringify(path) + " by way of C realpath: " + error.message;
            result.reject(error);
        } else {
            result.resolve(canonicalPath);
        }
    });
    return result.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
actual = outer.join(outer.ROOT, actual);
// then we reconstruct the path relative to the
// inner root
actual = outer.relativeFromDirectory(outer.ROOT, actual);
// and rejoin it on the outer root
actual = outer.join(root, actual);
// and find the corresponding real path
return outer.<span class="apidocCodeKeywordSpan">canonical</span>(actual)
.then(function (actual) {
    return actual;
}, function () {
    return actual;
}).then(function (actual) {
    // and verify that the outer canonical path is
    // actually inside the inner canonical path, to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.chmod" id="apidoc.element.q-io.fs.chmod">
        function <span class="apidocSignatureSpan">q-io.fs.</span>chmod
        <span class="apidocSignatureSpan">(path, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chmod = function (path, mode) {
    path = String(path);
    mode = String(mode);
    var done = Q.defer();
    try {
        FS.chmod(path, mode, function (error) {
            if (error) {
                error.message = "Can't chmod (change permissions mode) of " + JSON.stringify(path) + " to (octal number) " + mode
.toString(8) + ": " + error.message;
                done.reject(error);
            } else {
                done.resolve();
            }
        });
    } catch (error) {
        done.reject(error);
    }
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

exports.chmod = function (path, mode) {
path = String(path);
mode = String(mode);
var done = Q.defer();
try {
    FS.<span class="apidocCodeKeywordSpan">chmod</span>(path, mode, function (error) {
        if (error) {
            error.message = "Can't chmod (change permissions mode) of " + JSON.stringify(path) + " to (octal
 number) " + mode.toString(8) + ": " + error.message;
            done.reject(error);
        } else {
            done.resolve();
        }
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.chown" id="apidoc.element.q-io.fs.chown">
        function <span class="apidocSignatureSpan">q-io.fs.</span>chown
        <span class="apidocSignatureSpan">(path, uid, gid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chown = function (path, uid, gid) {
    path = String(path);
    var done = Q.defer();
    try {
        FS.chown(path, uid, gid, function (error) {
            if (error) {
                error.message = "Can't chown (change owner) of " + JSON.stringify(path) + " to user " + JSON.stringify(uid) + "
and group " + JSON.stringify(gid) + ": " + error.message;
                done.reject(error);
            } else {
                done.resolve();
            }
        });
    } catch (error) {
        done.reject(error);
    }
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return done.promise;
};

exports.chown = function (path, uid, gid) {
path = String(path);
var done = Q.defer();
try {
    FS.<span class="apidocCodeKeywordSpan">chown</span>(path, uid, gid, function (error) {
        if (error) {
            error.message = "Can't chown (change owner) of " + JSON.stringify(path) + " to user " + JSON
.stringify(uid) + " and group " + JSON.stringify(gid) + ": " + error.message;
            done.reject(error);
        } else {
            done.resolve();
        }
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.contains" id="apidoc.element.q-io.fs.contains">
        function <span class="apidocSignatureSpan">q-io.fs.</span>contains
        <span class="apidocSignatureSpan">(parent, child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (parent, child) {
    var i, ii;
    parent = this.absolute(parent);
    child = this.absolute(child);
    parent = parent.split(this.SEPARATORS_RE());
    child = child.split(this.SEPARATORS_RE());
    if (parent.length === 2 &amp;&amp; parent[1] === "")
        parent.pop();
    if (parent.length &gt; child.length)
        return false;
    for (i = 0, ii = parent.length; i &lt; ii; i++) {
        if (parent[i] !== child[i])
            break;
    }
    return i == ii;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return actual;
}, function () {
    return actual;
}).then(function (actual) {
    // and verify that the outer canonical path is
    // actually inside the inner canonical path, to
    // prevent break-outs
    if (outer.<span class="apidocCodeKeywordSpan">contains</span>(root, actual)) {
        return {
            "inner": outer.join(outer.ROOT, outer.relativeFromDirectory(root, actual)),
            "outer": actual
        };
    } else {
        return Q.reject("Can't find: " + JSON.stringify(path));
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.copy" id="apidoc.element.q-io.fs.copy">
        function <span class="apidocSignatureSpan">q-io.fs.</span>copy
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy = function (source, target) {
    var self = this;
    return Q.when(self.stat(source), function (stat) {
        var mode = stat.node.mode;
        return Q.all([
            self.open(source, {flags: "rb"}),
            self.open(target, {flags: "wb", mode: mode})
        ]);
    })
    .spread(function (reader, writer) {
        return Q.when(reader.forEach(function (block) {
            return writer.write(block);
        }), function () {
            return Q.all([
                reader.close(),
                writer.close()
            ]);
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
};

exports.copyTree = function (source, target) {
    var self = this;
    return Q.when(self.stat(source), function (stat) {
        if (stat.isFile()) {
            return self.<span class="apidocCodeKeywordSpan">copy</span>(source, target);
        } else if (stat.isDirectory()) {
            return self.exists(target).then(function (targetExists) {
                function copySubTree() {
                    return Q.when(self.list(source), function (list) {
                        return Q.all(list.map(function (child) {
                            return self.copyTree(
                                self.join(source, child),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.copyTree" id="apidoc.element.q-io.fs.copyTree">
        function <span class="apidocSignatureSpan">q-io.fs.</span>copyTree
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copyTree = function (source, target) {
    var self = this;
    return Q.when(self.stat(source), function (stat) {
        if (stat.isFile()) {
            return self.copy(source, target);
        } else if (stat.isDirectory()) {
            return self.exists(target).then(function (targetExists) {
                function copySubTree() {
                    return Q.when(self.list(source), function (list) {
                        return Q.all(list.map(function (child) {
                            return self.copyTree(
                                self.join(source, child),
                                self.join(target, child)
                            );
                        }));
                    });
                }
                if (targetExists) {
                    return copySubTree();
                } else {
                    return Q.when(self.makeDirectory(target, stat.node.mode), copySubTree);
                }
            });
        } else if (stat.isSymbolicLink()) {
            // TODO copy the link and type with readPath (but what about
            // Windows junction type?)
            return self.symbolicCopy(source, target);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

exports.move = function (source, target) {
    var self = this;
    return this.rename(source, target)
    .catch(function (error) {
        if (error.crossDevice) {
            return self.<span class="apidocCodeKeywordSpan">copyTree</span>(source, target)
            .then(function () {
                return self.removeTree(source);
            });
        } else {
            throw error;
        }
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.directory" id="apidoc.element.q-io.fs.directory">
        function <span class="apidocSignatureSpan">q-io.fs.</span>directory
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directory = function (path) {
    path = exports.normal(path);
    var absolute = exports.isAbsolute(path);
    var parts = exports.split(path);
    // XXX needs to be sensitive to the root for
    // Windows compatibility
    if (parts.length) {
        if (parts[parts.length - 1] == "..") {
            parts.push("..");
        } else {
            parts.pop();
        }
    } else {
        parts.unshift("..");
    }
    return parts.join(exports.SEPARATOR) || (
        exports.isRelative(path) ?
        "" : exports.ROOT
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.exists" id="apidoc.element.q-io.fs.exists">
        function <span class="apidocSignatureSpan">q-io.fs.</span>exists
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exists = function (path) {
    return Q.when(this.stat(path), function () {
        return true;
    }, function () {
        return false;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    exports.copyTree = function (source, target) {
var self = this;
return Q.when(self.stat(source), function (stat) {
    if (stat.isFile()) {
        return self.copy(source, target);
    } else if (stat.isDirectory()) {
        return self.<span class="apidocCodeKeywordSpan">exists</span>(target).then(function (targetExists) {
            function copySubTree() {
                return Q.when(self.list(source), function (list) {
                    return Q.all(list.map(function (child) {
                        return self.copyTree(
                            self.join(source, child),
                            self.join(target, child)
                        );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.extension" id="apidoc.element.q-io.fs.extension">
        function <span class="apidocSignatureSpan">q-io.fs.</span>extension
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extension = function (path) {
    path = exports.base(path);
    path = path.replace(/^\.*/, "");
    var index = path.lastIndexOf(".");
    return index &lt;= 0 ? "" : path.substring(index);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.isAbsolute" id="apidoc.element.q-io.fs.isAbsolute">
        function <span class="apidocSignatureSpan">q-io.fs.</span>isAbsolute
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAbsolute = function (path) {
    // for absolute paths on any operating system,
    // the first path component always determines
    // whether it is relative or absolute.  On Unix,
    // it is empty, so ["", "foo"].join("/") == "/foo",
    // "/foo".split("/") == ["", "foo"].
    var parts = exports.split(path);
    // split("") == [].  "" is not absolute.
    // split("/") == ["", ""] is absolute.
    // split(?) == [""] does not occur.
    if (parts.length == 0)
        return false;
    return exports.isRoot(parts[0]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var children = [];
var leaf = "";
for (var i = 0; i &lt; arguments.length; i++) {
    var path = String(arguments[i]);
    if (path == "")
        continue;
    var parts = path.split(exports.SEPARATORS_RE());
    if (exports.<span class="apidocCodeKeywordSpan">isAbsolute</span>(path)) {
        root = parts.shift() + exports.SEPARATOR;
        parents = [];
        children = [];
    }
    leaf = parts.pop();
    if (leaf == "." || leaf == "..") {
        parts.push(leaf);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.isDirectory" id="apidoc.element.q-io.fs.isDirectory">
        function <span class="apidocSignatureSpan">q-io.fs.</span>isDirectory
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDirectory = function (path) {
    return Q.when(this.stat(path), function (stat) {
        return stat.isDirectory();
    }, function (reason) {
        return false;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

exports.copyTree = function (source, target) {
    var self = this;
    return Q.when(self.stat(source), function (stat) {
        if (stat.isFile()) {
            return self.copy(source, target);
        } else if (stat.<span class="apidocCodeKeywordSpan">isDirectory</span>()) {
            return self.exists(target).then(function (targetExists) {
                function copySubTree() {
                    return Q.when(self.list(source), function (list) {
                        return Q.all(list.map(function (child) {
                            return self.copyTree(
                                self.join(source, child),
                                self.join(target, child)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.isFile" id="apidoc.element.q-io.fs.isFile">
        function <span class="apidocSignatureSpan">q-io.fs.</span>isFile
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFile = function (path) {
    return Q.when(this.stat(path), function (stat) {
        return stat.isFile();
    }, function (reason) {
        return false;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        });
    });
};

exports.copyTree = function (source, target) {
    var self = this;
    return Q.when(self.stat(source), function (stat) {
        if (stat.<span class="apidocCodeKeywordSpan">isFile</span>()) {
            return self.copy(source, target);
        } else if (stat.isDirectory()) {
            return self.exists(target).then(function (targetExists) {
                function copySubTree() {
                    return Q.when(self.list(source), function (list) {
                        return Q.all(list.map(function (child) {
                            return self.copyTree(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.isRelative" id="apidoc.element.q-io.fs.isRelative">
        function <span class="apidocSignatureSpan">q-io.fs.</span>isRelative
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRelative = function (path) {
    return !exports.isAbsolute(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       } else {
           parts.pop();
       }
   } else {
       parts.unshift("..");
   }
   return parts.join(exports.SEPARATOR) || (
       exports.<span class="apidocCodeKeywordSpan">isRelative</span>(path) ?
       "" : exports.ROOT
   );
};

/**
* @returns {String} the last component of a path, without
* the given extension if the extension is provided and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.isRoot" id="apidoc.element.q-io.fs.isRoot">
        function <span class="apidocSignatureSpan">q-io.fs.</span>isRoot
        <span class="apidocSignatureSpan">(first)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRoot = function (first) {
    if (exports.SEPARATOR === "\\") {
        return /[a-zA-Z]:$/.test(first);
    } else {
        return first == "";
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // "/foo".split("/") == ["", "foo"].
    var parts = exports.split(path);
    // split("") == [].  "" is not absolute.
    // split("/") == ["", ""] is absolute.
    // split(?) == [""] does not occur.
    if (parts.length == 0)
        return false;
    return exports.<span class="apidocCodeKeywordSpan">isRoot</span>(parts[0]);
};

/**
 * @returns {Boolean} whether the given path does not begin
 * at the root of the file system or a drive letter.
 */
exports.isRelative = function (path) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.isSymbolicLink" id="apidoc.element.q-io.fs.isSymbolicLink">
        function <span class="apidocSignatureSpan">q-io.fs.</span>isSymbolicLink
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSymbolicLink = function (path) {
    return Q.when(this.statLink(path), function (stat) {
        return stat.isSymbolicLink();
    }, function (reason) {
        return false;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                }
                if (targetExists) {
                    return copySubTree();
                } else {
                    return Q.when(self.makeDirectory(target, stat.node.mode), copySubTree);
                }
            });
        } else if (stat.<span class="apidocCodeKeywordSpan">isSymbolicLink</span>()) {
            // TODO copy the link and type with readPath (but what about
            // Windows junction type?)
            return self.symbolicCopy(source, target);
        }
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.join" id="apidoc.element.q-io.fs.join">
        function <span class="apidocSignatureSpan">q-io.fs.</span>join
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">join = function () {
    if (arguments.length === 1 &amp;&amp; Array.isArray(arguments[0]))
        return exports.normal.apply(exports, arguments[0]);
    return exports.normal.apply(exports, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return Q.fcall(function () {
        chunks.splice(0, chunks.length).forEach(write, thisp);
    });
};

BufferStream.prototype.read = function () {
    var result;
    result = Reader.<span class="apidocCodeKeywordSpan">join</span>(this._chunks);
    if (this._charset) {
        result = result.toString(this._charset);
    }
    return Q.resolve(result);
};

BufferStream.prototype.write = function (chunk) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.lastAccessed" id="apidoc.element.q-io.fs.lastAccessed">
        function <span class="apidocSignatureSpan">q-io.fs.</span>lastAccessed
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastAccessed = function (path) {
    var self = this;
    return self.stat(path).invoke('lastAccessed');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.lastModified" id="apidoc.element.q-io.fs.lastModified">
        function <span class="apidocSignatureSpan">q-io.fs.</span>lastModified
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastModified = function (path) {
    var self = this;
    return self.stat(path).invoke('lastModified');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.link" id="apidoc.element.q-io.fs.link">
        function <span class="apidocSignatureSpan">q-io.fs.</span>link
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">link = function (source, target) {
    source = String(source);
    target = String(target);
    var done = Q.defer();
    try {
        FS.link(source, target, function (error) {
            if (error) {
                error.message = "Can't link " + JSON.stringify(source) + " to " + JSON.stringify(target) + ": " + error.message;
                done.reject(error);
            } else {
                done.resolve();
            }
        });
    } catch (error) {
        done.reject(error);
    }
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

exports.link = function (source, target) {
source = String(source);
target = String(target);
var done = Q.defer();
try {
    FS.<span class="apidocCodeKeywordSpan">link</span>(source, target, function (error) {
        if (error) {
            error.message = "Can't link " + JSON.stringify(source) + " to " + JSON.stringify(target) + &amp;#
x22;: " + error.message;
            done.reject(error);
        } else {
            done.resolve();
        }
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.list" id="apidoc.element.q-io.fs.list">
        function <span class="apidocSignatureSpan">q-io.fs.</span>list
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">list = function () {
    var args = arguments;
    var ready = backOffDelay ? Q.delay(backOffDelay) : Q.resolve();
    return ready.then(function () {
        return Q.when(wrapped.apply(thisp, args), function (stream) {
            backOffDelay = Math.max(0, backOffDelay - 1);
            return stream;
        }, function (error) {
            if (error.code === "EMFILE") {
                backOffDelay = (backOffDelay + 1) * backOffFactor;
                return retry.apply(null, args);
            } else {
                throw error;
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var self = this;
return Q.when(self.stat(source), function (stat) {
    if (stat.isFile()) {
        return self.copy(source, target);
    } else if (stat.isDirectory()) {
        return self.exists(target).then(function (targetExists) {
            function copySubTree() {
                return Q.when(self.<span class="apidocCodeKeywordSpan">list</span>(source), function (list) {
                    return Q.all(list.map(function (child) {
                        return self.copyTree(
                            self.join(source, child),
                            self.join(target, child)
                        );
                    }));
                });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.listDirectoryTree" id="apidoc.element.q-io.fs.listDirectoryTree">
        function <span class="apidocSignatureSpan">q-io.fs.</span>listDirectoryTree
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listDirectoryTree = function (path) {
    return this.listTree(path, function (path, stat) {
        return stat.isDirectory();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.listTree" id="apidoc.element.q-io.fs.listTree">
        function <span class="apidocSignatureSpan">q-io.fs.</span>listTree
        <span class="apidocSignatureSpan">(basePath, guard)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listTree = function (basePath, guard) {
    var self = this;
    basePath = String(basePath || '');
    if (!basePath)
        basePath = ".";
    guard = guard || function () {
        return true;
    };
    var stat = self.stat(basePath);
    return Q.when(stat, function (stat) {
        var paths = [];
        var mode; // true:include, false:exclude, null:no-recur
        try {
            var include = guard(basePath, stat);
        } catch (exception) {
            return Q.reject(exception);
        }
        return Q.when(include, function (include) {
            if (include) {
                paths.push([basePath]);
            }
            if (include !== null &amp;&amp; stat.isDirectory()) {
                return Q.when(self.list(basePath), function (children) {
                    paths.push.apply(paths, children.map(function (child) {
                        var path = self.join(basePath, child);
                        return self.listTree(path, guard);
                    }));
                    return paths;
                });
            } else {
                return paths;
            }
        });
    }, function noSuchFile(reason) {
        return [];
    }).then(Q.all).then(concat);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (include) {
        paths.push([basePath]);
    }
    if (include !== null &amp;&amp; stat.isDirectory()) {
        return Q.when(self.list(basePath), function (children) {
            paths.push.apply(paths, children.map(function (child) {
                var path = self.join(basePath, child);
                return self.<span class="apidocCodeKeywordSpan">listTree</span>(path, guard);
            }));
            return paths;
        });
    } else {
        return paths;
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.makeDirectory" id="apidoc.element.q-io.fs.makeDirectory">
        function <span class="apidocSignatureSpan">q-io.fs.</span>makeDirectory
        <span class="apidocSignatureSpan">(path, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeDirectory = function (path, mode) {
    path = String(path);
    var done = Q.defer();
    if (typeof mode === "string") {
        mode = parseInt(mode, 8);
    } else if (mode === void 0) {
        mode = parseInt('755', 8);
    }
    FS.mkdir(path, mode, function (error) {
        if (error) {
            if (error.code === "EISDIR") {
                error.exists = true;
                error.isDirectory = true;
                error.message = "directory already exists: " + error.message;
            }
            if (error.code === "EEXIST") {
                error.exists = true;
                error.message = "file exists at that path: " + error.message;
            }
            error.message = "Can't makeDirectory " + JSON.stringify(path) + " with mode " + mode + ": " + error.message;
            done.reject(error);
        } else {
            done.resolve();
        }
    });
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                    );
                }));
            });
        }
        if (targetExists) {
            return copySubTree();
        } else {
            return Q.when(self.<span class="apidocCodeKeywordSpan">makeDirectory</span>(target, stat.node.mode), copySubTree);
        }
    });
} else if (stat.isSymbolicLink()) {
    // TODO copy the link and type with readPath (but what about
    // Windows junction type?)
    return self.symbolicCopy(source, target);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.makeTree" id="apidoc.element.q-io.fs.makeTree">
        function <span class="apidocSignatureSpan">q-io.fs.</span>makeTree
        <span class="apidocSignatureSpan">(path, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeTree = function (path, mode) {
    path = String(path);
    var self = this;
    var parts = self.split(path);
    var at = [];
    if (self.isAbsolute(path)) {
        // On Windows use the root drive (e.g. "C:"), on *nix the first
        // part is the falsey "", and so use the ROOT ("/")
        at.push(parts.shift() || self.ROOT);
    }
    return parts.reduce(function (parent, part) {
        return Q.when(parent, function () {
            at.push(part);
            var parts = self.join(at) || ".";
            var made = self.makeDirectory(parts, mode);
            return Q.when(made, null, function rejected(error) {
                // throw away errors for already made directories
                if (error.exists) {
                    return;
                } else {
                    throw error;
                }
            });
        });
    }, undefined);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }).catch(function (error) {
        throw new Error("Can't remove " + JSON.stringify(path));
    });
};

inner.makeTree = function (path) {
    return attenuate(path).then(function (path) {
        return outer.<span class="apidocCodeKeywordSpan">makeTree</span>(path.outer);
    }).catch(function (error) {
        throw new Error("Can't make tree " + JSON.stringify(path));
    });
};

inner.removeTree = function (path) {
    return attenuate(path).then(function (path) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.merge" id="apidoc.element.q-io.fs.merge">
        function <span class="apidocSignatureSpan">q-io.fs.</span>merge
        <span class="apidocSignatureSpan">(fss)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (fss) {
    var tree = {};
    var done;
    fss.forEach(function (fs) {
        done = Q.when(done, function () {
            return fs.listTree("", function (path, stat) {
                return stat.isFile();
            })
            .then(function (list) {
                return Q.all(list.map(function (path) {
                    return Q.when(fs.read(path, "rb"), function (content) {
                        tree[path] = content;
                    });
                }));
            });
        });
    })
    return Q.when(done, function () {
        return MockFs(tree);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.mock" id="apidoc.element.q-io.fs.mock">
        function <span class="apidocSignatureSpan">q-io.fs.</span>mock
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mock = function (path) {
    return Mock.mock(this, path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

You can also instantiate a mock file system with the content of a
subtree of a real file system.  You receive a promise for the mock
filesystem.

```javascript
var FS = require("q-io/fs");
FS.<span class="apidocCodeKeywordSpan">mock</span>(__dirname)
.then(function (fs) {
    //
})
.done();
```

## HTTP
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.move" id="apidoc.element.q-io.fs.move">
        function <span class="apidocSignatureSpan">q-io.fs.</span>move
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">move = function (source, target) {
    var self = this;
    return this.rename(source, target)
    .catch(function (error) {
        if (error.crossDevice) {
            return self.copyTree(source, target)
            .then(function () {
                return self.removeTree(source);
            });
        } else {
            throw error;
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.normal" id="apidoc.element.q-io.fs.normal">
        function <span class="apidocSignatureSpan">q-io.fs.</span>normal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normal = function () {
    var root = "";
    var parents = [];
    var children = [];
    for (var i = 0, ii = arguments.length; i &lt; ii; i++) {
        var path = String(arguments[i]);
        // empty paths have no affect
        if (path === "")
            continue;
        var parts = path.split(exports.SEPARATORS_RE());
        if (exports.isAbsolute(path)) {
            root = parts.shift() + exports.SEPARATOR;
            parents = [];
            children = [];
        }
        for (var j = 0, jj = parts.length; j &lt; jj; j++) {
            var part = parts[j];
            if (part === "." || part === "") {
            } else if (part == "..") {
                if (children.length) {
                    children.pop();
                } else {
                    if (root) {
                    } else {
                        parents.push("..");
                    }
                }
            } else {
                children.push(part);
            }
        }
    }
    path = parents.concat(children).join(exports.SEPARATOR);
    return root + path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return exports.join(parts[0], "");
};

/**
 * @returns {String} the parent directory of the given path.
 */
exports.directory = function (path) {
path = exports.<span class="apidocCodeKeywordSpan">normal</span>(path);
var absolute = exports.isAbsolute(path);
var parts = exports.split(path);
// XXX needs to be sensitive to the root for
// Windows compatibility
if (parts.length) {
    if (parts[parts.length - 1] == "..") {
        parts.push("..");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.open" id="apidoc.element.q-io.fs.open">
        function <span class="apidocSignatureSpan">q-io.fs.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function () {
    var args = arguments;
    var ready = backOffDelay ? Q.delay(backOffDelay) : Q.resolve();
    return ready.then(function () {
        return Q.when(wrapped.apply(thisp, args), function (stream) {
            backOffDelay = Math.max(0, backOffDelay - 1);
            return stream;
        }, function (error) {
            if (error.code === "EMFILE") {
                backOffDelay = (backOffDelay + 1) * backOffFactor;
                return retry.apply(null, args);
            } else {
                throw error;
            }
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return {
        status: 404,
        headers: {},
        body: ["Can't access protocol " + url.protocol]
    };
} else {
    var path = url.pathname;
    return fs.<span class="apidocCodeKeywordSpan">open</span>(path, {
        charset: request.charset
    }).then(function (body) {
        return {
            status: 200,
            headers: {},
            body: body
        };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.read" id="apidoc.element.q-io.fs.read">
        function <span class="apidocSignatureSpan">q-io.fs.</span>read
        <span class="apidocSignatureSpan">(path, flags, charset, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (path, flags, charset, options) {
    if (typeof flags === "object") {
        options = flags;
    } else if (typeof charset === "object") {
        options = charset;
        options.flags = flags;
    } else {
        options = options || {};
        options.flags = flags;
        options.charset = charset;
    }
    options.flags = options.flags || "r";
    return Q.when(this.open(path, options), function (stream) {
        return stream.read();
    }, function (error) {
        error.message = "Can't read " + path + " because " + error.message;
        error.path = path;
        error.flags = flags;
        error.charset = charset;
        throw error;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
into memory.  It returns a promise for the whole file contents.  By
default, `read` provides a string decoded from UTF-8.  With the bytewise
mode flag, provides a `Buffer`.

The options argument is identical to that of `open`.

```javascript
return FS.<span class="apidocCodeKeywordSpan">read</span>(__filename, "b")
.then(function (content) {
    // ...
})
```

```javascript
return FS.read(__filename, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.readLink" id="apidoc.element.q-io.fs.readLink">
        function <span class="apidocSignatureSpan">q-io.fs.</span>readLink
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readLink = function (path) {
    var result = Q.defer();
    FS.readlink(path, function (error, path) {
        if (error) {
            error.message = "Can't get link from " + JSON.stringify(path) + " by way of C readlink: " + error.message;
            result.reject(error);
        } else {
            result.resolve(path);
        }
    });
    return result.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.relative" id="apidoc.element.q-io.fs.relative">
        function <span class="apidocSignatureSpan">q-io.fs.</span>relative
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">relative = function (source, target) {
    var self = this;
    return Q.when(this.isDirectory(source), function (isDirectory) {
        if (isDirectory) {
            return self.relativeFromDirectory(source, target);
        } else {
            return self.relativeFromFile(source, target);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return self.remove(path);
        }
    });
};

exports.symbolicCopy = function (source, target, type) {
    var self = this;
    return Q.when(self.<span class="apidocCodeKeywordSpan">relative</span>(target, source), function (relative) {
        return self.symbolicLink(target, relative, type || "file");
    });
};

exports.exists = function (path) {
    return Q.when(this.stat(path), function () {
        return true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.relativeFromDirectory" id="apidoc.element.q-io.fs.relativeFromDirectory">
        function <span class="apidocSignatureSpan">q-io.fs.</span>relativeFromDirectory
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">relativeFromDirectory = function (source, target) {
    if (!target) {
        target = source;
        source = workingDirectory();
    }
    source = this.absolute(source);
    target = this.absolute(target);
    source = source.split(this.SEPARATORS_RE());
    target = target.split(this.SEPARATORS_RE());
    if (source.length === 2 &amp;&amp; source[1] === "")
        source.pop();
    while (
        source.length &amp;&amp;
        target.length &amp;&amp;
        target[0] == source[0]
    ) {
        source.shift();
        target.shift();
    }
    while (source.length) {
        source.shift();
        target.unshift("..");
    }
    return target.join(this.SEPARATOR);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return this.join(workingDirectory(), path);
};

exports.relative = function (source, target) {
    var self = this;
    return Q.when(this.isDirectory(source), function (isDirectory) {
        if (isDirectory) {
            return self.<span class="apidocCodeKeywordSpan">relativeFromDirectory</span>(source, target);
        } else {
            return self.relativeFromFile(source, target);
        }
    });
};

exports.relativeFromFile = function (source, target) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.relativeFromFile" id="apidoc.element.q-io.fs.relativeFromFile">
        function <span class="apidocSignatureSpan">q-io.fs.</span>relativeFromFile
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">relativeFromFile = function (source, target) {
    var self = this;
    source = self.absolute(source);
    target = self.absolute(target);
    source = source.split(self.SEPARATORS_RE());
    target = target.split(self.SEPARATORS_RE());
    source.pop();
    while (
        source.length &amp;&amp;
        target.length &amp;&amp;
        target[0] == source[0]
    ) {
        source.shift();
        target.shift();
    }
    while (source.length) {
        source.shift();
        target.unshift("..");
    }
    return target.join(self.SEPARATOR);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.relative = function (source, target) {
    var self = this;
    return Q.when(this.isDirectory(source), function (isDirectory) {
        if (isDirectory) {
            return self.relativeFromDirectory(source, target);
        } else {
            return self.<span class="apidocCodeKeywordSpan">relativeFromFile</span>(source, target);
        }
    });
};

exports.relativeFromFile = function (source, target) {
    var self = this;
    source = self.absolute(source);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.remove" id="apidoc.element.q-io.fs.remove">
        function <span class="apidocSignatureSpan">q-io.fs.</span>remove
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (path) {
    path = String(path);
    var done = Q.defer();
    FS.unlink(path, function (error) {
        if (error) {
            error.message = "Can't remove " + JSON.stringify(path) + ": " + error.message;
            done.reject(error);
        } else {
            done.resolve();
        }
    });
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }, undefined);
};

exports.removeTree = function (path) {
    var self = this;
    return Q.when(self.statLink(path), function (stat) {
        if (stat.isSymbolicLink()) {
            return self.<span class="apidocCodeKeywordSpan">remove</span>(path);
        } else if (stat.isDirectory()) {
            return self.list(path)
            .then(function (list) {
                // asynchronously remove every subtree
                return Q.all(list.map(function (name) {
                    return self.removeTree(self.join(path, name));
                }))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.removeDirectory" id="apidoc.element.q-io.fs.removeDirectory">
        function <span class="apidocSignatureSpan">q-io.fs.</span>removeDirectory
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeDirectory = function (path) {
    path = String(path);
    var done = Q.defer();
    FS.rmdir(path, function (error) {
        if (error) {
            error.message = "Can't removeDirectory " + JSON.stringify(path) + ": " + error.message;
            done.reject(error);
        } else {
            done.resolve();
        }
    });
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return self.list(path)
            .then(function (list) {
                // asynchronously remove every subtree
                return Q.all(list.map(function (name) {
                    return self.removeTree(self.join(path, name));
                }))
                .then(function () {
                    return self.<span class="apidocCodeKeywordSpan">removeDirectory</span>(path);
                });
            });
        } else {
            return self.remove(path);
        }
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.removeTree" id="apidoc.element.q-io.fs.removeTree">
        function <span class="apidocSignatureSpan">q-io.fs.</span>removeTree
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeTree = function (path) {
    var self = this;
    return Q.when(self.statLink(path), function (stat) {
        if (stat.isSymbolicLink()) {
            return self.remove(path);
        } else if (stat.isDirectory()) {
            return self.list(path)
            .then(function (list) {
                // asynchronously remove every subtree
                return Q.all(list.map(function (name) {
                    return self.removeTree(self.join(path, name));
                }))
                .then(function () {
                    return self.removeDirectory(path);
                });
            });
        } else {
            return self.remove(path);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.move = function (source, target) {
    var self = this;
    return this.rename(source, target)
    .catch(function (error) {
        if (error.crossDevice) {
            return self.copyTree(source, target)
            .then(function () {
                return self.<span class="apidocCodeKeywordSpan">removeTree</span>(source);
            });
        } else {
            throw error;
        }
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.rename" id="apidoc.element.q-io.fs.rename">
        function <span class="apidocSignatureSpan">q-io.fs.</span>rename
        <span class="apidocSignatureSpan">(source, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rename = function (source, target) {
    source = String(source);
    target = String(target);
    return Q.ninvoke(FS, "rename", source, target)
    .fail(function (error) {
        if (error.code === "EXDEV") {
            error.message = "source and target are on different devices: " + error.message;
            error.crossDevice = true;
        }
        error.message = (
            "Can't move " + JSON.stringify(source) + " to " +
            JSON.stringify(target) + " because " + error.message
        );
        throw error;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return stream.close();
        });
    });
};

exports.move = function (source, target) {
    var self = this;
    return this.<span class="apidocCodeKeywordSpan">rename</span>(source, target)
    .catch(function (error) {
        if (error.crossDevice) {
            return self.copyTree(source, target)
            .then(function () {
                return self.removeTree(source);
            });
        } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.reroot" id="apidoc.element.q-io.fs.reroot">
        function <span class="apidocSignatureSpan">q-io.fs.</span>reroot
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reroot(path) {
    var self = this;
    path = path || this.ROOT;
    return RootFs(self, path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.resolve" id="apidoc.element.q-io.fs.resolve">
        function <span class="apidocSignatureSpan">q-io.fs.</span>resolve
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function () {
    var root = "";
    var parents = [];
    var children = [];
    var leaf = "";
    for (var i = 0; i &lt; arguments.length; i++) {
        var path = String(arguments[i]);
        if (path == "")
            continue;
        var parts = path.split(exports.SEPARATORS_RE());
        if (exports.isAbsolute(path)) {
            root = parts.shift() + exports.SEPARATOR;
            parents = [];
            children = [];
        }
        leaf = parts.pop();
        if (leaf == "." || leaf == "..") {
            parts.push(leaf);
            leaf = "";
        }
        for (var j = 0; j &lt; parts.length; j++) {
            var part = parts[j];
            if (part == "." || part == "") {
            } else if (part == "..") {
                if (children.length) {
                    children.pop();
                } else {
                    if (root) {
                    } else {
                        parents.push("..");
                    }
                }
            } else {
                children.push(part);
            }
        };
    }
    path = parents.concat(children).join(exports.SEPARATOR);
    if (path) leaf = exports.SEPARATOR + leaf;
    return root + path + leaf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

BufferStream.prototype.read = function () {
var result;
result = Reader.join(this._chunks);
if (this._charset) {
    result = result.toString(this._charset);
}
return Q.<span class="apidocCodeKeywordSpan">resolve</span>(result);
};

BufferStream.prototype.write = function (chunk) {
if (this._charset) {
    chunk = new Buffer(String(chunk), this._charset);
} else {
    if (!(chunk instanceof Buffer)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.root" id="apidoc.element.q-io.fs.root">
        function <span class="apidocSignatureSpan">q-io.fs.</span>root
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">root = function (path) {
    if (!exports.isAbsolute(path))
        path = require("./fs").absolute(path);
    var parts = exports.split(path);
    return exports.join(parts[0], "");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.split" id="apidoc.element.q-io.fs.split">
        function <span class="apidocSignatureSpan">q-io.fs.</span>split
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (path) {
    var parts;
    try {
        parts = String(path).split(exports.SEPARATORS_RE());
    } catch (exception) {
        throw new Error("Cannot split " + (typeof path) + ", " + JSON.stringify(path));
    }
    // this special case helps isAbsolute
    // distinguish an empty path from an absolute path
    // "" -&gt; [] NOT [""]
    if (parts.length === 1 &amp;&amp; parts[0] === "")
        return [];
    // "a" -&gt; ["a"]
    // "/a" -&gt; ["", "a"]
    return parts;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * file system, indicated by an empty string on Unix, and a
 * drive letter followed by a colon on Windows.
 * @returns {Array * String}
 */
exports.split = function (path) {
var parts;
try {
    parts = String(path).<span class="apidocCodeKeywordSpan">split</span>(exports.SEPARATORS_RE());
} catch (exception) {
    throw new Error("Cannot split " + (typeof path) + ", " + JSON.stringify(path));
}
// this special case helps isAbsolute
// distinguish an empty path from an absolute path
// "" -&gt; [] NOT [""]
if (parts.length === 1 &amp;&amp; parts[0] === "")
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.stat" id="apidoc.element.q-io.fs.stat">
        function <span class="apidocSignatureSpan">q-io.fs.</span>stat
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stat = function (path) {
    var self = this;
    path = String(path);
    var done = Q.defer();
    try {
        FS.stat(path, function (error, stat) {
            if (error) {
                error.message = "Can't stat " + JSON.stringify(path) + ": " + error;
                done.reject(error);
            } else {
                done.resolve(new self.Stats(stat));
            }
        });
    } catch (error) {
        done.reject(error);
    }
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            throw error;
        }
    });
};

exports.copy = function (source, target) {
    var self = this;
    return Q.when(self.<span class="apidocCodeKeywordSpan">stat</span>(source), function (stat) {
        var mode = stat.node.mode;
        return Q.all([
            self.open(source, {flags: "rb"}),
            self.open(target, {flags: "wb", mode: mode})
        ]);
    })
    .spread(function (reader, writer) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.statFd" id="apidoc.element.q-io.fs.statFd">
        function <span class="apidocSignatureSpan">q-io.fs.</span>statFd
        <span class="apidocSignatureSpan">(fd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statFd = function (fd) {
    fd = Number(fd);
    var done = Q.defer();
    try {
        FS.fstat(fd, function (error, stat) {
            if (error) {
                error.message = "Can't statFd file descriptor " + JSON.stringify(fd) + ": " + error.message;
                done.reject(error);
            } else {
                done.resolve(stat);
            }
        });
    } catch (error) {
        done.reject(error);
    }
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.statLink" id="apidoc.element.q-io.fs.statLink">
        function <span class="apidocSignatureSpan">q-io.fs.</span>statLink
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statLink = function (path) {
    path = String(path);
    var done = Q.defer();
    try {
        FS.lstat(path, function (error, stat) {
            if (error) {
                error.message = "Can't statLink " + JSON.stringify(path) + ": " + error.message;
                done.reject(error);
            } else {
                done.resolve(stat);
            }
        });
    } catch (error) {
        done.reject(error);
    }
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            });
        });
    }, undefined);
};

exports.removeTree = function (path) {
    var self = this;
    return Q.when(self.<span class="apidocCodeKeywordSpan">statLink</span>(path), function (stat) {
        if (stat.isSymbolicLink()) {
            return self.remove(path);
        } else if (stat.isDirectory()) {
            return self.list(path)
            .then(function (list) {
                // asynchronously remove every subtree
                return Q.all(list.map(function (name) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.symbolicCopy" id="apidoc.element.q-io.fs.symbolicCopy">
        function <span class="apidocSignatureSpan">q-io.fs.</span>symbolicCopy
        <span class="apidocSignatureSpan">(source, target, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symbolicCopy = function (source, target, type) {
    var self = this;
    return Q.when(self.relative(target, source), function (relative) {
        return self.symbolicLink(target, relative, type || "file");
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                } else {
                    return Q.when(self.makeDirectory(target, stat.node.mode), copySubTree);
                }
            });
        } else if (stat.isSymbolicLink()) {
            // TODO copy the link and type with readPath (but what about
            // Windows junction type?)
            return self.<span class="apidocCodeKeywordSpan">symbolicCopy</span>(source, target);
        }
    });
};

exports.listTree = function (basePath, guard) {
    var self = this;
    basePath = String(basePath || '');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.symbolicLink" id="apidoc.element.q-io.fs.symbolicLink">
        function <span class="apidocSignatureSpan">q-io.fs.</span>symbolicLink
        <span class="apidocSignatureSpan">(target, relative, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symbolicLink = function (target, relative, type) {
    if (!linkTypes.hasOwnProperty(type)) {
        console.warn(new Error("For Windows compatibility, symbolicLink must be called with a type argument \"file\", \"directory\", or \"junction\""));
    }
    type = linkTypes[type];
    target = String(target);
    relative = String(relative);
    var done = Q.defer();
    try {
        FS.symlink(relative, target, type || 'file', function (error) {
            if (error) {
                error.message = "Can't create symbolicLink " + JSON.stringify(target) + " to relative location " + JSON.stringify
(relative) + ": " + error.message;
                done.reject(error);
            } else {
                done.resolve();
            }
        });
    } catch (error) {
        done.reject(error);
    }
    return done.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    });
};

exports.symbolicCopy = function (source, target, type) {
    var self = this;
    return Q.when(self.relative(target, source), function (relative) {
        return self.<span class="apidocCodeKeywordSpan">symbolicLink</span>(target, relative, type || "file");
    });
};

exports.exists = function (path) {
    return Q.when(this.stat(path), function () {
        return true;
    }, function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.toObject" id="apidoc.element.q-io.fs.toObject">
        function <span class="apidocSignatureSpan">q-io.fs.</span>toObject
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toObject = function (path) {
    var self = this;
    var list = self.listTree(path || "", function (path, stat) {
        return stat.isFile();
    });
    return Q.when(list, function (list) {
        var tree = {};
        return Q.all(list.map(function (path) {
            return Q.when(self.read(path, "rb"), function (content) {
                tree[path] = content;
            });
        })).then(function () {
            return tree;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs.write" id="apidoc.element.q-io.fs.write">
        function <span class="apidocSignatureSpan">q-io.fs.</span>write
        <span class="apidocSignatureSpan">(path, content, flags, charset, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (path, content, flags, charset, options) {
    var self = this;
    if (typeof flags === "object") {
        options = flags;
    } else if (typeof charset === "object") {
        options = charset;
        options.flags = flags;
    } else {
        options = options || {};
        options.flags = flags;
        options.charset = charset;
    }
    flags = options.flags || "w";
    if (flags.indexOf("b") !== -1) {
        if (!(content instanceof Buffer)) {
            content = new Buffer(content);
        }
    } else if (content instanceof Buffer) {
        flags += "b";
    }
    options.flags = flags;
    return Q.when(self.open(path, options), function (stream) {
        return Q.when(stream.write(content), function () {
            return stream.close();
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`write` is a shortcut for opening a file and writing its entire content
from a single string or buffer.

The options are identical to that of `open`, but the "w" flag is
implied, and the "b" flag is implied if the content is a buffer.

```javascript
return FS.<span class="apidocCodeKeywordSpan">write</span>("hello.txt", "Hello, World!\n")
.then(function () {
    return FS.read("hello.txt")
})
.then(function (hello) {
    expect(hello).toBe("Hello, World!\n")
})
```
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.fs2http" id="apidoc.module.q-io.fs2http">module q-io.fs2http</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.fs2http.Client" id="apidoc.element.q-io.fs2http.Client">
        function <span class="apidocSignatureSpan">q-io.fs2http.</span>Client
        <span class="apidocSignatureSpan">(fs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client(fs) {
    var self = Object.create(Client.prototype);

    self.request = function (request) {
        return Q.when(request, function (request) {
            request = HTTP.normalizeRequest(request);
            var url = URL.parse(request.url);
            if (url.protocol !== "file:") {
                return {
                    status: 404,
                    headers: {},
                    body: ["Can't access protocol " + url.protocol]
                };
            } else {
                var path = url.pathname;
                return fs.open(path, {
                    charset: request.charset
                }).then(function (body) {
                    return {
                        status: 200,
                        headers: {},
                        body: body
                    };
                });
            }
        });
    };

    self.read = function (request, qualifier) {
        qualifier = qualifier || function (response) {
            return response.status === 200;
        };
        return Q.when(exports.request(request), function (response) {
            if (!qualifier(response)){
                var error = new Error("HTTP request failed with code " + response.status);
                error.response = response;
                throw error;
            }
            return Q.invoke(response.body, "read");
        });
    };

    return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs2http.read" id="apidoc.element.q-io.fs2http.read">
        function <span class="apidocSignatureSpan">q-io.fs2http.</span>read
        <span class="apidocSignatureSpan">(request, qualifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (request, qualifier) {
    return Q.fcall(require.async || require, "./fs")
    .then(function (fs) {
        return Client(fs).read(request);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
into memory.  It returns a promise for the whole file contents.  By
default, `read` provides a string decoded from UTF-8.  With the bytewise
mode flag, provides a `Buffer`.

The options argument is identical to that of `open`.

```javascript
return FS.<span class="apidocCodeKeywordSpan">read</span>(__filename, "b")
.then(function (content) {
    // ...
})
```

```javascript
return FS.read(__filename, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs2http.request" id="apidoc.element.q-io.fs2http.request">
        function <span class="apidocSignatureSpan">q-io.fs2http.</span>request
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">request = function (request) {
    return Q.fcall(require.async || require, "./fs")
    .then(function (fs) {
        return Client(fs).request(request);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
};

self.read = function (request, qualifier) {
    qualifier = qualifier || function (response) {
        return response.status === 200;
    };
    return Q.when(exports.<span class="apidocCodeKeywordSpan">request</span>(request), function (response) {
        if (!qualifier(response)){
            var error = new Error("HTTP request failed with code " + response.status);
            error.response = response;
            throw error;
        }
        return Q.invoke(response.body, "read");
    });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.fs_boot" id="apidoc.module.q-io.fs_boot">module q-io.fs_boot</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.fs_boot.SEPARATORS_RE" id="apidoc.element.q-io.fs_boot.SEPARATORS_RE">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>SEPARATORS_RE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SEPARATORS_RE = function () {
    if (
        separatorCached !== exports.SEPARATOR ||
        altSeparatorCached !== exports.ALT_SEPARATOR
    ) {
        separatorCached = exports.SEPARATOR;
        altSeparatorCached = exports.ALT_SEPARATOR;
        separatorReCached = new RegExp("[" +
            (separatorCached || "").replace(/[-[\]{}()*+?.\\^$|,#\s]/g, "\\$&amp;") +
            (altSeparatorCached || "").replace(/[-[\]{}()*+?.\\^$|,#\s]/g, "\\$&amp;") +
        "]", "g");
    }
    return separatorReCached;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * file system, indicated by an empty string on Unix, and a
 * drive letter followed by a colon on Windows.
 * @returns {Array * String}
 */
exports.split = function (path) {
var parts;
try {
    parts = String(path).split(exports.<span class="apidocCodeKeywordSpan">SEPARATORS_RE</span>());
} catch (exception) {
    throw new Error("Cannot split " + (typeof path) + ", " + JSON.stringify(path));
}
// this special case helps isAbsolute
// distinguish an empty path from an absolute path
// "" -&gt; [] NOT [""]
if (parts.length === 1 &amp;&amp; parts[0] === "")
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.base" id="apidoc.element.q-io.fs_boot.base">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>base
        <span class="apidocSignatureSpan">(path, extension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base = function (path, extension) {
    var base = path.split(exports.SEPARATORS_RE()).pop();
    if (extension)
        base = base.replace(
            new RegExp(regExpEscape(extension) + "$"),
            ""
        );
    return base;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * @returns {String} the extension (e.g., `txt`) of the file
 * at the given path.
 */
exports.extension = function (path) {
    path = exports.<span class="apidocCodeKeywordSpan">base</span>(path);
    path = path.replace(/^\.*/, "");
    var index = path.lastIndexOf(".");
    return index &lt;= 0 ? "" : path.substring(index);
};

})(typeof exports !== "undefined" ? exports : FS_BOOT = {});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.directory" id="apidoc.element.q-io.fs_boot.directory">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>directory
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directory = function (path) {
    path = exports.normal(path);
    var absolute = exports.isAbsolute(path);
    var parts = exports.split(path);
    // XXX needs to be sensitive to the root for
    // Windows compatibility
    if (parts.length) {
        if (parts[parts.length - 1] == "..") {
            parts.push("..");
        } else {
            parts.pop();
        }
    } else {
        parts.unshift("..");
    }
    return parts.join(exports.SEPARATOR) || (
        exports.isRelative(path) ?
        "" : exports.ROOT
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.extension" id="apidoc.element.q-io.fs_boot.extension">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>extension
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extension = function (path) {
    path = exports.base(path);
    path = path.replace(/^\.*/, "");
    var index = path.lastIndexOf(".");
    return index &lt;= 0 ? "" : path.substring(index);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.isAbsolute" id="apidoc.element.q-io.fs_boot.isAbsolute">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>isAbsolute
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAbsolute = function (path) {
    // for absolute paths on any operating system,
    // the first path component always determines
    // whether it is relative or absolute.  On Unix,
    // it is empty, so ["", "foo"].join("/") == "/foo",
    // "/foo".split("/") == ["", "foo"].
    var parts = exports.split(path);
    // split("") == [].  "" is not absolute.
    // split("/") == ["", ""] is absolute.
    // split(?) == [""] does not occur.
    if (parts.length == 0)
        return false;
    return exports.isRoot(parts[0]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var children = [];
var leaf = "";
for (var i = 0; i &lt; arguments.length; i++) {
    var path = String(arguments[i]);
    if (path == "")
        continue;
    var parts = path.split(exports.SEPARATORS_RE());
    if (exports.<span class="apidocCodeKeywordSpan">isAbsolute</span>(path)) {
        root = parts.shift() + exports.SEPARATOR;
        parents = [];
        children = [];
    }
    leaf = parts.pop();
    if (leaf == "." || leaf == "..") {
        parts.push(leaf);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.isRelative" id="apidoc.element.q-io.fs_boot.isRelative">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>isRelative
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRelative = function (path) {
    return !exports.isAbsolute(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       } else {
           parts.pop();
       }
   } else {
       parts.unshift("..");
   }
   return parts.join(exports.SEPARATOR) || (
       exports.<span class="apidocCodeKeywordSpan">isRelative</span>(path) ?
       "" : exports.ROOT
   );
};

/**
* @returns {String} the last component of a path, without
* the given extension if the extension is provided and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.isRoot" id="apidoc.element.q-io.fs_boot.isRoot">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>isRoot
        <span class="apidocSignatureSpan">(first)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRoot = function (first) {
    if (exports.SEPARATOR === "\\") {
        return /[a-zA-Z]:$/.test(first);
    } else {
        return first == "";
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // "/foo".split("/") == ["", "foo"].
    var parts = exports.split(path);
    // split("") == [].  "" is not absolute.
    // split("/") == ["", ""] is absolute.
    // split(?) == [""] does not occur.
    if (parts.length == 0)
        return false;
    return exports.<span class="apidocCodeKeywordSpan">isRoot</span>(parts[0]);
};

/**
 * @returns {Boolean} whether the given path does not begin
 * at the root of the file system or a drive letter.
 */
exports.isRelative = function (path) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.join" id="apidoc.element.q-io.fs_boot.join">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>join
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">join = function () {
    if (arguments.length === 1 &amp;&amp; Array.isArray(arguments[0]))
        return exports.normal.apply(exports, arguments[0]);
    return exports.normal.apply(exports, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return Q.fcall(function () {
        chunks.splice(0, chunks.length).forEach(write, thisp);
    });
};

BufferStream.prototype.read = function () {
    var result;
    result = Reader.<span class="apidocCodeKeywordSpan">join</span>(this._chunks);
    if (this._charset) {
        result = result.toString(this._charset);
    }
    return Q.resolve(result);
};

BufferStream.prototype.write = function (chunk) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.normal" id="apidoc.element.q-io.fs_boot.normal">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>normal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normal = function () {
    var root = "";
    var parents = [];
    var children = [];
    for (var i = 0, ii = arguments.length; i &lt; ii; i++) {
        var path = String(arguments[i]);
        // empty paths have no affect
        if (path === "")
            continue;
        var parts = path.split(exports.SEPARATORS_RE());
        if (exports.isAbsolute(path)) {
            root = parts.shift() + exports.SEPARATOR;
            parents = [];
            children = [];
        }
        for (var j = 0, jj = parts.length; j &lt; jj; j++) {
            var part = parts[j];
            if (part === "." || part === "") {
            } else if (part == "..") {
                if (children.length) {
                    children.pop();
                } else {
                    if (root) {
                    } else {
                        parents.push("..");
                    }
                }
            } else {
                children.push(part);
            }
        }
    }
    path = parents.concat(children).join(exports.SEPARATOR);
    return root + path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return exports.join(parts[0], "");
};

/**
 * @returns {String} the parent directory of the given path.
 */
exports.directory = function (path) {
path = exports.<span class="apidocCodeKeywordSpan">normal</span>(path);
var absolute = exports.isAbsolute(path);
var parts = exports.split(path);
// XXX needs to be sensitive to the root for
// Windows compatibility
if (parts.length) {
    if (parts[parts.length - 1] == "..") {
        parts.push("..");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.resolve" id="apidoc.element.q-io.fs_boot.resolve">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>resolve
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function () {
    var root = "";
    var parents = [];
    var children = [];
    var leaf = "";
    for (var i = 0; i &lt; arguments.length; i++) {
        var path = String(arguments[i]);
        if (path == "")
            continue;
        var parts = path.split(exports.SEPARATORS_RE());
        if (exports.isAbsolute(path)) {
            root = parts.shift() + exports.SEPARATOR;
            parents = [];
            children = [];
        }
        leaf = parts.pop();
        if (leaf == "." || leaf == "..") {
            parts.push(leaf);
            leaf = "";
        }
        for (var j = 0; j &lt; parts.length; j++) {
            var part = parts[j];
            if (part == "." || part == "") {
            } else if (part == "..") {
                if (children.length) {
                    children.pop();
                } else {
                    if (root) {
                    } else {
                        parents.push("..");
                    }
                }
            } else {
                children.push(part);
            }
        };
    }
    path = parents.concat(children).join(exports.SEPARATOR);
    if (path) leaf = exports.SEPARATOR + leaf;
    return root + path + leaf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

BufferStream.prototype.read = function () {
var result;
result = Reader.join(this._chunks);
if (this._charset) {
    result = result.toString(this._charset);
}
return Q.<span class="apidocCodeKeywordSpan">resolve</span>(result);
};

BufferStream.prototype.write = function (chunk) {
if (this._charset) {
    chunk = new Buffer(String(chunk), this._charset);
} else {
    if (!(chunk instanceof Buffer)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.root" id="apidoc.element.q-io.fs_boot.root">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>root
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">root = function (path) {
    if (!exports.isAbsolute(path))
        path = require("./fs").absolute(path);
    var parts = exports.split(path);
    return exports.join(parts[0], "");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.fs_boot.split" id="apidoc.element.q-io.fs_boot.split">
        function <span class="apidocSignatureSpan">q-io.fs_boot.</span>split
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (path) {
    var parts;
    try {
        parts = String(path).split(exports.SEPARATORS_RE());
    } catch (exception) {
        throw new Error("Cannot split " + (typeof path) + ", " + JSON.stringify(path));
    }
    // this special case helps isAbsolute
    // distinguish an empty path from an absolute path
    // "" -&gt; [] NOT [""]
    if (parts.length === 1 &amp;&amp; parts[0] === "")
        return [];
    // "a" -&gt; ["a"]
    // "/a" -&gt; ["", "a"]
    return parts;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * file system, indicated by an empty string on Unix, and a
 * drive letter followed by a colon on Windows.
 * @returns {Array * String}
 */
exports.split = function (path) {
var parts;
try {
    parts = String(path).<span class="apidocCodeKeywordSpan">split</span>(exports.SEPARATORS_RE());
} catch (exception) {
    throw new Error("Cannot split " + (typeof path) + ", " + JSON.stringify(path));
}
// this special case helps isAbsolute
// distinguish an empty path from an absolute path
// "" -&gt; [] NOT [""]
if (parts.length === 1 &amp;&amp; parts[0] === "")
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.fs_common" id="apidoc.module.q-io.fs_common">module q-io.fs_common</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.fs_common.update" id="apidoc.element.q-io.fs_common.update">
        function <span class="apidocSignatureSpan">q-io.fs_common.</span>update
        <span class="apidocSignatureSpan">(exports, workingDirectory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (exports, workingDirectory) {

    for (var name in Boot) {
        exports[name] = Boot[name];
    }

<span class="apidocCodeCommentSpan">    /**
     * Read a complete file.
     * @param {String} path    Path to the file.
     * @param {String} [options.flags]  The mode to open the file with.
     * @param {String} [options.charset]  The charset to open the file with.
     * @param {Object} [options]   An object with options.
     * second argument.
     * @returns {Promise * (String || Buffer)}
     */
</span>    exports.read = function (path, flags, charset, options) {
        if (typeof flags === "object") {
            options = flags;
        } else if (typeof charset === "object") {
            options = charset;
            options.flags = flags;
        } else {
            options = options || {};
            options.flags = flags;
            options.charset = charset;
        }
        options.flags = options.flags || "r";
        return Q.when(this.open(path, options), function (stream) {
            return stream.read();
        }, function (error) {
            error.message = "Can't read " + path + " because " + error.message;
            error.path = path;
            error.flags = flags;
            error.charset = charset;
            throw error;
        });
    };

    /**
     * Write content to a file, overwriting the existing content.
     * @param {String} path    Path to the file.
     * @param {String || Buffer} content
     * @param {String} [options.flags]  The mode to open the file with.
     * @param {String} [options.charset]  The charset to open the file with.
     * @param {Object} [options]   An object with options.
     * @returns {Promise * Undefined} a promise that resolves
     * when the writing is complete.
     */
    exports.write = function (path, content, flags, charset, options) {
        var self = this;
        if (typeof flags === "object") {
            options = flags;
        } else if (typeof charset === "object") {
            options = charset;
            options.flags = flags;
        } else {
            options = options || {};
            options.flags = flags;
            options.charset = charset;
        }
        flags = options.flags || "w";
        if (flags.indexOf("b") !== -1) {
            if (!(content instanceof Buffer)) {
                content = new Buffer(content);
            }
        } else if (content instanceof Buffer) {
            flags += "b";
        }
        options.flags = flags;
        return Q.when(self.open(path, options), function (stream) {
            return Q.when(stream.write(content), function () {
                return stream.close();
            });
        });
    };

    /**
     * Append content to the end of a file.
     * @param {String} path    Path to the file.
     * @param {String || Buffer} content
     * @param {String} [options.flags]  The mode to open the file with.
     * @param {String} [options.charset]  The charset to open the file with.
     * @param {Object} [options]   An object with options.
     * @returns {Promise * Undefined} a promise that resolves
     * when the writing is complete.
     */
    exports.append = function (path, content, flags, charset, options) {
        var self = this;
        if (typeof flags === "object") {
            options = flags;
        } else if (typeof charset === "object") {
            options = charset;
            options.flags = flags;
        } else {
            options = options || {};
            options.flags = flags;
            options.charset = charset;
        }
        flags = options.flags || "a";
        if (content instanceof Buffer) {
            flags += "b";
        }
        options.flags = flags;
        return Q.when(self.open(path, options), function (stream) {
            return Q.when(stream.write(content), function () {
                return stream.close();
            });
        });
    };

    exports.move = function (source, target) {
        var self = this;
        return this.rename(source, target)
        .catch(function (error) {
            if (error.crossDevic ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Q = require("q");
var Reader = require("./reader");
var Writer = require("./writer");
var Common = require("./fs-common");
var Mock = require("./fs-mock");
var Root = require("./fs-root");

Common.<span class="apidocCodeKeywordSpan">update</span>(exports, process.cwd);
exports.Mock = Mock;
exports.Root = Root;

// facilitates AIMD (additive increase, multiplicative decrease) for backing off
var backOffDelay = 0;
var backOffFactor = 1.0001;
function dampen(wrapped, thisp) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.html" id="apidoc.module.q-io.html">module q-io.html</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.html.HandleHtmlFragmentResponses" id="apidoc.element.q-io.html.HandleHtmlFragmentResponses">
        function <span class="apidocSignatureSpan">q-io.html.</span>HandleHtmlFragmentResponses
        <span class="apidocSignatureSpan">(app, handleHtmlFragmentResponse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HandleHtmlFragmentResponses = function (app, handleHtmlFragmentResponse) {
    handleHtmlFragmentResponse = handleHtmlFragmentResponse || exports.handleHtmlFragmentResponse;
    return function (request) {
        request.handleHtmlFragmentResponse = handleHtmlFragmentResponse;
        return Q.fcall(app, request)
        .then(function (response) {
            if (response.htmlFragment) {
                return Q.fcall(handleHtmlFragmentResponse, response);
            } else {
                return response;
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.html.escapeHtml" id="apidoc.element.q-io.html.escapeHtml">
        function <span class="apidocSignatureSpan">q-io.html.</span>escapeHtml
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escapeHtml(text) {
    return String(text)
        .replace(/&amp;/g, "&amp;amp;")
        .replace(/&lt;/g, "&amp;lt;")
        .replace(/&gt;/g, "&amp;gt;")
        .replace(/"/g, "&amp;quot;")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
headers: {
    location: location,
    "content-type": "text/html"
},
htmlTitle: title,
htmlFragment: {
    forEach: function (write) {
        write("&lt;h1&gt;" + HtmlApps.<span class="apidocCodeKeywordSpan">escapeHtml</span>(title) + "&lt;/
h1&gt;\n");
        write(
            "&lt;p&gt;See: &lt;a href=\"" + HtmlApps.escapeHtml(location) + "\"&gt;" +
            HtmlApps.escapeHtml(location) +
            "&lt;/a&gt;&lt;/p&gt;\n"
        );
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.html.handleHtmlFragmentResponse" id="apidoc.element.q-io.html.handleHtmlFragmentResponse">
        function <span class="apidocSignatureSpan">q-io.html.</span>handleHtmlFragmentResponse
        <span class="apidocSignatureSpan">(response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleHtmlFragmentResponse = function (response) {
    var htmlFragment = response.htmlFragment;
    delete response.htmlFragment;
    response.headers["content-type"] = "text/html; charset=utf-8";
    response.body = {
        forEach: function (write) {
            write("&lt;!doctype html&gt;\n");
            write("&lt;html&gt;\n");
            write("    &lt;head&gt;\n");
            if (response.htmlTitle !== void 0) {
                write("        &lt;title&gt;" + escapeHtml(response.htmlTitle) + "&lt;/title&gt;\n");
            }
            write("    &lt;/head&gt;\n");
            write("    &lt;body&gt;\n");
            htmlFragment.forEach(function (line) {
                write("        " + line);
            });
            write("    &lt;/body&gt;\n");
            write("&lt;/html&gt;\n");
        }
    };
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.http" id="apidoc.module.q-io.http">module q-io.http</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.http.ClientResponse" id="apidoc.element.q-io.http.ClientResponse">
        function <span class="apidocSignatureSpan">q-io.http.</span>ClientResponse
        <span class="apidocSignatureSpan">(_response, charset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ClientResponse = function (_response, charset) {
    var response = Object.create(exports.ClientResponse.prototype);
<span class="apidocCodeCommentSpan">    /*** {Number} HTTP status code */
</span>    response.status = _response.statusCode;
    /*** HTTP version */
    response.version = _response.httpVersion;
    /*** {Object} HTTP headers */
    response.headers = _response.headers;
    /***
     * A Q IO asynchronous text reader.
     */
    response.node = _response;
    response.nodeResponse = _response; // Deprecated
    response.nodeConnection = _response.connection; // Deprecated
    return Q.when(Reader(_response, charset), function (body) {
        response.body = body;
        return response;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

if (request.agent !== undefined) {
    requestOptions.agent = request.agent;
}

var _request = http.request(requestOptions, function (_response) {
    deferred.resolve(exports.<span class="apidocCodeKeywordSpan">ClientResponse</span>(_response, request.charset));
    _response.on("error", function (error) {
        // TODO find a better way to channel
        // this into the response
        console.warn(error &amp;&amp; error.stack || error);
        deferred.reject(error);
    });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http.Server" id="apidoc.element.q-io.http.Server">
        function <span class="apidocSignatureSpan">q-io.http.</span>Server
        <span class="apidocSignatureSpan">(respond)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server = function (respond) {
    var self = Object.create(exports.Server.prototype);

    var server = HTTP.createServer(function (_request, _response) {
        var request = exports.ServerRequest(_request);
        var response = exports.ServerResponse(_response);

        var closed = Q.defer();
        _request.on("end", function (error, value) {
            if (error) {
                closed.reject(error);
            } else {
                closed.resolve(value);
            }
        });

        Q.when(request, function (request) {
            return Q.when(respond(request, response), function (response) {
                if (!response)
                    return;

                _response.writeHead(response.status, response.headers);

                if (response.onclose || response.onClose)
                    Q.when(closed, response.onclose || response.onClose);

                return Q.when(response.body, function (body) {
                    var length;
                    if (
                        Array.isArray(body) &amp;&amp;
                        (length = body.length) &amp;&amp;
                        body.every(function (chunk) {
                            return typeof chunk === "string"
                        })
                    ) {
                        body.forEach(function (chunk, i) {
                            if (i &lt; length - 1) {
                                _response.write(chunk, response.charset);
                            } else {
                                _response.end(chunk, response.charset);
                            }
                        });
                    } else if (body) {
                        var end;
                        var done = body.forEach(function (chunk) {
                            end = Q.when(end, function () {
                                return Q.when(chunk, function (chunk) {
                                    _response.write(chunk, response.charset);
                                });
                            });
                        });
                        return Q.when(done, function () {
                            return Q.when(end, function () {
                                _response.end();
                            });
                        });
                    } else {
                        _response.end();
                    }
                });

            })
        })
        .done(); // should be .fail(self.emitter("error"))

    });

    var stopped = Q.defer();
    server.on("close", function (err) {
        if (err) {
            stopped.reject(err);
        } else {
            stopped.resolve();
        }
    });

<span class="apidocCodeCommentSpan">    /***
     * Stops the server.
     * @returns {Promise * Undefined} a promise that will
     * resolve when the server is stopped.
     */
</span>    self.stop = function () {
        server.close();
        listening = undefined;
        return stopped.promise;
    };

    var listening = Q.defer();
    server.on("listening", function (err) {
        if (err) {
            listening.reject(err);
        } else {
            listening.resolve(self);
        }
    });

    /***
     * Starts the server, listening on the given port
     * @param {Number} port
     * @returns {Promise * Undefined} a promise that will
     * resolve when the server is ready to receive
     * connections
     */
    self.listen = function (/*...args*/) {
        if (typeof server.port !== "undefined")
            return Q.reject(new Error("A server cannot be restarted or " +
            "started on a new port"));
        server.listen.apply(server, arguments);
        return listening.promise;
    };

    self.stopped = stopped.promise;

    self.node = server;
    self.nodeServer = server; // Deprecated
    self.address = server.address.bind(server);

    return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http.ServerRequest" id="apidoc.element.q-io.http.ServerRequest">
        function <span class="apidocSignatureSpan">q-io.http.</span>ServerRequest
        <span class="apidocSignatureSpan">(_request, ssl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ServerRequest = function (_request, ssl) {
    var request = Object.create(_request, requestDescriptor);
<span class="apidocCodeCommentSpan">    /*** {Array} HTTP version. (JSGI) */
</span>    request.version = _request.httpVersion.split(".").map(Math.floor);
    /*** {String} HTTP method, e.g., `"GET"` (JSGI) */
    request.method = _request.method;
    /*** {String} path, starting with `"/"` */
    request.path = _request.url;
    /*** {String} pathInfo, starting with `"/"`, the
     * portion of the path that has not yet
     * been routed (JSGI) */
    request._pathInfo = null;
    /*** {String} scriptName, the portion of the path that
     * has already been routed (JSGI) */
    request.scriptName = "";
    /*** {String} (JSGI) */
    request.scheme = "http";

    var address = _request.connection.address();
    /*** {String} hostname */
    if (_request.headers.host) {
        request.hostname = _request.headers.host.split(":")[0];
    } else {
        request.hostname = address.address;
    }
    /*** {String} host */
    request.port = address.port;
    var defaultPort = request.port === (ssl ? 443 : 80);
    request.host = request.hostname + (defaultPort ? "" : ":" + request.port);

    var socket = _request.socket;
    /*** {String} */
    request.remoteHost = socket.remoteAddress;
    /*** {Number} */
    request.remotePort = socket.remotePort;

    /*** {String} url */
    request.url = URL.format({
        protocol: request.scheme,
        host: _request.headers.host,
        port: request.port === (ssl ? 443 : 80) ? null : request.port,
        path: request.path
    });
    /*** A Q IO asynchronous text reader */
    request.body = Reader(_request);
    /*** {Object} HTTP headers (JSGI)*/
    request.headers = _request.headers;
    /*** The underlying Node request */
    request.node = _request;
    request.nodeRequest = _request; // Deprecated
    /*** The underlying Node TCP connection */
    request.nodeConnection = _request.connection;

    return Q.when(request.body, function (body) {
        request.body = body;
        return request;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * written.
 * @returns a Node Server object.
 */
exports.Server = function (respond) {
    var self = Object.create(exports.Server.prototype);

    var server = HTTP.createServer(function (_request, _response) {
var request = exports.<span class="apidocCodeKeywordSpan">ServerRequest</span>(_request);
var response = exports.ServerResponse(_response);

var closed = Q.defer();
_request.on("end", function (error, value) {
    if (error) {
        closed.reject(error);
    } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http.ServerResponse" id="apidoc.element.q-io.http.ServerResponse">
        function <span class="apidocSignatureSpan">q-io.http.</span>ServerResponse
        <span class="apidocSignatureSpan">(_response, ssl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ServerResponse = function (_response, ssl) {
    var response = Object.create(_response);
    response.ssl = ssl;
    response.node = _response;
    response.nodeResponse = _response; // Deprecated
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns a Node Server object.
 */
exports.Server = function (respond) {
    var self = Object.create(exports.Server.prototype);

    var server = HTTP.createServer(function (_request, _response) {
var request = exports.ServerRequest(_request);
var response = exports.<span class="apidocCodeKeywordSpan">ServerResponse</span>(_response);

var closed = Q.defer();
_request.on("end", function (error, value) {
    if (error) {
        closed.reject(error);
    } else {
        closed.resolve(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http.normalizeRequest" id="apidoc.element.q-io.http.normalizeRequest">
        function <span class="apidocSignatureSpan">q-io.http.</span>normalizeRequest
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeRequest = function (request) {
    if (typeof request === "string") {
        request = {url: request};
    }
    request.method = request.method || "GET";
    request.headers = request.headers || {};
    if (request.url) {
        var url = URL.parse(request.url);
        request.ssl = url.protocol === "https:";
        request.hostname = url.hostname;
        request.host = url.host;
        request.port = +url.port;
        request.path = (url.pathname || "") + (url.search || "");
        request.auth = url.auth || void 0;
    }
    request.host = request.host || request.headers.host;
    request.port = request.port || (request.ssl ? 443 : 80);
    if (request.host &amp;&amp; !request.hostname) {
        request.hostname = request.host.split(":")[0];
    }
    if (request.hostname &amp;&amp; request.port &amp;&amp; !request.host) {
        var defaultPort = request.ssl ? 443 : 80;
        request.host = request.hostname + (defaultPort ? "" : ":" + request.port);
    }
    request.headers.host = request.headers.host || request.host;
    request.path = request.path || "/";
    return request;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.Client = Client;
function Client(fs) {
var self = Object.create(Client.prototype);

self.request = function (request) {
    return Q.when(request, function (request) {
        request = HTTP.<span class="apidocCodeKeywordSpan">normalizeRequest</span>(request);
        var url = URL.parse(request.url);
        if (url.protocol !== "file:") {
            return {
                status: 404,
                headers: {},
                body: ["Can't access protocol " + url.protocol]
            };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http.normalizeResponse" id="apidoc.element.q-io.http.normalizeResponse">
        function <span class="apidocSignatureSpan">q-io.http.</span>normalizeResponse
        <span class="apidocSignatureSpan">(response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeResponse = function (response) {
    if (response === void 0) {
        return;
    }
    if (typeof response == "string") {
        response = [response];
    }
    if (response.forEach) {
        response = {
            status: 200,
            headers: {},
            body: response
        }
    }
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var RouteApps = require("./route");
var StatusApps = require("./status");

exports.Normalize = function (app) {
return function (request, response) {
    var request = HTTP.normalizeRequest(request);
    return Q.when(app(request, response), function (response) {
        return HTTP.<span class="apidocCodeKeywordSpan">normalizeResponse</span>(response);
    });
};
};

exports.Date = function (app, present) {
present = present || function () {
    return new Date();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http.read" id="apidoc.element.q-io.http.read">
        function <span class="apidocSignatureSpan">q-io.http.</span>read
        <span class="apidocSignatureSpan">(request, qualifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (request, qualifier) {
    qualifier = qualifier || function (response) {
        return response.status === 200;
    };
    return Q.when(exports.request(request), function (response) {
        if (!qualifier(response)){
            var error = new Error("HTTP request failed with code " + response.status);
            error.response = response;
            throw error;
        }
        return Q.post(response.body, 'read', []);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
into memory.  It returns a promise for the whole file contents.  By
default, `read` provides a string decoded from UTF-8.  With the bytewise
mode flag, provides a `Buffer`.

The options argument is identical to that of `open`.

```javascript
return FS.<span class="apidocCodeKeywordSpan">read</span>(__filename, "b")
.then(function (content) {
    // ...
})
```

```javascript
return FS.read(__filename, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http.request" id="apidoc.element.q-io.http.request">
        function <span class="apidocSignatureSpan">q-io.http.</span>request
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">request = function (request) {
    return Q.when(request, function (request) {

        request = exports.normalizeRequest(request);

        var deferred = Q.defer();
        var http = request.ssl ? HTTPS : HTTP;

        var requestOptions = {
            hostname: request.hostname,
            port: request.port || (request.ssl ? 443 : 80),
            localAddress: request.localAddress,
            socketPath: request.socketPath,
            method: request.method,
            path: request.path,
            headers: request.headers,
            auth: request.auth // Generates the appropriate header
        };

        if (request.agent !== undefined) {
            requestOptions.agent = request.agent;
        }

        var _request = http.request(requestOptions, function (_response) {
            deferred.resolve(exports.ClientResponse(_response, request.charset));
            _response.on("error", function (error) {
                // TODO find a better way to channel
                // this into the response
                console.warn(error &amp;&amp; error.stack || error);
                deferred.reject(error);
            });
        });

        _request.on("error", function (error) {
            deferred.reject(error);
        });

        if (request.timeout) {
            _request.setTimeout(request.timeout, function() {
                _request.abort();
            });
        }

        Q.when(request.body, function (body) {
            var end, done;
            if (body) {
                done = body.forEach(function (chunk) {
                    end = Q.when(end, function () {
                        return Q.when(chunk, function (chunk) {
                            _request.write(chunk, request.charset);
                        });
                    });
                });
            }
            return Q.when(end, function () {
                return Q.when(done, function () {
                    _request.end();
                });
            });
        }).done();

        return deferred.promise;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
};

self.read = function (request, qualifier) {
    qualifier = qualifier || function (response) {
        return response.status === 200;
    };
    return Q.when(exports.<span class="apidocCodeKeywordSpan">request</span>(request), function (response) {
        if (!qualifier(response)){
            var error = new Error("HTTP request failed with code " + response.status);
            error.response = response;
            throw error;
        }
        return Q.invoke(response.body, "read");
    });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.http_apps" id="apidoc.module.q-io.http_apps">module q-io.http_apps</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.http_apps.Branch" id="apidoc.element.q-io.http_apps.Branch">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Branch
        <span class="apidocSignatureSpan">(paths, notFound)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Branch = function (paths, notFound) {
    if (!paths)
        paths = {};
    if (!notFound)
        notFound = StatusApps.notFound;
    return function (request, response) {
        if (!/^\//.test(request.pathInfo)) {
            return notFound(request, response);
        }
        var path = request.pathInfo.slice(1);
        var parts = path.split("/");
        var part = decodeURIComponent(parts.shift());
        if (Object.has(paths, part)) {
            request.scriptName = request.scriptName + part + "/";
            request.pathInfo = path.slice(part.length);
            return Object.get(paths, part)(request, response);
        }
        return notFound(request, response);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Cap" id="apidoc.element.q-io.http_apps.Cap">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Cap
        <span class="apidocSignatureSpan">(app, notFound)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Cap = function (app, notFound) {
    notFound = notFound || StatusApps.notFound;
    return function (request, response) {
        // TODO Distinguish these cases
        if (request.pathInfo === "" || request.pathInfo === "/") {
            return app(request, response);
        } else {
            return notFound(request, response);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Chain" id="apidoc.element.q-io.http_apps.Chain">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Chain
        <span class="apidocSignatureSpan">(end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(end) {
    var self = Object.create(Chain.prototype);
    self.end = end || function (next) {
        return next;
    };
    return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Charset" id="apidoc.element.q-io.http_apps.Charset">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Charset
        <span class="apidocSignatureSpan">(types, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Charset = function (types, notAcceptable) {
    var keys = Object.keys(types);
    if (!notAcceptable)
        notAcceptable = Status.notAcceptable;
    return function (request) {
        var accept = request.headers[requestHeader] || "*";
        var type = MimeParse.bestMatch(keys, accept);
        request.terms = request.terms || {};
        request.terms[responseHeader] = type;
        if (Object.has(keys, type)) {
            return Q.when(types[type](request), function (response) {
                if (
                    respond !== null &amp;&amp;
                    response &amp;&amp;
                    response.status === 200 &amp;&amp;
                    response.headers
                ) {
                    response.headers[responseHeader] = type;
                }
                return response;
            });
        } else {
            return notAcceptable(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Content" id="apidoc.element.q-io.http_apps.Content">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Content
        <span class="apidocSignatureSpan">(body, contentType, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Content = function (body, contentType, status) {
    return function () {
        return exports.content(body, contentType, status);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.ContentRequest" id="apidoc.element.q-io.http_apps.ContentRequest">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>ContentRequest
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ContentRequest = function (app) {
    return function (request, response) {
        return Q.when(request.body.read(), function (body) {
            return app(body, request, response);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function(Request, Object):Response} app
 * @param {App} badRequest
 * @returns {App}
 */
exports.JsonRequest = function (app, badRequest) {
if (!badRequest)
    badRequest = Status.badRequest;
return Content.<span class="apidocCodeKeywordSpan">ContentRequest</span>(function (content, request, response) {
    try {
        var object = JSON.parse(content);
    } catch (error) {
        return badRequest(request, error);
    }
    return app(object, request, response);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.ContentType" id="apidoc.element.q-io.http_apps.ContentType">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>ContentType
        <span class="apidocSignatureSpan">(types, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ContentType = function (types, notAcceptable) {
    var keys = Object.keys(types);
    if (!notAcceptable)
        notAcceptable = Status.notAcceptable;
    return function (request) {
        var accept = request.headers[requestHeader] || "*";
        var type = MimeParse.bestMatch(keys, accept);
        request.terms = request.terms || {};
        request.terms[responseHeader] = type;
        if (Object.has(keys, type)) {
            return Q.when(types[type](request), function (response) {
                if (
                    respond !== null &amp;&amp;
                    response &amp;&amp;
                    response.status === 200 &amp;&amp;
                    response.headers
                ) {
                    response.headers[responseHeader] = type;
                }
                return response;
            });
        } else {
            return notAcceptable(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.CookieJar" id="apidoc.element.q-io.http_apps.CookieJar">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>CookieJar
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CookieJar = function (app) {
    var hostCookies = {}; // to {} of pathCookies to [] of cookies
    return function (request) {

        if (!request.headers.host) {
            throw new Error("Requests must have a host header");
        }
        var hosts = allHostsContaining(request.headers.host);

        var now = new Date();

        // delete expired cookies
        for (var host in hostCookies) {
            var pathCookies = hostCookies[host];
            for (var path in pathCookies) {
                var cookies = pathCookies[path];
                for (var name in cookies) {
                    var cookie = cookies[name];
                    if (cookie.expires &amp;&amp; cookie.expires &gt; now) {
                        delete cookie[name];
                    }
                }
            }
        }

        // collect applicable cookies
        var requestCookies = concat(
            Object.keys(hostCookies)
            .map(function (host) {
                if (!hostContains(host, request.headers.host)) {
                    return [];
                }
                var pathCookies = hostCookies[host];
                return concat(
                    Object.keys(pathCookies)
                    .map(function (path) {
                        if (!pathContains(path, request.path))
                            return [];
                        var cookies = pathCookies[path];
                        return (
                            Object.keys(cookies)
                            .map(function (name) {
                                return cookies[name];
                            })
                            .filter(function (cookie) {
                                return cookie.secure ?
                                    request.ssl :
                                    true;
                            })
                        );
                    })
                )
            })
        );

        if (requestCookies.length) {
            request.headers["cookie"] = (
                requestCookies
                .map(function (cookie) {
                    return Cookie.stringify(
                        cookie.key,
                        cookie.value
                    );
                })
                .join("; ")
            );
        }

        return Q.when(app.apply(this, arguments), function (response) {
            response.headers = response.headers || {};
            if (response.headers["set-cookie"]) {
                var host = request.headers.host;
                var hostParts = splitHost(host);
                var hostname = hostParts[0];
                var requestHost = ipRe.test(hostname) ? host : "." + host;
                // normalize to array
                if (!Array.isArray(response.headers["set-cookie"])) {
                    response.headers["set-cookie"] = [response.headers["set-cookie"]];
                }
                response.headers["set-cookie"].forEach(function (cookie) {
                    var date = response.headers["date"] ?
                        new Date(response.headers["date"]) :
                        new Date();
                    cookie = Cookie.parse(cookie, date);
                    // ignore illegal host
                    if (cookie.host &amp;&amp; !hostContains(requestHost, cookie.host))
                        delete cookie.host;
                    var host = requestHost || cookie.host;
                    var path = cookie.path || "/";
                    var pathCookies = hostCookies[host] = hostCookies[host] || {};
                    var cookies = pathCookies[path] = pathCookies[path] || {};
                    cookies[cookie.key] = cookie;
                })
                delete response.headers["set-cookie"];
            }

            return response;
        });

    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Date" id="apidoc.element.q-io.http_apps.Date">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Date
        <span class="apidocSignatureSpan">(app, present)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Date = function (app, present) {
    present = present || function () {
        return new Date();
    };
    return RouteApps.Trap(app, function (response, request) {
        response.headers["date"] = "" + present();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Debug" id="apidoc.element.q-io.http_apps.Debug">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Debug
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Debug = function (app) {
    return exports.Error(app, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Decorators" id="apidoc.element.q-io.http_apps.Decorators">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Decorators
        <span class="apidocSignatureSpan">(decorators, app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Decorators = function (decorators, app) {
    decorators.reversed().forEach(function (Middleware) {
        app = Middleware(app);
    });
    return app;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.DirectoryIndex" id="apidoc.element.q-io.http_apps.DirectoryIndex">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>DirectoryIndex
        <span class="apidocSignatureSpan">(app, indexFile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DirectoryIndex = function (app, indexFile) {
    indexFile = indexFile || "index.html";
    return function (request) {
        request.directoryIndex = true;
        request.location = URL.parse(request.path);
        // redirect index.html to containing directory
        // TODO worry about whether this file actually exists
        if (request.location.file === indexFile) {
            return RedirectApps.redirect(request, ".");
        } else {
            return Q.fcall(app, request)
            .then(function (response) {
                if (response.directory !== void 0) {
                    if (request.location.file) {
                        return RedirectApps.redirect(request, request.location.file + "/");
                    } else {
                        var index = request.fs.join(response.directory, indexFile);
                        return Q.invoke(request.fs, "isFile", index)
                        .then(function (isFile) {
                            if (isFile) {
                                request.url = URL.resolve(request.url, indexFile);
                                request.pathInfo += indexFile;
                                return app(request);
                            } else {
                                return response;
                            }
                        });
                    }
                } else {
                    return response;
                }
            });
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Encoding" id="apidoc.element.q-io.http_apps.Encoding">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Encoding
        <span class="apidocSignatureSpan">(types, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Encoding = function (types, notAcceptable) {
    var keys = Object.keys(types);
    if (!notAcceptable)
        notAcceptable = Status.notAcceptable;
    return function (request) {
        var accept = request.headers[requestHeader] || "*";
        var type = MimeParse.bestMatch(keys, accept);
        request.terms = request.terms || {};
        request.terms[responseHeader] = type;
        if (Object.has(keys, type)) {
            return Q.when(types[type](request), function (response) {
                if (
                    respond !== null &amp;&amp;
                    response &amp;&amp;
                    response.status === 200 &amp;&amp;
                    response.headers
                ) {
                    response.headers[responseHeader] = type;
                }
                return response;
            });
        } else {
            return notAcceptable(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Error" id="apidoc.element.q-io.http_apps.Error">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Error
        <span class="apidocSignatureSpan">(app, debug)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error = function (app, debug) {
    return function (request, response) {
        return Q.when(app(request, response), null, function (error) {
            if (!debug)
                error = undefined;
            return StatusApps.responseForStatus(request, 500, error &amp;&amp; error.stack || error);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
               error = undefined;
           return StatusApps.responseForStatus(request, 500, error &amp;&amp; error.stack || error);
       });
   };
};

exports.Debug = function (app) {
   return exports.<span class="apidocCodeKeywordSpan">Error</span>(app, true);
};

/**
* Decorates a Q-JSGI application such that all requests and responses
* are logged.
*
* @param {App} app
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.File" id="apidoc.element.q-io.http_apps.File">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>File
        <span class="apidocSignatureSpan">(path, contentType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">File = function (path, contentType) {
    return function (request, response) {
        return exports.file(request, String(path), contentType);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.FileTree" id="apidoc.element.q-io.http_apps.FileTree">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>FileTree
        <span class="apidocSignatureSpan">(root, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FileTree = function (root, options) {
    if (!options)
        options = {};
    options.notFound = options.notFound || StatusApps.notFound;
    options.file = options.file || exports.file;
    options.directory = options.directory || exports.directory;
    options.fs = options.fs || FS;
    var fs = options.fs;
    root = fs.canonical(root);
    return function (request, response) {
        var location = URL.parse(request.url);
        request.fs = fs;
        var redirect = options.redirect || (
            request.permanent || options.permanent ?
            RedirectApps.permanentRedirect :
            RedirectApps.temporaryRedirect
        );
        return Q.when(root, function (root) {
            var path = fs.join(root, request.pathInfo.slice(1));
            return Q.when(fs.canonical(path), function (canonical) {
                //TODO remove for 2.0.0
                if (options.followInsecureSymlinks) {
                    Deprecate.deprecationWarning("followInsecureSymlinks", "followInsecureSymbolicLinks");
                    options.followInsecureSymbolicLinks = true;
                }
                if (!fs.contains(root, canonical) &amp;&amp; !options.followInsecureSymbolicLinks)
                    return options.notFound(request, response);
                if (path !== canonical &amp;&amp; options.redirectSymbolicLinks)
                    return redirect(request, fs.relativeFromFile(path, canonical));
                // TODO: relativeFromFile should be designed for URLs, not generalized paths.
                // HTTP.relative(pathToDirectoryLocation(path), pathToFile/DirectoryLocation(canonical))
                return Q.when(fs.stat(canonical), function (stat) {
                    if (stat.isFile()) {
                        return options.file(request, canonical, options.contentType, fs);
                    } else if (stat.isDirectory()) {
                        return options.directory(request, canonical, options.contentType, fs);
                    } else {
                        return options.notFound(request, response);
                    }
                });
            }, function (reason) {
                return options.notFound(request, response);
            });
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.HandleHtmlFragmentResponses" id="apidoc.element.q-io.http_apps.HandleHtmlFragmentResponses">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>HandleHtmlFragmentResponses
        <span class="apidocSignatureSpan">(app, handleHtmlFragmentResponse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HandleHtmlFragmentResponses = function (app, handleHtmlFragmentResponse) {
    handleHtmlFragmentResponse = handleHtmlFragmentResponse || exports.handleHtmlFragmentResponse;
    return function (request) {
        request.handleHtmlFragmentResponse = handleHtmlFragmentResponse;
        return Q.fcall(app, request)
        .then(function (response) {
            if (response.htmlFragment) {
                return Q.fcall(handleHtmlFragmentResponse, response);
            } else {
                return response;
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.HandleJsonResponses" id="apidoc.element.q-io.http_apps.HandleJsonResponses">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>HandleJsonResponses
        <span class="apidocSignatureSpan">(app, reviver, tab)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HandleJsonResponses = function (app, reviver, tab) {
    return function (request) {
        request.handleJsonResponse = exports.handleJsonResponse;
        return Q.fcall(app, request)
        .then(function (response) {
            if (response.data !== void 0) {
                return Q.fcall(exports.handleJsonResponse, response, reviver, tab);
            } else {
                return response;
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Headers" id="apidoc.element.q-io.http_apps.Headers">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Headers
        <span class="apidocSignatureSpan">(app, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Headers = function (app, headers) {
    return function (request, response) {
        return Q.when(app(request, response), function (response) {
            if (response &amp;&amp; response.headers) {
                Object.keys(headers).forEach(function (key) {
                    if (!(key in response.headers)) {
                        response.headers[key] = headers[key];
                    }
                });
            }
            return response;
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Host" id="apidoc.element.q-io.http_apps.Host">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Host
        <span class="apidocSignatureSpan">(appForHost, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Host = function (appForHost, notAcceptable) {
    var table = Object.keys(appForHost).map(function (pattern) {
        var parts = pattern.split(":");
        return [
            pattern,
            parts[0] || "*",
            parts[1] || "*",
            appForHost[pattern]
        ];
    });
    if (!notAcceptable) {
        notAcceptable = Status.notAcceptable;
    }
    return function (request) {
        // find first matching host for app
        for (var index = 0; index &lt; table.length; index++) {
            var row = table[index]; // [hostname, port, app]
            var pattern = row[0];
            var hostname = row[1];
            var port = row[2];
            var app = row[3];
            if (
                (hostname === "*" || hostname === request.hostname) &amp;&amp;
                (port === "*" || port === "" + request.port)
            ) {
                request.terms = request.terms || {};
                request.terms.host = pattern;
                return app(request);
            }
        }
        return notAcceptable(request);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Inspect" id="apidoc.element.q-io.http_apps.Inspect">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Inspect
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Inspect = function (app) {
    return Negotiate.Method({"GET": function (request, response) {
        return Q.when(app(request, response), function (object) {
            return {
                status: 200,
                headers: {
                    "content-type": "text/plain"
                },
                body: [inspect(object)]
            }
        });
    }});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Json" id="apidoc.element.q-io.http_apps.Json">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Json
        <span class="apidocSignatureSpan">(app, reviver, tabs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Json = function (app, reviver, tabs) {
    return function (request, response) {
        return Q.when(app(request, response), function (object) {
            return exports.json(object, reviver, tabs);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.JsonRequest" id="apidoc.element.q-io.http_apps.JsonRequest">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>JsonRequest
        <span class="apidocSignatureSpan">(app, badRequest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JsonRequest = function (app, badRequest) {
    if (!badRequest)
        badRequest = Status.badRequest;
    return Content.ContentRequest(function (content, request, response) {
        try {
            var object = JSON.parse(content);
        } catch (error) {
            return badRequest(request, error);
        }
        return app(object, request, response);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Language" id="apidoc.element.q-io.http_apps.Language">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Language
        <span class="apidocSignatureSpan">(types, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Language = function (types, notAcceptable) {
    var keys = Object.keys(types);
    if (!notAcceptable)
        notAcceptable = Status.notAcceptable;
    return function (request) {
        var accept = request.headers[requestHeader] || "*";
        var type = MimeParse.bestMatch(keys, accept);
        request.terms = request.terms || {};
        request.terms[responseHeader] = type;
        if (Object.has(keys, type)) {
            return Q.when(types[type](request), function (response) {
                if (
                    respond !== null &amp;&amp;
                    response &amp;&amp;
                    response.status === 200 &amp;&amp;
                    response.headers
                ) {
                    response.headers[responseHeader] = type;
                }
                return response;
            });
        } else {
            return notAcceptable(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.ListDirectories" id="apidoc.element.q-io.http_apps.ListDirectories">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>ListDirectories
        <span class="apidocSignatureSpan">(app, listDirectory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ListDirectories = function (app, listDirectory) {
    listDirectory = listDirectory || exports.listDirectory;
    return function (request) {
        if (request.directoryIndex) {
            throw new Error("DirectoryIndex must be used after ListDirectories");
        }
        request.listDirectories = true;
        return Q.fcall(app, request)
        .then(function (response) {
            if (response.directory !== void 0) {
                return listDirectory(request, response);
            } else {
                return response;
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Log" id="apidoc.element.q-io.http_apps.Log">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Log
        <span class="apidocSignatureSpan">(app, log, stamp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Log = function (app, log, stamp) {
    log = log || console.log;
    stamp = stamp || function (message) {
        return new Date().toISOString() + " " + message;
    };
    return function (request, response) {
        var remoteHost =
            request.remoteHost + ":" +
            request.remotePort;
        var requestLine =
            request.method + " " +
            request.path + " " +
            "HTTP/" + request.version.join(".");
        log(stamp(
            remoteHost + " " +
            "--&gt;     " +
            requestLine
        ));
        return Q.when(app(request, response), function (response) {
            if (response) {
                log(stamp(
                    remoteHost + " " +
                    "&lt;== " +
                    response.status + " " +
                    requestLine + " " +
                    (response.headers["content-length"] || "-")
                ));
            } else {
                log(stamp(
                    remoteHost + " " +
                    "... " +
                    "... " +
                    requestLine + " (response undefined / presumed streaming)"
                ));
            }
            return response;
        }, function (reason) {
            log(stamp(
                remoteHost + " " +
                "!!!     " +
                requestLine + " " +
                (reason &amp;&amp; reason.message || reason)
            ));
            return Q.reject(reason);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Method" id="apidoc.element.q-io.http_apps.Method">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Method
        <span class="apidocSignatureSpan">(methods, methodNotAllowed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Method = function (methods, methodNotAllowed) {
    var keys = Object.keys(methods);
    if (!methodNotAllowed)
        methodNotAllowed = Status.methodNotAllowed;
    return function (request) {
        var method = request.method;
        if (Object.has(keys, method)) {
            return Object.get(methods, method)(request);
        } else {
            return methodNotAllowed(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * @param {Function(Request):Object}
 * @returns {App}
 */
exports.Inspect = function (app) {
return Negotiate.<span class="apidocCodeKeywordSpan">Method</span>({"GET": function (request, response) {
    return Q.when(app(request, response), function (object) {
        return {
            status: 200,
            headers: {
                "content-type": "text/plain"
            },
            body: [inspect(object)]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Normalize" id="apidoc.element.q-io.http_apps.Normalize">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Normalize
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Normalize = function (app) {
    return function (request, response) {
        var request = HTTP.normalizeRequest(request);
        return Q.when(app(request, response), function (response) {
            return HTTP.normalizeResponse(response);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.ParseQuery" id="apidoc.element.q-io.http_apps.ParseQuery">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>ParseQuery
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ParseQuery = function (app) {
    return function (request, response) {
        request.query = QS.parse(URL.parse(request.url).query || "");
        return app(request, response);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Permanent" id="apidoc.element.q-io.http_apps.Permanent">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Permanent
        <span class="apidocSignatureSpan">(app, future)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Permanent = function (app, future) {
    future = future || function () {
        return new Date(new Date().getTime() + farFuture);
    };
    app = RouteApps.Tap(app, function (request, response) {
        request.permanent = future;
    });
    app = RouteApps.Trap(app, function (response, request) {
        response.headers["expires"] = "" + future();
    });
    return app;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.PermanentRedirect" id="apidoc.element.q-io.http_apps.PermanentRedirect">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>PermanentRedirect
        <span class="apidocSignatureSpan">(location, status, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PermanentRedirect = function (location, status, tree) {
    return function (request, response) {
        return exports.permanentRedirect(request, location, status, tree);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.PermanentRedirectTree" id="apidoc.element.q-io.http_apps.PermanentRedirectTree">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>PermanentRedirectTree
        <span class="apidocSignatureSpan">(location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PermanentRedirectTree = function (location, status) {
    return function (request, response) {
        return exports.permanentRedirect(request, location, status, true);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Proxy" id="apidoc.element.q-io.http_apps.Proxy">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Proxy
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Proxy = function (app) {
    if (typeof app === "string") {
        var location = app;
        app = function (request) {
            request.url = location;
            return request;
        };
    }
    return function (request, response) {
        return Q.when(app.apply(this, arguments), function (request) {
            return HTTP.request(request);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return Q.when(app.apply(this, arguments), function (request) {
            return HTTP.request(request);
        });
    };
};

exports.ProxyTree = function (url) {
    return exports.<span class="apidocCodeKeywordSpan">Proxy</span>(function (request) {
        request.url = URL.resolve(url, request.pathInfo.replace(/^\//, ""));
        return request;
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.ProxyTree" id="apidoc.element.q-io.http_apps.ProxyTree">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>ProxyTree
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ProxyTree = function (url) {
    return exports.Proxy(function (request) {
        request.url = URL.resolve(url, request.pathInfo.replace(/^\//, ""));
        return request;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Redirect" id="apidoc.element.q-io.http_apps.Redirect">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Redirect
        <span class="apidocSignatureSpan">(location, status, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Redirect = function (location, status, tree) {
    return function (request, response) {
        return exports.redirect(request, location, status, tree);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.RedirectTrap" id="apidoc.element.q-io.http_apps.RedirectTrap">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>RedirectTrap
        <span class="apidocSignatureSpan">(app, maxRedirects)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RedirectTrap = function (app, maxRedirects) {
    maxRedirects = maxRedirects || 20;
    return function (request, response) {
        var remaining = maxRedirects;
        var deferred = Q.defer();
        var self = this;
        var args = arguments;

        request = Http.normalizeRequest(request);

        // try redirect loop
        function next() {
            Q.fcall(function () {
                return app(request, response);
            })
            .then(function (response) {
                if (exports.isRedirect(response)) {
                    if (remaining--) {
                        request.url = response.headers.location;
                        next();
                    } else {
                        throw new Error("Maximum redirects.");
                    }
                } else {
                    deferred.resolve(response);
                }
            })
            .fail(deferred.reject)
        }
        next();

        return deferred.promise;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.RedirectTree" id="apidoc.element.q-io.http_apps.RedirectTree">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>RedirectTree
        <span class="apidocSignatureSpan">(location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RedirectTree = function (location, status) {
    return function (request, response) {
        return exports.redirect(request, location, status, true);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Select" id="apidoc.element.q-io.http_apps.Select">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Select
        <span class="apidocSignatureSpan">(select)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Select = function (select) {
    return function (request) {
        return Q.when(select(request), function (app) {
            return app(request);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Tap" id="apidoc.element.q-io.http_apps.Tap">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Tap
        <span class="apidocSignatureSpan">(app, tap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Tap = function (app, tap) {
    return function (request, response) {
        var self = this, args = arguments;
        return Q.when(tap.apply(this, arguments), function (response) {
            if (response) {
                return response;
            } else {
                return app.apply(self, args);
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    24 * // h
    365 * // d
    10; // years
exports.Permanent = function (app, future) {
    future = future || function () {
        return new Date(new Date().getTime() + farFuture);
    };
    app = RouteApps.<span class="apidocCodeKeywordSpan">Tap</span>(app, function (request, response) {
        request.permanent = future;
    });
    app = RouteApps.Trap(app, function (response, request) {
        response.headers["expires"] = "" + future();
    });
    return app;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.TemporaryRedirect" id="apidoc.element.q-io.http_apps.TemporaryRedirect">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>TemporaryRedirect
        <span class="apidocSignatureSpan">(location, status, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TemporaryRedirect = function (location, status, tree) {
    return function (request, response) {
        return exports.temporaryRedirect(request, location, status, tree);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.TemporaryRedirectTree" id="apidoc.element.q-io.http_apps.TemporaryRedirectTree">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>TemporaryRedirectTree
        <span class="apidocSignatureSpan">(location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TemporaryRedirectTree = function (location, status) {
    return function (request, response) {
        return exports.temporaryRedirect(request, location, status, true);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Time" id="apidoc.element.q-io.http_apps.Time">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Time
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Time = function (app) {
    return function (request, response) {
        var start = new Date();
        return Q.when(app(request, response), function (response) {
            var stop = new Date();
            if (response &amp;&amp; response.headers) {
                response.headers["x-response-time"] = "" + (stop - start);
            }
            return response;
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.Trap" id="apidoc.element.q-io.http_apps.Trap">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>Trap
        <span class="apidocSignatureSpan">(app, trap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Trap = function (app, trap) {
    return function (request, response) {
        return Q.when(app.apply(this, arguments), function (response) {
            if (response) {
                response.headers = response.headers || {};
                return trap(response, request) || response;
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   };
};

exports.Date = function (app, present) {
   present = present || function () {
       return new Date();
   };
   return RouteApps.<span class="apidocCodeKeywordSpan">Trap</span>(app, function (response, request) {
       response.headers["date"] = "" + present();
   });
};

/**
* Decorates a JSGI application such that rejected response promises
* get translated into `500` server error responses with no content.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.appForStatus" id="apidoc.element.q-io.http_apps.appForStatus">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>appForStatus
        <span class="apidocSignatureSpan">(status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appForStatus = function (status) {
    return function (request) {
        return exports.responseForStatus(request, status, request.method + " " + request.path);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       }
   }
};

/**
* {App} an application that returns a 400 response.
*/
exports.badRequest = exports.<span class="apidocCodeKeywordSpan">appForStatus</span>(400);
/**
* {App} an application that returns a 404 response.
*/
exports.notFound = exports.appForStatus(404);
/**
* {App} an application that returns a 405 response.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.badRequest" id="apidoc.element.q-io.http_apps.badRequest">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>badRequest
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">badRequest = function (request) {
    return exports.responseForStatus(request, status, request.method + " " + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.content" id="apidoc.element.q-io.http_apps.content">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>content
        <span class="apidocSignatureSpan">(content, contentType, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">content = function (content, contentType, status) {
    status = status || 200;
    content = content || "";
    if (typeof content === "string") {
        content = [content];
    }
    contentType = contentType || "text/plain";
    return {
        "status": status,
        "headers": {
            "content-type": contentType
        },
        "body": content
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* response body
* @param {String} contentType
* @param {Number} status
* @returns {App} a Q-JSGI app
*/
exports.Content = function (body, contentType, status) {
   return function () {
       return exports.<span class="apidocCodeKeywordSpan">content</span>(body, contentType, status);
   };
};

/**
* Returns a Q-JSGI response with the given content.
* @param {Body} content (optional) defaults to `[""]`
* @param {String} contentType (optional) defaults to `"text/plain"`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.directory" id="apidoc.element.q-io.http_apps.directory">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>directory
        <span class="apidocSignatureSpan">(request, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directory = function (request, path) {
    var response = StatusApps.notFound(request);
    response.directory = path;
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.escapeHtml" id="apidoc.element.q-io.http_apps.escapeHtml">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>escapeHtml
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escapeHtml(text) {
    return String(text)
        .replace(/&amp;/g, "&amp;amp;")
        .replace(/&lt;/g, "&amp;lt;")
        .replace(/&gt;/g, "&amp;gt;")
        .replace(/"/g, "&amp;quot;")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
headers: {
    location: location,
    "content-type": "text/html"
},
htmlTitle: title,
htmlFragment: {
    forEach: function (write) {
        write("&lt;h1&gt;" + HtmlApps.<span class="apidocCodeKeywordSpan">escapeHtml</span>(title) + "&lt;/
h1&gt;\n");
        write(
            "&lt;p&gt;See: &lt;a href=\"" + HtmlApps.escapeHtml(location) + "\"&gt;" +
            HtmlApps.escapeHtml(location) +
            "&lt;/a&gt;&lt;/p&gt;\n"
        );
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.etag" id="apidoc.element.q-io.http_apps.etag">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>etag
        <span class="apidocSignatureSpan">(stat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">etag = function (stat) {
    return [
        stat.node.ino,
        stat.size,
        stat.lastModified().getTime()
    ].join("-");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.file" id="apidoc.element.q-io.http_apps.file">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>file
        <span class="apidocSignatureSpan">(request, path, contentType, fs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file = function (request, path, contentType, fs) {
    fs = fs || FS;
    // TODO last-modified header
    contentType = contentType || MimeTypes.lookup(path);
    return Q.when(fs.stat(path), function (stat) {
        var etag = exports.etag(stat);
        var options = {
            flags: "rb"
        };
        var range;
        var status = 200;
        var headers = {
            "content-type": contentType,
            etag: etag
        };

        // Partial range requests
        if ("range" in request.headers) {
            // Invalid cache
            if (
                "if-range" in request.headers &amp;&amp;
                etag != request.headers["if-range"]
            ) {
                // Normal 200 for entire, altered content
            } else {
                // Truncate to the first requested continuous range
                range = interpretFirstRange(request.headers["range"], stat.size);
                // Like Apache, ignore the range header if it is invalid
                if (range) {
                    if (range.end &gt; stat.size) {
                        range.end = stat.size;
                    }
                    if (range.end &lt;= range.begin) {
                        return StatusApps.responseForStatus(request, 416); // not satisfiable
                    }
                    status = 206; // partial content
                    headers["content-range"] = (
                        "bytes " +
                        range.begin + "-" + (range.end - 1) +
                        "/" + stat.size
                    );
                    headers["content-length"] = "" + (range.end - range.begin);
                    options.begin = range.begin;
                    options.end = range.end;
                } else {
                    return StatusApps.responseForStatus(request, 416); // not satisfiable
                }
            }
        // Full requests
        } else {
            // Cached
            // We do not use date-based caching
            // TODO consider if-match?
            if (etag == request.headers["if-none-match"])
                return StatusApps.responseForStatus(request, 304);
            headers["content-length"] = "" + stat.size;
        }

        // TODO sendfile
        return {
            status: status,
            headers: headers,
            body: fs.open(path, options),
            file: path,
            range: range
        };
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.handleHtmlFragmentResponse" id="apidoc.element.q-io.http_apps.handleHtmlFragmentResponse">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>handleHtmlFragmentResponse
        <span class="apidocSignatureSpan">(response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleHtmlFragmentResponse = function (response) {
    var htmlFragment = response.htmlFragment;
    delete response.htmlFragment;
    response.headers["content-type"] = "text/html; charset=utf-8";
    response.body = {
        forEach: function (write) {
            write("&lt;!doctype html&gt;\n");
            write("&lt;html&gt;\n");
            write("    &lt;head&gt;\n");
            if (response.htmlTitle !== void 0) {
                write("        &lt;title&gt;" + escapeHtml(response.htmlTitle) + "&lt;/title&gt;\n");
            }
            write("    &lt;/head&gt;\n");
            write("    &lt;body&gt;\n");
            htmlFragment.forEach(function (line) {
                write("        " + line);
            });
            write("    &lt;/body&gt;\n");
            write("&lt;/html&gt;\n");
        }
    };
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.handleJsonResponse" id="apidoc.element.q-io.http_apps.handleJsonResponse">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>handleJsonResponse
        <span class="apidocSignatureSpan">(response, revivier, tab)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleJsonResponse = function (response, revivier, tab) {
    response.headers["content-type"] = "application/json";
    response.body = {
        forEach: function (write) {
            write(JSON.stringify(response.data, revivier, tab));
        }
    };
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.htmlResponseForStatus" id="apidoc.element.q-io.http_apps.htmlResponseForStatus">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>htmlResponseForStatus
        <span class="apidocSignatureSpan">(request, status, message, addendum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">htmlResponseForStatus = function (request, status, message, addendum) {
    return {
        status: status,
        statusMessage: message,
        headers: {},
        htmlTitle: message,
        htmlFragment: {
            forEach: function (write) {
                write("&lt;h1&gt;" + HtmlApps.escapeHtml(message) + "&lt;/h1&gt;\n");
                write("&lt;p&gt;Status: " + status + "&lt;/p&gt;\n");
                if (addendum) {
                    write("&lt;pre&gt;" + HtmlApps.escapeHtml(addendum) + "&lt;/pre&gt;\n");
                }
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.isRedirect" id="apidoc.element.q-io.http_apps.isRedirect">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>isRedirect
        <span class="apidocSignatureSpan">(response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRedirect = function (response) {
    return isRedirect[response.status] || false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// try redirect loop
function next() {
    Q.fcall(function () {
        return app(request, response);
    })
    .then(function (response) {
        if (exports.<span class="apidocCodeKeywordSpan">isRedirect</span>(response)) {
            if (remaining--) {
                request.url = response.headers.location;
                next();
            } else {
                throw new Error("Maximum redirects.");
            }
        } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.json" id="apidoc.element.q-io.http_apps.json">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>json
        <span class="apidocSignatureSpan">(content, reviver, tabs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json = function (content, reviver, tabs) {
    try {
        var json = JSON.stringify(content, reviver, tabs);
    } catch (exception) {
        return Q.reject(exception);
    }
    return Content.ok([json], "application/json");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function(Request):Object} app an application that accepts a
* request and returns a JSON serializable object.
* @returns {App}
*/
exports.Json = function (app, reviver, tabs) {
   return function (request, response) {
       return Q.when(app(request, response), function (object) {
           return exports.<span class="apidocCodeKeywordSpan">json</span>(object, reviver, tabs);
       });
   };
};

/**
* @param {Object} content data to serialize as JSON
* @param {Function} reviver
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.listDirectory" id="apidoc.element.q-io.http_apps.listDirectory">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectory
        <span class="apidocSignatureSpan">(request, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listDirectory = function (request, response) {
    // TODO advisory to have JSON or HTML fragment handler.
    request.location = URL.parse(request.path);
    if (request.location.file) {
        return RedirectApps.redirect(request, request.location.file + "/");
    }
    var handlers = {};
    handlers["text/plain"] = exports.listDirectoryText;
    handlers["text/markdown"] = exports.listDirectoryMarkdown;
    if (request.handleHtmlFragmentResponse) {
        handlers["text/html"] = exports.listDirectoryHtmlFragment;
    }
    if (request.handleJsonResponse) {
        handlers["application/json"] = exports.listDirectoryJson;
    }
    var handleResponse = Negotiation.negotiate(request, handlers) || function () {
        return response;
    };
    return handleResponse(request, response);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.listDirectoryData" id="apidoc.element.q-io.http_apps.listDirectoryData">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryData
        <span class="apidocSignatureSpan">(request, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listDirectoryData = function (request, response) {
    if (!request.fs) {
        throw new Error("Can't list a directory without a designated file system");
    }
    var fs = request.fs;
    return Q.invoke(fs, "list", response.directory)
    .then(function (list) {
        list.sort();
        return list.map(function (name) {
            return Q.invoke(fs, "stat", fs.join(response.directory, name))
            .then(function (stat) {
                if (stat.isDirectory()) {
                    return {name: name, stat: {
                        type: "directory"
                    }};
                } else if (stat.isFile()) {
                    return {name: name, stat: {
                        type: "file"
                    }};
                }
            }, function () {
                // ignore unstatable entries
            });
        })
    })
    .all()
    .then(function (stats) {
        var data = {};
        stats.forEach(function (entry) {
            if (entry) {
                data[entry.name] = entry.stat;
            }
        });
        return data;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.listDirectoryHtmlFragment" id="apidoc.element.q-io.http_apps.listDirectoryHtmlFragment">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryHtmlFragment
        <span class="apidocSignatureSpan">(request, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listDirectoryHtmlFragment = function (request, response) {
    return exports.listDirectoryData(request, response)
    .then(function (data) {
        return {
            status: 200,
            headers: {
                "content-type": "text/html"
            },
            htmlTitle: "Directory Index",
            htmlFragment: {
                forEach: function (write) {
                    write("&lt;ul class=\"directory-index\"&gt;\n");
                    Object.keys(data).sort().forEach(function (name) {
                        var stat = data[name];
                        var suffix = "";
                        if (stat.type === "directory") {
                            suffix = "/";
                        }
                        write("    &lt;li class=\"entry " + stat.type + "\"&gt;&lt;a href=\"" + HtmlApps.escapeHtml(name + suffix) + "\"&gt;" +
HtmlApps.escapeHtml(name + suffix) + "&lt;/a&gt;&lt;/li&gt;\n");
                    });
                    write("&lt;/ul&gt;\n");
                }
            }
        };
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.listDirectoryJson" id="apidoc.element.q-io.http_apps.listDirectoryJson">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryJson
        <span class="apidocSignatureSpan">(request, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listDirectoryJson = function (request, response) {
    return exports.listDirectoryData(request, response)
    .then(function (data) {
        return {
            status: 200,
            headers: {},
            data: data
        };
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.listDirectoryMarkdown" id="apidoc.element.q-io.http_apps.listDirectoryMarkdown">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryMarkdown
        <span class="apidocSignatureSpan">(request, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listDirectoryMarkdown = function (request, response) {
    return exports.listDirectoryData(request, response)
    .then(function (data) {
        return {
            status: 200,
            headers: {
                "content-type": "text/plain"
            },
            body: {
                forEach: function (write) {
                    write("\n# Directory Index\n\n");
                    Object.keys(data).forEach(function (name) {
                        var stat = data[name];
                        var suffix = "";
                        if (stat.type === "directory") {
                            suffix = "/";
                        }
                        write("-   " + name + suffix + "\n");
                    });
                    write("\n");
                }
            }
        };
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.listDirectoryText" id="apidoc.element.q-io.http_apps.listDirectoryText">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>listDirectoryText
        <span class="apidocSignatureSpan">(request, response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listDirectoryText = function (request, response) {
    return exports.listDirectoryData(request, response)
    .then(function (data) {
        return {
            status: 200,
            headers: {
                "content-type": "text/plain"
            },
            body: {
                forEach: function (write) {
                    Object.keys(data).sort().forEach(function (name) {
                        var stat = data[name];
                        var suffix = "";
                        if (stat.type === "directory") {
                            suffix = "/";
                        }
                        write(name + suffix + "\n");
                    });
                }
            }
        };
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.methodNotAllowed" id="apidoc.element.q-io.http_apps.methodNotAllowed">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>methodNotAllowed
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">methodNotAllowed = function (request) {
    return exports.responseForStatus(request, status, request.method + " " + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.negotiate" id="apidoc.element.q-io.http_apps.negotiate">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>negotiate
        <span class="apidocSignatureSpan">(request, types, header)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function negotiate(request, types, header) {
    var keys = Object.keys(types);
    var accept = request.headers[header || "accept"] || "*";
    var best = MimeParse.bestMatch(keys, accept);
    return types[best];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var handlers = {};
handlers["text/plain"] = exports.redirectText;
if (request.handleHtmlFragmentResponse) {
    handlers["text/html"] = exports.redirectHtml;
}
var handler = Negotiation.<span class="apidocCodeKeywordSpan">negotiate</span>(request, handlers) || exports.redirectText;
return handler(request, location, status);

};

exports.redirectText = function (request, location, status) {
var content = (
    (request.permanent ? "Permanent redirect\n" : "Temporary redirect\n") +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.noLanguage" id="apidoc.element.q-io.http_apps.noLanguage">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>noLanguage
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noLanguage = function (request) {
    return exports.responseForStatus(request, status, request.method + " " + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.notAcceptable" id="apidoc.element.q-io.http_apps.notAcceptable">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>notAcceptable
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notAcceptable = function (request) {
    return exports.responseForStatus(request, status, request.method + " " + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.notFound" id="apidoc.element.q-io.http_apps.notFound">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>notFound
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notFound = function (request) {
    return exports.responseForStatus(request, status, request.method + " " + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.ok" id="apidoc.element.q-io.http_apps.ok">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>ok
        <span class="apidocSignatureSpan">(content, contentType, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ok = function (content, contentType, status) {
    status = status || 200;
    content = content || "";
    if (typeof content === "string") {
        content = [content];
    }
    contentType = contentType || "text/plain";
    return {
        "status": status,
        "headers": {
            "content-type": contentType
        },
        "body": content
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
exports.json = function (content, reviver, tabs) {
   try {
       var json = JSON.stringify(content, reviver, tabs);
   } catch (exception) {
       return Q.reject(exception);
   }
   return Content.<span class="apidocCodeKeywordSpan">ok</span>([json], "application/json");
};

/**
* @param {Function(Request, Object):Response} app
* @param {App} badRequest
* @returns {App}
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.permanentRedirect" id="apidoc.element.q-io.http_apps.permanentRedirect">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>permanentRedirect
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">permanentRedirect = function (request, location, status) {
    return exports.redirect(request, location, status || 301);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* @param {String} path
* @param {Number} status (optional) default is `301`
* @returns {App}
*/
exports.PermanentRedirect = function (location, status, tree) {
   return function (request, response) {
       return exports.<span class="apidocCodeKeywordSpan">permanentRedirect</span>(request, location, status, tree);
   };
};

/**
* @param {String} path
* @param {Number} status (optional) default is `301`
* @returns {App}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.permanentRedirectTree" id="apidoc.element.q-io.http_apps.permanentRedirectTree">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>permanentRedirectTree
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">permanentRedirectTree = function (request, location, status) {
    return exports.redirect(request, location, status || 301, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.redirect" id="apidoc.element.q-io.http_apps.redirect">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>redirect
        <span class="apidocSignatureSpan">(request, location, status, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redirect = function (request, location, status, tree) {

    // request.permanent gets set by Permanent middleware
    status = status || (request.permanent ? 301 : 307);

    // ascertain that the location is absolute, per spec
    location = URL.resolve(request.url, location);

    // redirect into a subtree with the remaining unrouted
    // portion of the path, if so configured
    if (tree) {
        location = URL.resolve(
            location,
            request.pathInfo.replace(/^\//, "")
        );
    }

    var handlers = {};
    handlers["text/plain"] = exports.redirectText;
    if (request.handleHtmlFragmentResponse) {
        handlers["text/html"] = exports.redirectHtml;
    }
    var handler = Negotiation.negotiate(request, handlers) || exports.redirectText;
    return handler(request, location, status);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* @param {String} path
* @param {Number} status (optional) default is `307`
* @returns {App}
*/
exports.Redirect = function (location, status, tree) {
   return function (request, response) {
       return exports.<span class="apidocCodeKeywordSpan">redirect</span>(request, location, status, tree);
   };
};

/**
* @param {String} path
* @param {Number} status (optional) default is `307`
* @returns {App}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.redirectHtml" id="apidoc.element.q-io.http_apps.redirectHtml">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>redirectHtml
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redirectHtml = function (request, location, status) {
    var title = request.permanent ? "Permanent redirect" : "Temporary redirect";
    return {
        status: status,
        headers: {
            location: location,
            "content-type": "text/html"
        },
        htmlTitle: title,
        htmlFragment: {
            forEach: function (write) {
                write("&lt;h1&gt;" + HtmlApps.escapeHtml(title) + "&lt;/h1&gt;\n");
                write(
                    "&lt;p&gt;See: &lt;a href=\"" + HtmlApps.escapeHtml(location) + "\"&gt;" +
                    HtmlApps.escapeHtml(location) +
                    "&lt;/a&gt;&lt;/p&gt;\n"
                );
            }
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.redirectText" id="apidoc.element.q-io.http_apps.redirectText">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>redirectText
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redirectText = function (request, location, status) {
    var content = (
        (request.permanent ? "Permanent redirect\n" : "Temporary redirect\n") +
        "See: " + location + "\n"
    );
    var contentLength = content.length;
    return {
        status: status,
        headers: {
            location: location,
            "content-type": "text/plain"
        },
        body: [content]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.redirectTree" id="apidoc.element.q-io.http_apps.redirectTree">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>redirectTree
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redirectTree = function (request, location, status) {
    return exports.redirect(request, location, status, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.responseForStatus" id="apidoc.element.q-io.http_apps.responseForStatus">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>responseForStatus
        <span class="apidocSignatureSpan">(request, status, addendum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">responseForStatus = function (request, status, addendum) {
    if (exports.statusCodes[status] === undefined)
        throw "Unknown status code";

    var message = exports.statusCodes[status];

    // RFC 2616, 10.2.5:
    // The 204 response MUST NOT include a message-body, and thus is always
    // terminated by the first empty line after the header fields.
    // RFC 2616, 10.3.5:
    // The 304 response MUST NOT contain a message-body, and thus is always
    // terminated by the first empty line after the header fields.
    if (exports.statusWithNoEntityBody(status)) {
        return {status: status, headers: {}};
    } else {
        var handlers = {};
        handlers["text/plain"] = exports.textResponseForStatus;
        if (request.handleHtmlFragmentResponse) {
            handlers["text/html"] = exports.htmlResponseForStatus;
        }
        var responseForStatus = Negotiation.negotiate(request, handlers) || exports.textResponseForStatus;
        return responseForStatus(request, status, message, addendum);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {App}
 */
exports.Error = function (app, debug) {
    return function (request, response) {
        return Q.when(app(request, response), null, function (error) {
            if (!debug)
                error = undefined;
            return StatusApps.<span class="apidocCodeKeywordSpan">responseForStatus</span>(request, 500, error &amp;&amp; error
.stack || error);
        });
    };
};

exports.Debug = function (app) {
    return exports.Error(app, true);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.statusWithNoEntityBody" id="apidoc.element.q-io.http_apps.statusWithNoEntityBody">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>statusWithNoEntityBody
        <span class="apidocSignatureSpan">(status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statusWithNoEntityBody = function (status) {
    return (status &gt;= 100 &amp;&amp; status &lt;= 199) ||
        status == 204 || status == 304;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// RFC 2616, 10.2.5:
// The 204 response MUST NOT include a message-body, and thus is always
// terminated by the first empty line after the header fields.
// RFC 2616, 10.3.5:
// The 304 response MUST NOT contain a message-body, and thus is always
// terminated by the first empty line after the header fields.
if (exports.<span class="apidocCodeKeywordSpan">statusWithNoEntityBody</span>(status)) {
    return {status: status, headers: {}};
} else {
    var handlers = {};
    handlers["text/plain"] = exports.textResponseForStatus;
    if (request.handleHtmlFragmentResponse) {
        handlers["text/html"] = exports.htmlResponseForStatus;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.temporaryRedirect" id="apidoc.element.q-io.http_apps.temporaryRedirect">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>temporaryRedirect
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">temporaryRedirect = function (request, location, status) {
    return exports.redirect(request, location, status || 307);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* @param {String} path
* @param {Number} status (optional) default is `307`
* @returns {App}
*/
exports.TemporaryRedirect = function (location, status, tree) {
   return function (request, response) {
       return exports.<span class="apidocCodeKeywordSpan">temporaryRedirect</span>(request, location, status, tree);
   };
};

/**
* @param {String} path
* @param {Number} status (optional) default is `307`
* @returns {App}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.temporaryRedirectTree" id="apidoc.element.q-io.http_apps.temporaryRedirectTree">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>temporaryRedirectTree
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">temporaryRedirectTree = function (request, location, status) {
    return exports.redirect(request, location, status || 307, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_apps.textResponseForStatus" id="apidoc.element.q-io.http_apps.textResponseForStatus">
        function <span class="apidocSignatureSpan">q-io.http_apps.</span>textResponseForStatus
        <span class="apidocSignatureSpan">(request, status, message, addendum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">textResponseForStatus = function (request, status, message, addendum) {
    var content = message + "\n";
    if (addendum) {
        content += addendum + "\n";
    }
    var contentLength = content.length;
    return {
        status: status,
        statusMessage: message,
        headers: {
            "content-length": contentLength
        },
        body: [content]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.http_cookie" id="apidoc.module.q-io.http_cookie">module q-io.http_cookie</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.http_cookie.parse" id="apidoc.element.q-io.http_cookie.parse">
        function <span class="apidocSignatureSpan">q-io.http_cookie.</span>parse
        <span class="apidocSignatureSpan">(cookie, date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (cookie, date) {
    date = date || new Date();
    var parsed = {};
    var terms = cookie.split(/[;,]/g);
    var keyValue = terms.shift().split("=");
    parsed.key = decodeURIComponent(keyValue[0]);
    parsed.value = decodeURIComponent(keyValue[1]);
    terms.forEach(function (term) {
        var parts = term.split("=").map(function (part) {
            return part.trim();
        });
        var key = parts[0], value = parts[1];
        if (/^domain$/i.test(key)) {
            parsed.domain = value;
        } else if (/^path$/i.test(key)) {
            parsed.path = value;
        } else if (/^expires$/i.test(key)) {
            parsed.expires = new Date(
                +new Date() + // actual now
                (new Date(value) - date) // server offset
            );
        } else if (/^max-age$/i.test(key)) {
            parsed.expires = new Date(
                new Date().getTime() +
                (value * 1000)
            );
        } else if (/^secure$/i.test(key)) {
            parsed.secure = true;
        } else if (/^httponly$/i.test(key)) {
            parsed.httpOnly = true;
        }
    });
    return parsed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.Client = Client;
function Client(fs) {
var self = Object.create(Client.prototype);

self.request = function (request) {
    return Q.when(request, function (request) {
        request = HTTP.normalizeRequest(request);
        var url = URL.<span class="apidocCodeKeywordSpan">parse</span>(request.url);
        if (url.protocol !== "file:") {
            return {
                status: 404,
                headers: {},
                body: ["Can't access protocol " + url.protocol]
            };
        } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.http_cookie.stringify" id="apidoc.element.q-io.http_cookie.stringify">
        function <span class="apidocSignatureSpan">q-io.http_cookie.</span>stringify
        <span class="apidocSignatureSpan">(key, value, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (key, value, options) {
    var cookie = (
        encodeURIComponent(key) + "=" +
        encodeURIComponent(value)
    );
    if (options) {
        if (options.domain)
            cookie += "; Domain=" + encodeURIComponent(options.domain);
        if (options.path)
            cookie += "; Path=" + encodeURIComponent(options.path);
        if (options.expires)
            cookie += "; Expires=" + options.expires.toGMTString();
        if (options.secure)
            cookie += "; Secure";
        if (options.httpOnly)
            cookie += "; HttpOnly";
    }
    return cookie;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {Array * String}
 */
exports.split = function (path) {
var parts;
try {
    parts = String(path).split(exports.SEPARATORS_RE());
} catch (exception) {
    throw new Error("Cannot split " + (typeof path) + ", " + JSON.<span class="apidocCodeKeywordSpan">stringify
</span>(path));
}
// this special case helps isAbsolute
// distinguish an empty path from an absolute path
// "" -&gt; [] NOT [""]
if (parts.length === 1 &amp;&amp; parts[0] === "")
    return [];
// "a" -&gt; ["a"]
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.json" id="apidoc.module.q-io.json">module q-io.json</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.json.json" id="apidoc.element.q-io.json.json">
        function <span class="apidocSignatureSpan">q-io.</span>json
        <span class="apidocSignatureSpan">(content, reviver, tabs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json = function (content, reviver, tabs) {
    try {
        var json = JSON.stringify(content, reviver, tabs);
    } catch (exception) {
        return Q.reject(exception);
    }
    return Content.ok([json], "application/json");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function(Request):Object} app an application that accepts a
* request and returns a JSON serializable object.
* @returns {App}
*/
exports.Json = function (app, reviver, tabs) {
   return function (request, response) {
       return Q.when(app(request, response), function (object) {
           return exports.<span class="apidocCodeKeywordSpan">json</span>(object, reviver, tabs);
       });
   };
};

/**
* @param {Object} content data to serialize as JSON
* @param {Function} reviver
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.json.HandleJsonResponses" id="apidoc.element.q-io.json.HandleJsonResponses">
        function <span class="apidocSignatureSpan">q-io.json.</span>HandleJsonResponses
        <span class="apidocSignatureSpan">(app, reviver, tab)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">HandleJsonResponses = function (app, reviver, tab) {
    return function (request) {
        request.handleJsonResponse = exports.handleJsonResponse;
        return Q.fcall(app, request)
        .then(function (response) {
            if (response.data !== void 0) {
                return Q.fcall(exports.handleJsonResponse, response, reviver, tab);
            } else {
                return response;
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.json.Json" id="apidoc.element.q-io.json.Json">
        function <span class="apidocSignatureSpan">q-io.json.</span>Json
        <span class="apidocSignatureSpan">(app, reviver, tabs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Json = function (app, reviver, tabs) {
    return function (request, response) {
        return Q.when(app(request, response), function (object) {
            return exports.json(object, reviver, tabs);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.json.JsonRequest" id="apidoc.element.q-io.json.JsonRequest">
        function <span class="apidocSignatureSpan">q-io.json.</span>JsonRequest
        <span class="apidocSignatureSpan">(app, badRequest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JsonRequest = function (app, badRequest) {
    if (!badRequest)
        badRequest = Status.badRequest;
    return Content.ContentRequest(function (content, request, response) {
        try {
            var object = JSON.parse(content);
        } catch (error) {
            return badRequest(request, error);
        }
        return app(object, request, response);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.json.handleJsonResponse" id="apidoc.element.q-io.json.handleJsonResponse">
        function <span class="apidocSignatureSpan">q-io.json.</span>handleJsonResponse
        <span class="apidocSignatureSpan">(response, revivier, tab)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleJsonResponse = function (response, revivier, tab) {
    response.headers["content-type"] = "application/json";
    response.body = {
        forEach: function (write) {
            write(JSON.stringify(response.data, revivier, tab));
        }
    };
    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.negotiate" id="apidoc.module.q-io.negotiate">module q-io.negotiate</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.negotiate.negotiate" id="apidoc.element.q-io.negotiate.negotiate">
        function <span class="apidocSignatureSpan">q-io.</span>negotiate
        <span class="apidocSignatureSpan">(request, types, header)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function negotiate(request, types, header) {
    var keys = Object.keys(types);
    var accept = request.headers[header || "accept"] || "*";
    var best = MimeParse.bestMatch(keys, accept);
    return types[best];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var handlers = {};
handlers["text/plain"] = exports.redirectText;
if (request.handleHtmlFragmentResponse) {
    handlers["text/html"] = exports.redirectHtml;
}
var handler = Negotiation.<span class="apidocCodeKeywordSpan">negotiate</span>(request, handlers) || exports.redirectText;
return handler(request, location, status);

};

exports.redirectText = function (request, location, status) {
var content = (
    (request.permanent ? "Permanent redirect\n" : "Temporary redirect\n") +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.negotiate.Charset" id="apidoc.element.q-io.negotiate.Charset">
        function <span class="apidocSignatureSpan">q-io.negotiate.</span>Charset
        <span class="apidocSignatureSpan">(types, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Charset = function (types, notAcceptable) {
    var keys = Object.keys(types);
    if (!notAcceptable)
        notAcceptable = Status.notAcceptable;
    return function (request) {
        var accept = request.headers[requestHeader] || "*";
        var type = MimeParse.bestMatch(keys, accept);
        request.terms = request.terms || {};
        request.terms[responseHeader] = type;
        if (Object.has(keys, type)) {
            return Q.when(types[type](request), function (response) {
                if (
                    respond !== null &amp;&amp;
                    response &amp;&amp;
                    response.status === 200 &amp;&amp;
                    response.headers
                ) {
                    response.headers[responseHeader] = type;
                }
                return response;
            });
        } else {
            return notAcceptable(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.negotiate.ContentType" id="apidoc.element.q-io.negotiate.ContentType">
        function <span class="apidocSignatureSpan">q-io.negotiate.</span>ContentType
        <span class="apidocSignatureSpan">(types, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ContentType = function (types, notAcceptable) {
    var keys = Object.keys(types);
    if (!notAcceptable)
        notAcceptable = Status.notAcceptable;
    return function (request) {
        var accept = request.headers[requestHeader] || "*";
        var type = MimeParse.bestMatch(keys, accept);
        request.terms = request.terms || {};
        request.terms[responseHeader] = type;
        if (Object.has(keys, type)) {
            return Q.when(types[type](request), function (response) {
                if (
                    respond !== null &amp;&amp;
                    response &amp;&amp;
                    response.status === 200 &amp;&amp;
                    response.headers
                ) {
                    response.headers[responseHeader] = type;
                }
                return response;
            });
        } else {
            return notAcceptable(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.negotiate.Encoding" id="apidoc.element.q-io.negotiate.Encoding">
        function <span class="apidocSignatureSpan">q-io.negotiate.</span>Encoding
        <span class="apidocSignatureSpan">(types, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Encoding = function (types, notAcceptable) {
    var keys = Object.keys(types);
    if (!notAcceptable)
        notAcceptable = Status.notAcceptable;
    return function (request) {
        var accept = request.headers[requestHeader] || "*";
        var type = MimeParse.bestMatch(keys, accept);
        request.terms = request.terms || {};
        request.terms[responseHeader] = type;
        if (Object.has(keys, type)) {
            return Q.when(types[type](request), function (response) {
                if (
                    respond !== null &amp;&amp;
                    response &amp;&amp;
                    response.status === 200 &amp;&amp;
                    response.headers
                ) {
                    response.headers[responseHeader] = type;
                }
                return response;
            });
        } else {
            return notAcceptable(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.negotiate.Host" id="apidoc.element.q-io.negotiate.Host">
        function <span class="apidocSignatureSpan">q-io.negotiate.</span>Host
        <span class="apidocSignatureSpan">(appForHost, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Host = function (appForHost, notAcceptable) {
    var table = Object.keys(appForHost).map(function (pattern) {
        var parts = pattern.split(":");
        return [
            pattern,
            parts[0] || "*",
            parts[1] || "*",
            appForHost[pattern]
        ];
    });
    if (!notAcceptable) {
        notAcceptable = Status.notAcceptable;
    }
    return function (request) {
        // find first matching host for app
        for (var index = 0; index &lt; table.length; index++) {
            var row = table[index]; // [hostname, port, app]
            var pattern = row[0];
            var hostname = row[1];
            var port = row[2];
            var app = row[3];
            if (
                (hostname === "*" || hostname === request.hostname) &amp;&amp;
                (port === "*" || port === "" + request.port)
            ) {
                request.terms = request.terms || {};
                request.terms.host = pattern;
                return app(request);
            }
        }
        return notAcceptable(request);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.negotiate.Language" id="apidoc.element.q-io.negotiate.Language">
        function <span class="apidocSignatureSpan">q-io.negotiate.</span>Language
        <span class="apidocSignatureSpan">(types, notAcceptable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Language = function (types, notAcceptable) {
    var keys = Object.keys(types);
    if (!notAcceptable)
        notAcceptable = Status.notAcceptable;
    return function (request) {
        var accept = request.headers[requestHeader] || "*";
        var type = MimeParse.bestMatch(keys, accept);
        request.terms = request.terms || {};
        request.terms[responseHeader] = type;
        if (Object.has(keys, type)) {
            return Q.when(types[type](request), function (response) {
                if (
                    respond !== null &amp;&amp;
                    response &amp;&amp;
                    response.status === 200 &amp;&amp;
                    response.headers
                ) {
                    response.headers[responseHeader] = type;
                }
                return response;
            });
        } else {
            return notAcceptable(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.negotiate.Method" id="apidoc.element.q-io.negotiate.Method">
        function <span class="apidocSignatureSpan">q-io.negotiate.</span>Method
        <span class="apidocSignatureSpan">(methods, methodNotAllowed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Method = function (methods, methodNotAllowed) {
    var keys = Object.keys(methods);
    if (!methodNotAllowed)
        methodNotAllowed = Status.methodNotAllowed;
    return function (request) {
        var method = request.method;
        if (Object.has(keys, method)) {
            return Object.get(methods, method)(request);
        } else {
            return methodNotAllowed(request);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * @param {Function(Request):Object}
 * @returns {App}
 */
exports.Inspect = function (app) {
return Negotiate.<span class="apidocCodeKeywordSpan">Method</span>({"GET": function (request, response) {
    return Q.when(app(request, response), function (object) {
        return {
            status: 200,
            headers: {
                "content-type": "text/plain"
            },
            body: [inspect(object)]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.negotiate.Select" id="apidoc.element.q-io.negotiate.Select">
        function <span class="apidocSignatureSpan">q-io.negotiate.</span>Select
        <span class="apidocSignatureSpan">(select)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Select = function (select) {
    return function (request) {
        return Q.when(select(request), function (app) {
            return app(request);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.proxy" id="apidoc.module.q-io.proxy">module q-io.proxy</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.proxy.Proxy" id="apidoc.element.q-io.proxy.Proxy">
        function <span class="apidocSignatureSpan">q-io.proxy.</span>Proxy
        <span class="apidocSignatureSpan">(app)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Proxy = function (app) {
    if (typeof app === "string") {
        var location = app;
        app = function (request) {
            request.url = location;
            return request;
        };
    }
    return function (request, response) {
        return Q.when(app.apply(this, arguments), function (request) {
            return HTTP.request(request);
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return Q.when(app.apply(this, arguments), function (request) {
            return HTTP.request(request);
        });
    };
};

exports.ProxyTree = function (url) {
    return exports.<span class="apidocCodeKeywordSpan">Proxy</span>(function (request) {
        request.url = URL.resolve(url, request.pathInfo.replace(/^\//, ""));
        return request;
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.proxy.ProxyTree" id="apidoc.element.q-io.proxy.ProxyTree">
        function <span class="apidocSignatureSpan">q-io.proxy.</span>ProxyTree
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ProxyTree = function (url) {
    return exports.Proxy(function (request) {
        request.url = URL.resolve(url, request.pathInfo.replace(/^\//, ""));
        return request;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.reader" id="apidoc.module.q-io.reader">module q-io.reader</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.reader.reader" id="apidoc.element.q-io.reader.reader">
        function <span class="apidocSignatureSpan">q-io.</span>reader
        <span class="apidocSignatureSpan">(_stream, charset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(_stream, charset) {
    var self = Object.create(Reader.prototype);

    if (charset &amp;&amp; _stream.setEncoding) // TODO complain about inconsistency
        _stream.setEncoding(charset);

    var begin = Q.defer();
    var end = Q.defer();

    _stream.on("error", function (reason) {
        begin.reject(reason);
    });

    var chunks = [];
    var receiver;

    _stream.on("end", function () {
        begin.resolve(self);
        end.resolve()
    });

    _stream.on("data", function (chunk) {
        begin.resolve(self);
        if (receiver) {
            receiver(chunk);
        } else {
            chunks.push(chunk);
        }
    });

    function slurp() {
        var result;
        if (charset) {
            result = chunks.join("");
        } else {
            result = self.constructor.join(chunks);
        }
        chunks.splice(0, chunks.length);
        return result;
    }

<span class="apidocCodeCommentSpan">    /***
     * Reads all of the remaining data from the stream.
     * @returns {Promise * String} a promise for a String
     * containing the entirety the remaining stream.
     */
</span>    self.read = function () {
        receiver = undefined;
        var deferred = Q.defer();
        Q.done(end.promise, function () {
            deferred.resolve(slurp());
        });
        return deferred.promise;
    };

    /***
     * Reads and writes all of the remaining data from the
     * stream in chunks.
     * @param {Function(Promise * String)} write a function
     * to be called on each chunk of input from this stream.
     * @returns {Promise * Undefined} a promise that will
     * be resolved when the input is depleted.
     */
    self.forEach = function (write) {
        if (chunks &amp;&amp; chunks.length)
            write(slurp());
        receiver = write;
        return Q.when(end.promise, function () {
            receiver = undefined;
        });
    };

    self.close = function () {
        _stream.destroy();
    };

    self.node = _stream;

    return begin.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.reader.join" id="apidoc.element.q-io.reader.join">
        function <span class="apidocSignatureSpan">q-io.reader.</span>join
        <span class="apidocSignatureSpan">(buffers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function join(buffers) {
    var length = 0;
    var at;
    var i;
    var ii = buffers.length;
    var buffer;
    var result;
    for (i = 0; i &lt; ii; i++) {
        buffer = buffers[i];
        length += buffer.length;
    }
    result = new Buffer(length);
    at = 0;
    for (i = 0; i &lt; ii; i++) {
        buffer = buffers[i];
        buffer.copy(result, at, 0);
        at += buffer.length;
    }
    buffers.splice(0, ii, result);
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return Q.fcall(function () {
        chunks.splice(0, chunks.length).forEach(write, thisp);
    });
};

BufferStream.prototype.read = function () {
    var result;
    result = Reader.<span class="apidocCodeKeywordSpan">join</span>(this._chunks);
    if (this._charset) {
        result = result.toString(this._charset);
    }
    return Q.resolve(result);
};

BufferStream.prototype.write = function (chunk) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.reader.read" id="apidoc.element.q-io.reader.read">
        function <span class="apidocSignatureSpan">q-io.reader.</span>read
        <span class="apidocSignatureSpan">(stream, charset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read(stream, charset) {
    var chunks = [];
    stream.forEach(function (chunk) {
        chunks.push(chunk);
    });
    if (charset) {
        return chunks.join("");
    } else {
        return join(chunks);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
into memory.  It returns a promise for the whole file contents.  By
default, `read` provides a string decoded from UTF-8.  With the bytewise
mode flag, provides a `Buffer`.

The options argument is identical to that of `open`.

```javascript
return FS.<span class="apidocCodeKeywordSpan">read</span>(__filename, "b")
.then(function (content) {
    // ...
})
```

```javascript
return FS.read(__filename, {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.redirect" id="apidoc.module.q-io.redirect">module q-io.redirect</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.redirect.redirect" id="apidoc.element.q-io.redirect.redirect">
        function <span class="apidocSignatureSpan">q-io.</span>redirect
        <span class="apidocSignatureSpan">(request, location, status, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redirect = function (request, location, status, tree) {

    // request.permanent gets set by Permanent middleware
    status = status || (request.permanent ? 301 : 307);

    // ascertain that the location is absolute, per spec
    location = URL.resolve(request.url, location);

    // redirect into a subtree with the remaining unrouted
    // portion of the path, if so configured
    if (tree) {
        location = URL.resolve(
            location,
            request.pathInfo.replace(/^\//, "")
        );
    }

    var handlers = {};
    handlers["text/plain"] = exports.redirectText;
    if (request.handleHtmlFragmentResponse) {
        handlers["text/html"] = exports.redirectHtml;
    }
    var handler = Negotiation.negotiate(request, handlers) || exports.redirectText;
    return handler(request, location, status);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* @param {String} path
* @param {Number} status (optional) default is `307`
* @returns {App}
*/
exports.Redirect = function (location, status, tree) {
   return function (request, response) {
       return exports.<span class="apidocCodeKeywordSpan">redirect</span>(request, location, status, tree);
   };
};

/**
* @param {String} path
* @param {Number} status (optional) default is `307`
* @returns {App}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.PermanentRedirect" id="apidoc.element.q-io.redirect.PermanentRedirect">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>PermanentRedirect
        <span class="apidocSignatureSpan">(location, status, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PermanentRedirect = function (location, status, tree) {
    return function (request, response) {
        return exports.permanentRedirect(request, location, status, tree);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.PermanentRedirectTree" id="apidoc.element.q-io.redirect.PermanentRedirectTree">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>PermanentRedirectTree
        <span class="apidocSignatureSpan">(location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PermanentRedirectTree = function (location, status) {
    return function (request, response) {
        return exports.permanentRedirect(request, location, status, true);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.Redirect" id="apidoc.element.q-io.redirect.Redirect">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>Redirect
        <span class="apidocSignatureSpan">(location, status, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Redirect = function (location, status, tree) {
    return function (request, response) {
        return exports.redirect(request, location, status, tree);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.RedirectTrap" id="apidoc.element.q-io.redirect.RedirectTrap">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>RedirectTrap
        <span class="apidocSignatureSpan">(app, maxRedirects)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RedirectTrap = function (app, maxRedirects) {
    maxRedirects = maxRedirects || 20;
    return function (request, response) {
        var remaining = maxRedirects;
        var deferred = Q.defer();
        var self = this;
        var args = arguments;

        request = Http.normalizeRequest(request);

        // try redirect loop
        function next() {
            Q.fcall(function () {
                return app(request, response);
            })
            .then(function (response) {
                if (exports.isRedirect(response)) {
                    if (remaining--) {
                        request.url = response.headers.location;
                        next();
                    } else {
                        throw new Error("Maximum redirects.");
                    }
                } else {
                    deferred.resolve(response);
                }
            })
            .fail(deferred.reject)
        }
        next();

        return deferred.promise;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.RedirectTree" id="apidoc.element.q-io.redirect.RedirectTree">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>RedirectTree
        <span class="apidocSignatureSpan">(location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RedirectTree = function (location, status) {
    return function (request, response) {
        return exports.redirect(request, location, status, true);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.TemporaryRedirect" id="apidoc.element.q-io.redirect.TemporaryRedirect">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>TemporaryRedirect
        <span class="apidocSignatureSpan">(location, status, tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TemporaryRedirect = function (location, status, tree) {
    return function (request, response) {
        return exports.temporaryRedirect(request, location, status, tree);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.TemporaryRedirectTree" id="apidoc.element.q-io.redirect.TemporaryRedirectTree">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>TemporaryRedirectTree
        <span class="apidocSignatureSpan">(location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TemporaryRedirectTree = function (location, status) {
    return function (request, response) {
        return exports.temporaryRedirect(request, location, status, true);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.isRedirect" id="apidoc.element.q-io.redirect.isRedirect">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>isRedirect
        <span class="apidocSignatureSpan">(response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRedirect = function (response) {
    return isRedirect[response.status] || false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// try redirect loop
function next() {
    Q.fcall(function () {
        return app(request, response);
    })
    .then(function (response) {
        if (exports.<span class="apidocCodeKeywordSpan">isRedirect</span>(response)) {
            if (remaining--) {
                request.url = response.headers.location;
                next();
            } else {
                throw new Error("Maximum redirects.");
            }
        } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.permanentRedirect" id="apidoc.element.q-io.redirect.permanentRedirect">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>permanentRedirect
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">permanentRedirect = function (request, location, status) {
    return exports.redirect(request, location, status || 301);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* @param {String} path
* @param {Number} status (optional) default is `301`
* @returns {App}
*/
exports.PermanentRedirect = function (location, status, tree) {
   return function (request, response) {
       return exports.<span class="apidocCodeKeywordSpan">permanentRedirect</span>(request, location, status, tree);
   };
};

/**
* @param {String} path
* @param {Number} status (optional) default is `301`
* @returns {App}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.permanentRedirectTree" id="apidoc.element.q-io.redirect.permanentRedirectTree">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>permanentRedirectTree
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">permanentRedirectTree = function (request, location, status) {
    return exports.redirect(request, location, status || 301, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.redirectHtml" id="apidoc.element.q-io.redirect.redirectHtml">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>redirectHtml
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redirectHtml = function (request, location, status) {
    var title = request.permanent ? "Permanent redirect" : "Temporary redirect";
    return {
        status: status,
        headers: {
            location: location,
            "content-type": "text/html"
        },
        htmlTitle: title,
        htmlFragment: {
            forEach: function (write) {
                write("&lt;h1&gt;" + HtmlApps.escapeHtml(title) + "&lt;/h1&gt;\n");
                write(
                    "&lt;p&gt;See: &lt;a href=\"" + HtmlApps.escapeHtml(location) + "\"&gt;" +
                    HtmlApps.escapeHtml(location) +
                    "&lt;/a&gt;&lt;/p&gt;\n"
                );
            }
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.redirectText" id="apidoc.element.q-io.redirect.redirectText">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>redirectText
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redirectText = function (request, location, status) {
    var content = (
        (request.permanent ? "Permanent redirect\n" : "Temporary redirect\n") +
        "See: " + location + "\n"
    );
    var contentLength = content.length;
    return {
        status: status,
        headers: {
            location: location,
            "content-type": "text/plain"
        },
        body: [content]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.redirectTree" id="apidoc.element.q-io.redirect.redirectTree">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>redirectTree
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redirectTree = function (request, location, status) {
    return exports.redirect(request, location, status, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.temporaryRedirect" id="apidoc.element.q-io.redirect.temporaryRedirect">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>temporaryRedirect
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">temporaryRedirect = function (request, location, status) {
    return exports.redirect(request, location, status || 307);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* @param {String} path
* @param {Number} status (optional) default is `307`
* @returns {App}
*/
exports.TemporaryRedirect = function (location, status, tree) {
   return function (request, response) {
       return exports.<span class="apidocCodeKeywordSpan">temporaryRedirect</span>(request, location, status, tree);
   };
};

/**
* @param {String} path
* @param {Number} status (optional) default is `307`
* @returns {App}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.redirect.temporaryRedirectTree" id="apidoc.element.q-io.redirect.temporaryRedirectTree">
        function <span class="apidocSignatureSpan">q-io.redirect.</span>temporaryRedirectTree
        <span class="apidocSignatureSpan">(request, location, status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">temporaryRedirectTree = function (request, location, status) {
    return exports.redirect(request, location, status || 307, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.route" id="apidoc.module.q-io.route">module q-io.route</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.route.Branch" id="apidoc.element.q-io.route.Branch">
        function <span class="apidocSignatureSpan">q-io.route.</span>Branch
        <span class="apidocSignatureSpan">(paths, notFound)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Branch = function (paths, notFound) {
    if (!paths)
        paths = {};
    if (!notFound)
        notFound = StatusApps.notFound;
    return function (request, response) {
        if (!/^\//.test(request.pathInfo)) {
            return notFound(request, response);
        }
        var path = request.pathInfo.slice(1);
        var parts = path.split("/");
        var part = decodeURIComponent(parts.shift());
        if (Object.has(paths, part)) {
            request.scriptName = request.scriptName + part + "/";
            request.pathInfo = path.slice(part.length);
            return Object.get(paths, part)(request, response);
        }
        return notFound(request, response);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.route.Cap" id="apidoc.element.q-io.route.Cap">
        function <span class="apidocSignatureSpan">q-io.route.</span>Cap
        <span class="apidocSignatureSpan">(app, notFound)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Cap = function (app, notFound) {
    notFound = notFound || StatusApps.notFound;
    return function (request, response) {
        // TODO Distinguish these cases
        if (request.pathInfo === "" || request.pathInfo === "/") {
            return app(request, response);
        } else {
            return notFound(request, response);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.route.FirstFound" id="apidoc.element.q-io.route.FirstFound">
        function <span class="apidocSignatureSpan">q-io.route.</span>FirstFound
        <span class="apidocSignatureSpan">(cascade)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FirstFound = function (cascade) {
    return function (request, response) {
        var i = 0, ii = cascade.length;
        function next() {
            var response = cascade[i++](request, response);
            if (i &lt; ii) {
                return Q.when(response, function (response) {
                    if (response.status === 404) {
                        return next();
                    } else {
                        return response;
                    }
                });
            } else {
                return response;
            }
        }
        return next();
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.route.Tap" id="apidoc.element.q-io.route.Tap">
        function <span class="apidocSignatureSpan">q-io.route.</span>Tap
        <span class="apidocSignatureSpan">(app, tap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Tap = function (app, tap) {
    return function (request, response) {
        var self = this, args = arguments;
        return Q.when(tap.apply(this, arguments), function (response) {
            if (response) {
                return response;
            } else {
                return app.apply(self, args);
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    24 * // h
    365 * // d
    10; // years
exports.Permanent = function (app, future) {
    future = future || function () {
        return new Date(new Date().getTime() + farFuture);
    };
    app = RouteApps.<span class="apidocCodeKeywordSpan">Tap</span>(app, function (request, response) {
        request.permanent = future;
    });
    app = RouteApps.Trap(app, function (response, request) {
        response.headers["expires"] = "" + future();
    });
    return app;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.route.Trap" id="apidoc.element.q-io.route.Trap">
        function <span class="apidocSignatureSpan">q-io.route.</span>Trap
        <span class="apidocSignatureSpan">(app, trap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Trap = function (app, trap) {
    return function (request, response) {
        return Q.when(app.apply(this, arguments), function (response) {
            if (response) {
                response.headers = response.headers || {};
                return trap(response, request) || response;
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   };
};

exports.Date = function (app, present) {
   present = present || function () {
       return new Date();
   };
   return RouteApps.<span class="apidocCodeKeywordSpan">Trap</span>(app, function (response, request) {
       response.headers["date"] = "" + present();
   });
};

/**
* Decorates a JSGI application such that rejected response promises
* get translated into `500` server error responses with no content.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.q-io.status" id="apidoc.module.q-io.status">module q-io.status</a></h1>


    <h2>
        <a href="#apidoc.element.q-io.status.appForStatus" id="apidoc.element.q-io.status.appForStatus">
        function <span class="apidocSignatureSpan">q-io.status.</span>appForStatus
        <span class="apidocSignatureSpan">(status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appForStatus = function (status) {
    return function (request) {
        return exports.responseForStatus(request, status, request.method + " " + request.path);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       }
   }
};

/**
* {App} an application that returns a 400 response.
*/
exports.badRequest = exports.<span class="apidocCodeKeywordSpan">appForStatus</span>(400);
/**
* {App} an application that returns a 404 response.
*/
exports.notFound = exports.appForStatus(404);
/**
* {App} an application that returns a 405 response.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.badRequest" id="apidoc.element.q-io.status.badRequest">
        function <span class="apidocSignatureSpan">q-io.status.</span>badRequest
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">badRequest = function (request) {
    return exports.responseForStatus(request, status, request.method + " " + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.htmlResponseForStatus" id="apidoc.element.q-io.status.htmlResponseForStatus">
        function <span class="apidocSignatureSpan">q-io.status.</span>htmlResponseForStatus
        <span class="apidocSignatureSpan">(request, status, message, addendum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">htmlResponseForStatus = function (request, status, message, addendum) {
    return {
        status: status,
        statusMessage: message,
        headers: {},
        htmlTitle: message,
        htmlFragment: {
            forEach: function (write) {
                write("&lt;h1&gt;" + HtmlApps.escapeHtml(message) + "&lt;/h1&gt;\n");
                write("&lt;p&gt;Status: " + status + "&lt;/p&gt;\n");
                if (addendum) {
                    write("&lt;pre&gt;" + HtmlApps.escapeHtml(addendum) + "&lt;/pre&gt;\n");
                }
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.methodNotAllowed" id="apidoc.element.q-io.status.methodNotAllowed">
        function <span class="apidocSignatureSpan">q-io.status.</span>methodNotAllowed
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">methodNotAllowed = function (request) {
    return exports.responseForStatus(request, status, request.method + " " + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.noLanguage" id="apidoc.element.q-io.status.noLanguage">
        function <span class="apidocSignatureSpan">q-io.status.</span>noLanguage
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noLanguage = function (request) {
    return exports.responseForStatus(request, status, request.method + " " + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.notAcceptable" id="apidoc.element.q-io.status.notAcceptable">
        function <span class="apidocSignatureSpan">q-io.status.</span>notAcceptable
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notAcceptable = function (request) {
    return exports.responseForStatus(request, status, request.method + " " + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.notFound" id="apidoc.element.q-io.status.notFound">
        function <span class="apidocSignatureSpan">q-io.status.</span>notFound
        <span class="apidocSignatureSpan">(request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notFound = function (request) {
    return exports.responseForStatus(request, status, request.method + " " + request.path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.responseForStatus" id="apidoc.element.q-io.status.responseForStatus">
        function <span class="apidocSignatureSpan">q-io.status.</span>responseForStatus
        <span class="apidocSignatureSpan">(request, status, addendum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">responseForStatus = function (request, status, addendum) {
    if (exports.statusCodes[status] === undefined)
        throw "Unknown status code";

    var message = exports.statusCodes[status];

    // RFC 2616, 10.2.5:
    // The 204 response MUST NOT include a message-body, and thus is always
    // terminated by the first empty line after the header fields.
    // RFC 2616, 10.3.5:
    // The 304 response MUST NOT contain a message-body, and thus is always
    // terminated by the first empty line after the header fields.
    if (exports.statusWithNoEntityBody(status)) {
        return {status: status, headers: {}};
    } else {
        var handlers = {};
        handlers["text/plain"] = exports.textResponseForStatus;
        if (request.handleHtmlFragmentResponse) {
            handlers["text/html"] = exports.htmlResponseForStatus;
        }
        var responseForStatus = Negotiation.negotiate(request, handlers) || exports.textResponseForStatus;
        return responseForStatus(request, status, message, addendum);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {App}
 */
exports.Error = function (app, debug) {
    return function (request, response) {
        return Q.when(app(request, response), null, function (error) {
            if (!debug)
                error = undefined;
            return StatusApps.<span class="apidocCodeKeywordSpan">responseForStatus</span>(request, 500, error &amp;&amp; error
.stack || error);
        });
    };
};

exports.Debug = function (app) {
    return exports.Error(app, true);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.statusWithNoEntityBody" id="apidoc.element.q-io.status.statusWithNoEntityBody">
        function <span class="apidocSignatureSpan">q-io.status.</span>statusWithNoEntityBody
        <span class="apidocSignatureSpan">(status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statusWithNoEntityBody = function (status) {
    return (status &gt;= 100 &amp;&amp; status &lt;= 199) ||
        status == 204 || status == 304;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// RFC 2616, 10.2.5:
// The 204 response MUST NOT include a message-body, and thus is always
// terminated by the first empty line after the header fields.
// RFC 2616, 10.3.5:
// The 304 response MUST NOT contain a message-body, and thus is always
// terminated by the first empty line after the header fields.
if (exports.<span class="apidocCodeKeywordSpan">statusWithNoEntityBody</span>(status)) {
    return {status: status, headers: {}};
} else {
    var handlers = {};
    handlers["text/plain"] = exports.textResponseForStatus;
    if (request.handleHtmlFragmentResponse) {
        handlers["text/html"] = exports.htmlResponseForStatus;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.q-io.status.textResponseForStatus" id="apidoc.element.q-io.status.textResponseForStatus">
        function <span class="apidocSignatureSpan">q-io.status.</span>textResponseForStatus
        <span class="apidocSignatureSpan">(request, status, message, addendum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">textResponseForStatus = function (request, status, message, addendum) {
    var content = message + "\n";
    if (addendum) {
        content += addendum + "\n";
    }
    var contentLength = content.length;
    return {
        status: status,
        statusMessage: message,
        headers: {
            "content-length": contentLength
        },
        body: [content]
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>